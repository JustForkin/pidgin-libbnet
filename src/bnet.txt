# 1 "src/bnet.c"
# 1 "/home/nbook/pidgin-libbnet//"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "src/bnet.c"
# 24 "src/bnet.c"
# 1 "src/bnet.h" 1
# 30 "src/bnet.h"
# 1 "/usr/include/glib-2.0/glib.h" 1
# 32 "/usr/include/glib-2.0/glib.h"
# 1 "/usr/include/glib-2.0/glib/galloca.h" 1
# 34 "/usr/include/glib-2.0/glib/galloca.h"
# 1 "/usr/include/glib-2.0/glib/gtypes.h" 1
# 34 "/usr/include/glib-2.0/glib/gtypes.h"
# 1 "/usr/lib64/glib-2.0/include/glibconfig.h" 1
# 9 "/usr/lib64/glib-2.0/include/glibconfig.h"
# 1 "/usr/include/glib-2.0/glib/gmacros.h" 1
# 40 "/usr/include/glib-2.0/glib/gmacros.h"
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 147 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 212 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 324 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 3 4
typedef int wchar_t;
# 41 "/usr/include/glib-2.0/glib/gmacros.h" 2
# 10 "/usr/lib64/glib-2.0/include/glibconfig.h" 2

# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/limits.h" 1 3 4
# 34 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/limits.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/syslimits.h" 1 3 4






# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/limits.h" 1 3 4
# 168 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/limits.h" 3 4
# 1 "/usr/include/limits.h" 1 3 4
# 26 "/usr/include/limits.h" 3 4
# 1 "/usr/include/features.h" 1 3 4
# 375 "/usr/include/features.h" 3 4
# 1 "/usr/include/sys/cdefs.h" 1 3 4
# 385 "/usr/include/sys/cdefs.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 386 "/usr/include/sys/cdefs.h" 2 3 4
# 376 "/usr/include/features.h" 2 3 4
# 399 "/usr/include/features.h" 3 4
# 1 "/usr/include/gnu/stubs.h" 1 3 4
# 10 "/usr/include/gnu/stubs.h" 3 4
# 1 "/usr/include/gnu/stubs-64.h" 1 3 4
# 11 "/usr/include/gnu/stubs.h" 2 3 4
# 400 "/usr/include/features.h" 2 3 4
# 27 "/usr/include/limits.h" 2 3 4
# 144 "/usr/include/limits.h" 3 4
# 1 "/usr/include/bits/posix1_lim.h" 1 3 4
# 160 "/usr/include/bits/posix1_lim.h" 3 4
# 1 "/usr/include/bits/local_lim.h" 1 3 4
# 38 "/usr/include/bits/local_lim.h" 3 4
# 1 "/usr/include/linux/limits.h" 1 3 4
# 39 "/usr/include/bits/local_lim.h" 2 3 4
# 161 "/usr/include/bits/posix1_lim.h" 2 3 4
# 145 "/usr/include/limits.h" 2 3 4



# 1 "/usr/include/bits/posix2_lim.h" 1 3 4
# 149 "/usr/include/limits.h" 2 3 4
# 169 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/limits.h" 2 3 4
# 8 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/syslimits.h" 2 3 4
# 35 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/limits.h" 2 3 4
# 12 "/usr/lib64/glib-2.0/include/glibconfig.h" 2
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/float.h" 1 3 4
# 13 "/usr/lib64/glib-2.0/include/glibconfig.h" 2
# 22 "/usr/lib64/glib-2.0/include/glibconfig.h"

# 38 "/usr/lib64/glib-2.0/include/glibconfig.h"
typedef signed char gint8;
typedef unsigned char guint8;
typedef signed short gint16;
typedef unsigned short guint16;



typedef signed int gint32;
typedef unsigned int guint32;





typedef signed long gint64;
typedef unsigned long guint64;
# 65 "/usr/lib64/glib-2.0/include/glibconfig.h"
typedef signed long gssize;
typedef unsigned long gsize;
# 75 "/usr/lib64/glib-2.0/include/glibconfig.h"
typedef gint64 goffset;
# 90 "/usr/lib64/glib-2.0/include/glibconfig.h"
typedef signed long gintptr;
typedef unsigned long guintptr;
# 198 "/usr/lib64/glib-2.0/include/glibconfig.h"
typedef int GPid;
# 208 "/usr/lib64/glib-2.0/include/glibconfig.h"

# 35 "/usr/include/glib-2.0/glib/gtypes.h" 2

# 1 "/usr/include/glib-2.0/glib/gversionmacros.h" 1
# 37 "/usr/include/glib-2.0/glib/gtypes.h" 2
# 1 "/usr/include/time.h" 1 3 4
# 29 "/usr/include/time.h" 3 4








# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 38 "/usr/include/time.h" 2 3 4



# 1 "/usr/include/bits/time.h" 1 3 4
# 42 "/usr/include/time.h" 2 3 4
# 55 "/usr/include/time.h" 3 4
# 1 "/usr/include/bits/types.h" 1 3 4
# 27 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/bits/types.h" 2 3 4


typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;


typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;







typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
# 130 "/usr/include/bits/types.h" 3 4
# 1 "/usr/include/bits/typesizes.h" 1 3 4
# 131 "/usr/include/bits/types.h" 2 3 4


typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;


typedef int __clockid_t;


typedef void * __timer_t;


typedef long int __blksize_t;




typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;


typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;


typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;


typedef long int __fsword_t;

typedef long int __ssize_t;


typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;



typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;


typedef long int __intptr_t;


typedef unsigned int __socklen_t;
# 56 "/usr/include/time.h" 2 3 4



typedef __clock_t clock_t;



# 73 "/usr/include/time.h" 3 4


typedef __time_t time_t;



# 91 "/usr/include/time.h" 3 4
typedef __clockid_t clockid_t;
# 103 "/usr/include/time.h" 3 4
typedef __timer_t timer_t;
# 120 "/usr/include/time.h" 3 4
struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };








struct tm
{
  int tm_sec;
  int tm_min;
  int tm_hour;
  int tm_mday;
  int tm_mon;
  int tm_year;
  int tm_wday;
  int tm_yday;
  int tm_isdst;


  long int tm_gmtoff;
  const char *tm_zone;




};








struct itimerspec
  {
    struct timespec it_interval;
    struct timespec it_value;
  };


struct sigevent;





typedef __pid_t pid_t;
# 186 "/usr/include/time.h" 3 4



extern clock_t clock (void) __attribute__ ((__nothrow__ , __leaf__));


extern time_t time (time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));


extern double difftime (time_t __time1, time_t __time0)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern time_t mktime (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));





extern size_t strftime (char *__restrict __s, size_t __maxsize,
   const char *__restrict __format,
   const struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));

# 221 "/usr/include/time.h" 3 4
# 1 "/usr/include/xlocale.h" 1 3 4
# 27 "/usr/include/xlocale.h" 3 4
typedef struct __locale_struct
{

  struct __locale_data *__locales[13];


  const unsigned short int *__ctype_b;
  const int *__ctype_tolower;
  const int *__ctype_toupper;


  const char *__names[13];
} *__locale_t;


typedef __locale_t locale_t;
# 222 "/usr/include/time.h" 2 3 4

extern size_t strftime_l (char *__restrict __s, size_t __maxsize,
     const char *__restrict __format,
     const struct tm *__restrict __tp,
     __locale_t __loc) __attribute__ ((__nothrow__ , __leaf__));
# 236 "/usr/include/time.h" 3 4



extern struct tm *gmtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));





extern struct tm *gmtime_r (const time_t *__restrict __timer,
       struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));



extern struct tm *localtime_r (const time_t *__restrict __timer,
          struct tm *__restrict __tp) __attribute__ ((__nothrow__ , __leaf__));





extern char *asctime (const struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime (const time_t *__timer) __attribute__ ((__nothrow__ , __leaf__));







extern char *asctime_r (const struct tm *__restrict __tp,
   char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));


extern char *ctime_r (const time_t *__restrict __timer,
        char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern char *__tzname[2];
extern int __daylight;
extern long int __timezone;




extern char *tzname[2];



extern void tzset (void) __attribute__ ((__nothrow__ , __leaf__));



extern int daylight;
extern long int timezone;





extern int stime (const time_t *__when) __attribute__ ((__nothrow__ , __leaf__));
# 319 "/usr/include/time.h" 3 4
extern time_t timegm (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern time_t timelocal (struct tm *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int dysize (int __year) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 334 "/usr/include/time.h" 3 4
extern int nanosleep (const struct timespec *__requested_time,
        struct timespec *__remaining);



extern int clock_getres (clockid_t __clock_id, struct timespec *__res) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_gettime (clockid_t __clock_id, struct timespec *__tp) __attribute__ ((__nothrow__ , __leaf__));


extern int clock_settime (clockid_t __clock_id, const struct timespec *__tp)
     __attribute__ ((__nothrow__ , __leaf__));






extern int clock_nanosleep (clockid_t __clock_id, int __flags,
       const struct timespec *__req,
       struct timespec *__rem);


extern int clock_getcpuclockid (pid_t __pid, clockid_t *__clock_id) __attribute__ ((__nothrow__ , __leaf__));




extern int timer_create (clockid_t __clock_id,
    struct sigevent *__restrict __evp,
    timer_t *__restrict __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_delete (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_settime (timer_t __timerid, int __flags,
     const struct itimerspec *__restrict __value,
     struct itimerspec *__restrict __ovalue) __attribute__ ((__nothrow__ , __leaf__));


extern int timer_gettime (timer_t __timerid, struct itimerspec *__value)
     __attribute__ ((__nothrow__ , __leaf__));


extern int timer_getoverrun (timer_t __timerid) __attribute__ ((__nothrow__ , __leaf__));
# 430 "/usr/include/time.h" 3 4

# 38 "/usr/include/glib-2.0/glib/gtypes.h" 2


# 48 "/usr/include/glib-2.0/glib/gtypes.h"
typedef char gchar;
typedef short gshort;
typedef long glong;
typedef int gint;
typedef gint gboolean;

typedef unsigned char guchar;
typedef unsigned short gushort;
typedef unsigned long gulong;
typedef unsigned int guint;

typedef float gfloat;
typedef double gdouble;
# 79 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void* gpointer;
typedef const void *gconstpointer;

typedef gint (*GCompareFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef gint (*GCompareDataFunc) (gconstpointer a,
                                                 gconstpointer b,
       gpointer user_data);
typedef gboolean (*GEqualFunc) (gconstpointer a,
                                                 gconstpointer b);
typedef void (*GDestroyNotify) (gpointer data);
typedef void (*GFunc) (gpointer data,
                                                 gpointer user_data);
typedef guint (*GHashFunc) (gconstpointer key);
typedef void (*GHFunc) (gpointer key,
                                                 gpointer value,
                                                 gpointer user_data);
# 105 "/usr/include/glib-2.0/glib/gtypes.h"
typedef void (*GFreeFunc) (gpointer data);
# 119 "/usr/include/glib-2.0/glib/gtypes.h"
typedef const gchar * (*GTranslateFunc) (const gchar *str,
       gpointer data);
# 401 "/usr/include/glib-2.0/glib/gtypes.h"
typedef union _GDoubleIEEE754 GDoubleIEEE754;
typedef union _GFloatIEEE754 GFloatIEEE754;





union _GFloatIEEE754
{
  gfloat v_float;
  struct {
    guint mantissa : 23;
    guint biased_exponent : 8;
    guint sign : 1;
  } mpn;
};
union _GDoubleIEEE754
{
  gdouble v_double;
  struct {
    guint mantissa_low : 32;
    guint mantissa_high : 20;
    guint biased_exponent : 11;
    guint sign : 1;
  } mpn;
};
# 451 "/usr/include/glib-2.0/glib/gtypes.h"
typedef struct _GTimeVal GTimeVal;

struct _GTimeVal
{
  glong tv_sec;
  glong tv_usec;
};


# 35 "/usr/include/glib-2.0/glib/galloca.h" 2
# 33 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/garray.h" 1
# 36 "/usr/include/glib-2.0/glib/garray.h"


typedef struct _GBytes GBytes;
typedef struct _GArray GArray;
typedef struct _GByteArray GByteArray;
typedef struct _GPtrArray GPtrArray;

struct _GArray
{
  gchar *data;
  guint len;
};

struct _GByteArray
{
  guint8 *data;
  guint len;
};

struct _GPtrArray
{
  gpointer *pdata;
  guint len;
};
# 71 "/usr/include/glib-2.0/glib/garray.h"
extern
GArray* g_array_new (gboolean zero_terminated,
       gboolean clear_,
       guint element_size);
extern
GArray* g_array_sized_new (gboolean zero_terminated,
       gboolean clear_,
       guint element_size,
       guint reserved_size);
extern
gchar* g_array_free (GArray *array,
       gboolean free_segment);
extern
GArray *g_array_ref (GArray *array);
extern
void g_array_unref (GArray *array);
extern
guint g_array_get_element_size (GArray *array);
extern
GArray* g_array_append_vals (GArray *array,
       gconstpointer data,
       guint len);
extern
GArray* g_array_prepend_vals (GArray *array,
       gconstpointer data,
       guint len);
extern
GArray* g_array_insert_vals (GArray *array,
       guint index_,
       gconstpointer data,
       guint len);
extern
GArray* g_array_set_size (GArray *array,
       guint length);
extern
GArray* g_array_remove_index (GArray *array,
       guint index_);
extern
GArray* g_array_remove_index_fast (GArray *array,
       guint index_);
extern
GArray* g_array_remove_range (GArray *array,
       guint index_,
       guint length);
extern
void g_array_sort (GArray *array,
       GCompareFunc compare_func);
extern
void g_array_sort_with_data (GArray *array,
       GCompareDataFunc compare_func,
       gpointer user_data);
extern
void g_array_set_clear_func (GArray *array,
                                   GDestroyNotify clear_func);






extern
GPtrArray* g_ptr_array_new (void);
extern
GPtrArray* g_ptr_array_new_with_free_func (GDestroyNotify element_free_func);
extern
GPtrArray* g_ptr_array_sized_new (guint reserved_size);
extern
GPtrArray* g_ptr_array_new_full (guint reserved_size,
        GDestroyNotify element_free_func);
extern
gpointer* g_ptr_array_free (GPtrArray *array,
        gboolean free_seg);
extern
GPtrArray* g_ptr_array_ref (GPtrArray *array);
extern
void g_ptr_array_unref (GPtrArray *array);
extern
void g_ptr_array_set_free_func (GPtrArray *array,
                                           GDestroyNotify element_free_func);
extern
void g_ptr_array_set_size (GPtrArray *array,
        gint length);
extern
gpointer g_ptr_array_remove_index (GPtrArray *array,
        guint index_);
extern
gpointer g_ptr_array_remove_index_fast (GPtrArray *array,
        guint index_);
extern
gboolean g_ptr_array_remove (GPtrArray *array,
        gpointer data);
extern
gboolean g_ptr_array_remove_fast (GPtrArray *array,
        gpointer data);
extern
void g_ptr_array_remove_range (GPtrArray *array,
        guint index_,
        guint length);
extern
void g_ptr_array_add (GPtrArray *array,
        gpointer data);
extern
void g_ptr_array_sort (GPtrArray *array,
        GCompareFunc compare_func);
extern
void g_ptr_array_sort_with_data (GPtrArray *array,
        GCompareDataFunc compare_func,
        gpointer user_data);
extern
void g_ptr_array_foreach (GPtrArray *array,
        GFunc func,
        gpointer user_data);






extern
GByteArray* g_byte_array_new (void);
extern
GByteArray* g_byte_array_new_take (guint8 *data,
                                            gsize len);
extern
GByteArray* g_byte_array_sized_new (guint reserved_size);
extern
guint8* g_byte_array_free (GByteArray *array,
         gboolean free_segment);
extern
GBytes* g_byte_array_free_to_bytes (GByteArray *array);
extern
GByteArray *g_byte_array_ref (GByteArray *array);
extern
void g_byte_array_unref (GByteArray *array);
extern
GByteArray* g_byte_array_append (GByteArray *array,
         const guint8 *data,
         guint len);
extern
GByteArray* g_byte_array_prepend (GByteArray *array,
         const guint8 *data,
         guint len);
extern
GByteArray* g_byte_array_set_size (GByteArray *array,
         guint length);
extern
GByteArray* g_byte_array_remove_index (GByteArray *array,
         guint index_);
extern
GByteArray* g_byte_array_remove_index_fast (GByteArray *array,
         guint index_);
extern
GByteArray* g_byte_array_remove_range (GByteArray *array,
         guint index_,
         guint length);
extern
void g_byte_array_sort (GByteArray *array,
         GCompareFunc compare_func);
extern
void g_byte_array_sort_with_data (GByteArray *array,
         GCompareDataFunc compare_func,
         gpointer user_data);


# 34 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gasyncqueue.h" 1
# 34 "/usr/include/glib-2.0/glib/gasyncqueue.h"
# 1 "/usr/include/glib-2.0/glib/gthread.h" 1
# 34 "/usr/include/glib-2.0/glib/gthread.h"
# 1 "/usr/include/glib-2.0/glib/gatomic.h" 1
# 31 "/usr/include/glib-2.0/glib/gatomic.h"


extern
gint g_atomic_int_get (const volatile gint *atomic);
extern
void g_atomic_int_set (volatile gint *atomic,
                                                               gint newval);
extern
void g_atomic_int_inc (volatile gint *atomic);
extern
gboolean g_atomic_int_dec_and_test (volatile gint *atomic);
extern
gboolean g_atomic_int_compare_and_exchange (volatile gint *atomic,
                                                               gint oldval,
                                                               gint newval);
extern
gint g_atomic_int_add (volatile gint *atomic,
                                                               gint val);
extern
guint g_atomic_int_and (volatile guint *atomic,
                                                               guint val);
extern
guint g_atomic_int_or (volatile guint *atomic,
                                                               guint val);
extern
guint g_atomic_int_xor (volatile guint *atomic,
                                                               guint val);

extern
gpointer g_atomic_pointer_get (const volatile void *atomic);
extern
void g_atomic_pointer_set (volatile void *atomic,
                                                               gpointer newval);
extern
gboolean g_atomic_pointer_compare_and_exchange (volatile void *atomic,
                                                               gpointer oldval,
                                                               gpointer newval);
extern
gssize g_atomic_pointer_add (volatile void *atomic,
                                                               gssize val);
extern
gsize g_atomic_pointer_and (volatile void *atomic,
                                                               gsize val);
extern
gsize g_atomic_pointer_or (volatile void *atomic,
                                                               gsize val);
extern
gsize g_atomic_pointer_xor (volatile void *atomic,
                                                               gsize val);

__attribute__((__deprecated__("Use '" "g_atomic_add" "' instead"))) extern
gint g_atomic_int_exchange_and_add (volatile gint *atomic,
                                                               gint val);


# 35 "/usr/include/glib-2.0/glib/gthread.h" 2
# 1 "/usr/include/glib-2.0/glib/gerror.h" 1
# 28 "/usr/include/glib-2.0/glib/gerror.h"
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stdarg.h" 1 3 4
# 40 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 98 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 29 "/usr/include/glib-2.0/glib/gerror.h" 2

# 1 "/usr/include/glib-2.0/glib/gquark.h" 1
# 36 "/usr/include/glib-2.0/glib/gquark.h"


typedef guint32 GQuark;



extern
GQuark g_quark_try_string (const gchar *string);
extern
GQuark g_quark_from_static_string (const gchar *string);
extern
GQuark g_quark_from_string (const gchar *string);
extern
const gchar * g_quark_to_string (GQuark quark) __attribute__((__const__));
# 63 "/usr/include/glib-2.0/glib/gquark.h"
extern
const gchar * g_intern_string (const gchar *string);
extern
const gchar * g_intern_static_string (const gchar *string);


# 31 "/usr/include/glib-2.0/glib/gerror.h" 2


# 43 "/usr/include/glib-2.0/glib/gerror.h"
typedef struct _GError GError;

struct _GError
{
  GQuark domain;
  gint code;
  gchar *message;
};

extern
GError* g_error_new (GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) __attribute__((__format__ (__printf__, 3, 4)));

extern
GError* g_error_new_literal (GQuark domain,
                                gint code,
                                const gchar *message);
extern
GError* g_error_new_valist (GQuark domain,
                                gint code,
                                const gchar *format,
                                va_list args) __attribute__((__format__ (__printf__, 3, 0)));

extern
void g_error_free (GError *error);
extern
GError* g_error_copy (const GError *error);

extern
gboolean g_error_matches (const GError *error,
                                GQuark domain,
                                gint code);




extern
void g_set_error (GError **err,
                                GQuark domain,
                                gint code,
                                const gchar *format,
                                ...) __attribute__((__format__ (__printf__, 4, 5)));

extern
void g_set_error_literal (GError **err,
                                GQuark domain,
                                gint code,
                                const gchar *message);



extern
void g_propagate_error (GError **dest,
    GError *src);


extern
void g_clear_error (GError **err);


extern
void g_prefix_error (GError **err,
                                       const gchar *format,
                                       ...) __attribute__((__format__ (__printf__, 2, 3)));


extern
void g_propagate_prefixed_error (GError **dest,
                                       GError *src,
                                       const gchar *format,
                                       ...) __attribute__((__format__ (__printf__, 3, 4)));


# 36 "/usr/include/glib-2.0/glib/gthread.h" 2




extern
GQuark g_thread_error_quark (void);

typedef enum
{
  G_THREAD_ERROR_AGAIN
} GThreadError;

typedef gpointer (*GThreadFunc) (gpointer data);

typedef struct _GThread GThread;

typedef union _GMutex GMutex;
typedef struct _GRecMutex GRecMutex;
typedef struct _GRWLock GRWLock;
typedef struct _GCond GCond;
typedef struct _GPrivate GPrivate;
typedef struct _GOnce GOnce;

union _GMutex
{

  gpointer p;
  guint i[2];
};

struct _GRWLock
{

  gpointer p;
  guint i[2];
};

struct _GCond
{

  gpointer p;
  guint i[2];
};

struct _GRecMutex
{

  gpointer p;
  guint i[2];
};


struct _GPrivate
{

  gpointer p;
  GDestroyNotify notify;
  gpointer future[2];
};

typedef enum
{
  G_ONCE_STATUS_NOTCALLED,
  G_ONCE_STATUS_PROGRESS,
  G_ONCE_STATUS_READY
} GOnceStatus;


struct _GOnce
{
  volatile GOnceStatus status;
  volatile gpointer retval;
};
# 141 "/usr/include/glib-2.0/glib/gthread.h"
extern
GThread * g_thread_ref (GThread *thread);
extern
void g_thread_unref (GThread *thread);
extern
GThread * g_thread_new (const gchar *name,
                                                 GThreadFunc func,
                                                 gpointer data);
extern
GThread * g_thread_try_new (const gchar *name,
                                                 GThreadFunc func,
                                                 gpointer data,
                                                 GError **error);
extern
GThread * g_thread_self (void);
extern
void g_thread_exit (gpointer retval);
extern
gpointer g_thread_join (GThread *thread);
extern
void g_thread_yield (void);


extern
void g_mutex_init (GMutex *mutex);
extern
void g_mutex_clear (GMutex *mutex);
extern
void g_mutex_lock (GMutex *mutex);
extern
gboolean g_mutex_trylock (GMutex *mutex);
extern
void g_mutex_unlock (GMutex *mutex);

extern
void g_rw_lock_init (GRWLock *rw_lock);
extern
void g_rw_lock_clear (GRWLock *rw_lock);
extern
void g_rw_lock_writer_lock (GRWLock *rw_lock);
extern
gboolean g_rw_lock_writer_trylock (GRWLock *rw_lock);
extern
void g_rw_lock_writer_unlock (GRWLock *rw_lock);
extern
void g_rw_lock_reader_lock (GRWLock *rw_lock);
extern
gboolean g_rw_lock_reader_trylock (GRWLock *rw_lock);
extern
void g_rw_lock_reader_unlock (GRWLock *rw_lock);

extern
void g_rec_mutex_init (GRecMutex *rec_mutex);
extern
void g_rec_mutex_clear (GRecMutex *rec_mutex);
extern
void g_rec_mutex_lock (GRecMutex *rec_mutex);
extern
gboolean g_rec_mutex_trylock (GRecMutex *rec_mutex);
extern
void g_rec_mutex_unlock (GRecMutex *rec_mutex);

extern
void g_cond_init (GCond *cond);
extern
void g_cond_clear (GCond *cond);
extern
void g_cond_wait (GCond *cond,
                                                 GMutex *mutex);
extern
void g_cond_signal (GCond *cond);
extern
void g_cond_broadcast (GCond *cond);
extern
gboolean g_cond_wait_until (GCond *cond,
                                                 GMutex *mutex,
                                                 gint64 end_time);

extern
gpointer g_private_get (GPrivate *key);
extern
void g_private_set (GPrivate *key,
                                                 gpointer value);
extern
void g_private_replace (GPrivate *key,
                                                 gpointer value);

extern
gpointer g_once_impl (GOnce *once,
                                                 GThreadFunc func,
                                                 gpointer arg);
extern
gboolean g_once_init_enter (volatile void *location);
extern
void g_once_init_leave (volatile void *location,
                                                 gsize result);
# 268 "/usr/include/glib-2.0/glib/gthread.h"
extern
guint g_get_num_processors (void);


# 35 "/usr/include/glib-2.0/glib/gasyncqueue.h" 2



typedef struct _GAsyncQueue GAsyncQueue;

extern
GAsyncQueue *g_async_queue_new (void);
extern
GAsyncQueue *g_async_queue_new_full (GDestroyNotify item_free_func);
extern
void g_async_queue_lock (GAsyncQueue *queue);
extern
void g_async_queue_unlock (GAsyncQueue *queue);
extern
GAsyncQueue *g_async_queue_ref (GAsyncQueue *queue);
extern
void g_async_queue_unref (GAsyncQueue *queue);

__attribute__((__deprecated__("Use '" "g_async_queue_ref" "' instead"))) extern
void g_async_queue_ref_unlocked (GAsyncQueue *queue);

__attribute__((__deprecated__("Use '" "g_async_queue_unref" "' instead"))) extern
void g_async_queue_unref_and_unlock (GAsyncQueue *queue);

extern
void g_async_queue_push (GAsyncQueue *queue,
                                                 gpointer data);
extern
void g_async_queue_push_unlocked (GAsyncQueue *queue,
                                                 gpointer data);
extern
void g_async_queue_push_sorted (GAsyncQueue *queue,
                                                 gpointer data,
                                                 GCompareDataFunc func,
                                                 gpointer user_data);
extern
void g_async_queue_push_sorted_unlocked (GAsyncQueue *queue,
                                                 gpointer data,
                                                 GCompareDataFunc func,
                                                 gpointer user_data);
extern
gpointer g_async_queue_pop (GAsyncQueue *queue);
extern
gpointer g_async_queue_pop_unlocked (GAsyncQueue *queue);
extern
gpointer g_async_queue_try_pop (GAsyncQueue *queue);
extern
gpointer g_async_queue_try_pop_unlocked (GAsyncQueue *queue);
extern
gpointer g_async_queue_timeout_pop (GAsyncQueue *queue,
                                                 guint64 timeout);
extern
gpointer g_async_queue_timeout_pop_unlocked (GAsyncQueue *queue,
                                                 guint64 timeout);
extern
gint g_async_queue_length (GAsyncQueue *queue);
extern
gint g_async_queue_length_unlocked (GAsyncQueue *queue);
extern
void g_async_queue_sort (GAsyncQueue *queue,
                                                 GCompareDataFunc func,
                                                 gpointer user_data);
extern
void g_async_queue_sort_unlocked (GAsyncQueue *queue,
                                                 GCompareDataFunc func,
                                                 gpointer user_data);

__attribute__((__deprecated__("Use '" "g_async_queue_timeout_pop" "' instead"))) extern
gpointer g_async_queue_timed_pop (GAsyncQueue *queue,
                                                 GTimeVal *end_time);
__attribute__((__deprecated__("Use '" "g_async_queue_timeout_pop_unlocked" "' instead"))) extern
gpointer g_async_queue_timed_pop_unlocked (GAsyncQueue *queue,
                                                 GTimeVal *end_time);


# 35 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gbacktrace.h" 1
# 35 "/usr/include/glib-2.0/glib/gbacktrace.h"
# 1 "/usr/include/signal.h" 1 3 4
# 30 "/usr/include/signal.h" 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 23 "/usr/include/bits/sigset.h" 3 4
typedef int __sig_atomic_t;




typedef struct
  {
    unsigned long int __val[(1024 / (8 * sizeof (unsigned long int)))];
  } __sigset_t;
# 103 "/usr/include/bits/sigset.h" 3 4
extern int __sigismember (const __sigset_t *, int);
extern int __sigaddset (__sigset_t *, int);
extern int __sigdelset (__sigset_t *, int);
# 117 "/usr/include/bits/sigset.h" 3 4
extern __inline int __sigismember (const __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return (__set->__val[__word] & __mask) ? 1 : 0; }
extern __inline int __sigaddset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] |= __mask), 0); }
extern __inline int __sigdelset ( __sigset_t *__set, int __sig) { unsigned long int __mask = (((unsigned long int) 1) << (((__sig) - 1) % (8 * sizeof (unsigned long int)))); unsigned long int __word = (((__sig) - 1) / (8 * sizeof (unsigned long int))); return ((__set->__val[__word] &= ~__mask), 0); }
# 33 "/usr/include/signal.h" 2 3 4







typedef __sig_atomic_t sig_atomic_t;








typedef __sigset_t sigset_t;







# 1 "/usr/include/bits/signum.h" 1 3 4
# 58 "/usr/include/signal.h" 2 3 4
# 67 "/usr/include/signal.h" 3 4
typedef __uid_t uid_t;
# 80 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/siginfo.h" 1 3 4
# 24 "/usr/include/bits/siginfo.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 25 "/usr/include/bits/siginfo.h" 2 3 4







typedef union sigval
  {
    int sival_int;
    void *sival_ptr;
  } sigval_t;
# 58 "/usr/include/bits/siginfo.h" 3 4
typedef __clock_t __sigchld_clock_t;



typedef struct
  {
    int si_signo;
    int si_errno;

    int si_code;

    union
      {
 int _pad[((128 / sizeof (int)) - 4)];


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
   } _kill;


 struct
   {
     int si_tid;
     int si_overrun;
     sigval_t si_sigval;
   } _timer;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     sigval_t si_sigval;
   } _rt;


 struct
   {
     __pid_t si_pid;
     __uid_t si_uid;
     int si_status;
     __sigchld_clock_t si_utime;
     __sigchld_clock_t si_stime;
   } _sigchld;


 struct
   {
     void *si_addr;
   } _sigfault;


 struct
   {
     long int si_band;
     int si_fd;
   } _sigpoll;


 struct
   {
     void *_call_addr;
     int _syscall;
     unsigned int _arch;
   } _sigsys;
      } _sifields;
  } siginfo_t ;
# 151 "/usr/include/bits/siginfo.h" 3 4
enum
{
  SI_ASYNCNL = -60,

  SI_TKILL = -6,

  SI_SIGIO,

  SI_ASYNCIO,

  SI_MESGQ,

  SI_TIMER,

  SI_QUEUE,

  SI_USER,

  SI_KERNEL = 0x80

};



enum
{
  ILL_ILLOPC = 1,

  ILL_ILLOPN,

  ILL_ILLADR,

  ILL_ILLTRP,

  ILL_PRVOPC,

  ILL_PRVREG,

  ILL_COPROC,

  ILL_BADSTK

};


enum
{
  FPE_INTDIV = 1,

  FPE_INTOVF,

  FPE_FLTDIV,

  FPE_FLTOVF,

  FPE_FLTUND,

  FPE_FLTRES,

  FPE_FLTINV,

  FPE_FLTSUB

};


enum
{
  SEGV_MAPERR = 1,

  SEGV_ACCERR

};


enum
{
  BUS_ADRALN = 1,

  BUS_ADRERR,

  BUS_OBJERR

};


enum
{
  TRAP_BRKPT = 1,

  TRAP_TRACE

};


enum
{
  CLD_EXITED = 1,

  CLD_KILLED,

  CLD_DUMPED,

  CLD_TRAPPED,

  CLD_STOPPED,

  CLD_CONTINUED

};


enum
{
  POLL_IN = 1,

  POLL_OUT,

  POLL_MSG,

  POLL_ERR,

  POLL_PRI,

  POLL_HUP

};
# 297 "/usr/include/bits/siginfo.h" 3 4
typedef union pthread_attr_t pthread_attr_t;



typedef struct sigevent
  {
    sigval_t sigev_value;
    int sigev_signo;
    int sigev_notify;

    union
      {
 int _pad[((64 / sizeof (int)) - 4)];



 __pid_t _tid;

 struct
   {
     void (*_function) (sigval_t);
     pthread_attr_t *_attribute;
   } _sigev_thread;
      } _sigev_un;
  } sigevent_t;






enum
{
  SIGEV_SIGNAL = 0,

  SIGEV_NONE,

  SIGEV_THREAD,


  SIGEV_THREAD_ID = 4

};
# 81 "/usr/include/signal.h" 2 3 4




typedef void (*__sighandler_t) (int);




extern __sighandler_t __sysv_signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 100 "/usr/include/signal.h" 3 4


extern __sighandler_t signal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
# 114 "/usr/include/signal.h" 3 4

# 127 "/usr/include/signal.h" 3 4
extern int kill (__pid_t __pid, int __sig) __attribute__ ((__nothrow__ , __leaf__));






extern int killpg (__pid_t __pgrp, int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern int raise (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern __sighandler_t ssignal (int __sig, __sighandler_t __handler)
     __attribute__ ((__nothrow__ , __leaf__));
extern int gsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));




extern void psignal (int __sig, const char *__s);




extern void psiginfo (const siginfo_t *__pinfo, const char *__s);
# 169 "/usr/include/signal.h" 3 4
extern int __sigpause (int __sig_or_mask, int __is_sig);
# 197 "/usr/include/signal.h" 3 4
extern int sigblock (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int sigsetmask (int __mask) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));


extern int siggetmask (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));
# 217 "/usr/include/signal.h" 3 4
typedef __sighandler_t sig_t;





extern int sigemptyset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigfillset (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigaddset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigdelset (sigset_t *__set, int __signo) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int sigismember (const sigset_t *__set, int __signo)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 253 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/sigaction.h" 1 3 4
# 24 "/usr/include/bits/sigaction.h" 3 4
struct sigaction
  {


    union
      {

 __sighandler_t sa_handler;

 void (*sa_sigaction) (int, siginfo_t *, void *);
      }
    __sigaction_handler;







    __sigset_t sa_mask;


    int sa_flags;


    void (*sa_restorer) (void);
  };
# 254 "/usr/include/signal.h" 2 3 4


extern int sigprocmask (int __how, const sigset_t *__restrict __set,
   sigset_t *__restrict __oset) __attribute__ ((__nothrow__ , __leaf__));






extern int sigsuspend (const sigset_t *__set) __attribute__ ((__nonnull__ (1)));


extern int sigaction (int __sig, const struct sigaction *__restrict __act,
        struct sigaction *__restrict __oact) __attribute__ ((__nothrow__ , __leaf__));


extern int sigpending (sigset_t *__set) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sigwait (const sigset_t *__restrict __set, int *__restrict __sig)
     __attribute__ ((__nonnull__ (1, 2)));






extern int sigwaitinfo (const sigset_t *__restrict __set,
   siginfo_t *__restrict __info) __attribute__ ((__nonnull__ (1)));






extern int sigtimedwait (const sigset_t *__restrict __set,
    siginfo_t *__restrict __info,
    const struct timespec *__restrict __timeout)
     __attribute__ ((__nonnull__ (1)));



extern int sigqueue (__pid_t __pid, int __sig, const union sigval __val)
     __attribute__ ((__nothrow__ , __leaf__));
# 311 "/usr/include/signal.h" 3 4
extern const char *const _sys_siglist[65];
extern const char *const sys_siglist[65];


struct sigvec
  {
    __sighandler_t sv_handler;
    int sv_mask;

    int sv_flags;

  };
# 335 "/usr/include/signal.h" 3 4
extern int sigvec (int __sig, const struct sigvec *__vec,
     struct sigvec *__ovec) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/bits/sigcontext.h" 1 3 4
# 29 "/usr/include/bits/sigcontext.h" 3 4
struct _fpx_sw_bytes
{
  __uint32_t magic1;
  __uint32_t extended_size;
  __uint64_t xstate_bv;
  __uint32_t xstate_size;
  __uint32_t padding[7];
};

struct _fpreg
{
  unsigned short significand[4];
  unsigned short exponent;
};

struct _fpxreg
{
  unsigned short significand[4];
  unsigned short exponent;
  unsigned short padding[3];
};

struct _xmmreg
{
  __uint32_t element[4];
};
# 121 "/usr/include/bits/sigcontext.h" 3 4
struct _fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _fpxreg _st[8];
  struct _xmmreg _xmm[16];
  __uint32_t padding[24];
};

struct sigcontext
{
  __uint64_t r8;
  __uint64_t r9;
  __uint64_t r10;
  __uint64_t r11;
  __uint64_t r12;
  __uint64_t r13;
  __uint64_t r14;
  __uint64_t r15;
  __uint64_t rdi;
  __uint64_t rsi;
  __uint64_t rbp;
  __uint64_t rbx;
  __uint64_t rdx;
  __uint64_t rax;
  __uint64_t rcx;
  __uint64_t rsp;
  __uint64_t rip;
  __uint64_t eflags;
  unsigned short cs;
  unsigned short gs;
  unsigned short fs;
  unsigned short __pad0;
  __uint64_t err;
  __uint64_t trapno;
  __uint64_t oldmask;
  __uint64_t cr2;
  __extension__ union
    {
      struct _fpstate * fpstate;
      __uint64_t __fpstate_word;
    };
  __uint64_t __reserved1 [8];
};



struct _xsave_hdr
{
  __uint64_t xstate_bv;
  __uint64_t reserved1[2];
  __uint64_t reserved2[5];
};

struct _ymmh_state
{
  __uint32_t ymmh_space[64];
};

struct _xstate
{
  struct _fpstate fpstate;
  struct _xsave_hdr xstate_hdr;
  struct _ymmh_state ymmh;
};
# 341 "/usr/include/signal.h" 2 3 4


extern int sigreturn (struct sigcontext *__scp) __attribute__ ((__nothrow__ , __leaf__));






# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 351 "/usr/include/signal.h" 2 3 4




extern int siginterrupt (int __sig, int __interrupt) __attribute__ ((__nothrow__ , __leaf__));

# 1 "/usr/include/bits/sigstack.h" 1 3 4
# 25 "/usr/include/bits/sigstack.h" 3 4
struct sigstack
  {
    void *ss_sp;
    int ss_onstack;
  };



enum
{
  SS_ONSTACK = 1,

  SS_DISABLE

};
# 49 "/usr/include/bits/sigstack.h" 3 4
typedef struct sigaltstack
  {
    void *ss_sp;
    int ss_flags;
    size_t ss_size;
  } stack_t;
# 358 "/usr/include/signal.h" 2 3 4


# 1 "/usr/include/sys/ucontext.h" 1 3 4
# 22 "/usr/include/sys/ucontext.h" 3 4
# 1 "/usr/include/signal.h" 1 3 4
# 23 "/usr/include/sys/ucontext.h" 2 3 4
# 31 "/usr/include/sys/ucontext.h" 3 4
__extension__ typedef long long int greg_t;





typedef greg_t gregset_t[23];
# 92 "/usr/include/sys/ucontext.h" 3 4
struct _libc_fpxreg
{
  unsigned short int significand[4];
  unsigned short int exponent;
  unsigned short int padding[3];
};

struct _libc_xmmreg
{
  __uint32_t element[4];
};

struct _libc_fpstate
{

  __uint16_t cwd;
  __uint16_t swd;
  __uint16_t ftw;
  __uint16_t fop;
  __uint64_t rip;
  __uint64_t rdp;
  __uint32_t mxcsr;
  __uint32_t mxcr_mask;
  struct _libc_fpxreg _st[8];
  struct _libc_xmmreg _xmm[16];
  __uint32_t padding[24];
};


typedef struct _libc_fpstate *fpregset_t;


typedef struct
  {
    gregset_t gregs;

    fpregset_t fpregs;
    __extension__ unsigned long long __reserved1 [8];
} mcontext_t;


typedef struct ucontext
  {
    unsigned long int uc_flags;
    struct ucontext *uc_link;
    stack_t uc_stack;
    mcontext_t uc_mcontext;
    __sigset_t uc_sigmask;
    struct _libc_fpstate __fpregs_mem;
  } ucontext_t;
# 361 "/usr/include/signal.h" 2 3 4





extern int sigstack (struct sigstack *__ss, struct sigstack *__oss)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__deprecated__));



extern int sigaltstack (const struct sigaltstack *__restrict __ss,
   struct sigaltstack *__restrict __oss) __attribute__ ((__nothrow__ , __leaf__));
# 395 "/usr/include/signal.h" 3 4
# 1 "/usr/include/bits/pthreadtypes.h" 1 3 4
# 21 "/usr/include/bits/pthreadtypes.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 22 "/usr/include/bits/pthreadtypes.h" 2 3 4
# 60 "/usr/include/bits/pthreadtypes.h" 3 4
typedef unsigned long int pthread_t;


union pthread_attr_t
{
  char __size[56];
  long int __align;
};







typedef struct __pthread_internal_list
{
  struct __pthread_internal_list *__prev;
  struct __pthread_internal_list *__next;
} __pthread_list_t;
# 90 "/usr/include/bits/pthreadtypes.h" 3 4
typedef union
{
  struct __pthread_mutex_s
  {
    int __lock;
    unsigned int __count;
    int __owner;

    unsigned int __nusers;



    int __kind;

    int __spins;
    __pthread_list_t __list;
# 115 "/usr/include/bits/pthreadtypes.h" 3 4
  } __data;
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_mutexattr_t;




typedef union
{
  struct
  {
    int __lock;
    unsigned int __futex;
    __extension__ unsigned long long int __total_seq;
    __extension__ unsigned long long int __wakeup_seq;
    __extension__ unsigned long long int __woken_seq;
    void *__mutex;
    unsigned int __nwaiters;
    unsigned int __broadcast_seq;
  } __data;
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_condattr_t;



typedef unsigned int pthread_key_t;



typedef int pthread_once_t;





typedef union
{

  struct
  {
    int __lock;
    unsigned int __nr_readers;
    unsigned int __readers_wakeup;
    unsigned int __writer_wakeup;
    unsigned int __nr_readers_queued;
    unsigned int __nr_writers_queued;
    int __writer;
    int __shared;
    unsigned long int __pad1;
    unsigned long int __pad2;


    unsigned int __flags;

  } __data;
# 202 "/usr/include/bits/pthreadtypes.h" 3 4
  char __size[56];
  long int __align;
} pthread_rwlock_t;

typedef union
{
  char __size[8];
  long int __align;
} pthread_rwlockattr_t;





typedef volatile int pthread_spinlock_t;




typedef union
{
  char __size[32];
  long int __align;
} pthread_barrier_t;

typedef union
{
  char __size[4];
  int __align;
} pthread_barrierattr_t;
# 396 "/usr/include/signal.h" 2 3 4
# 1 "/usr/include/bits/sigthread.h" 1 3 4
# 30 "/usr/include/bits/sigthread.h" 3 4
extern int pthread_sigmask (int __how,
       const __sigset_t *__restrict __newmask,
       __sigset_t *__restrict __oldmask)__attribute__ ((__nothrow__ , __leaf__));


extern int pthread_kill (pthread_t __threadid, int __signo) __attribute__ ((__nothrow__ , __leaf__));
# 397 "/usr/include/signal.h" 2 3 4






extern int __libc_current_sigrtmin (void) __attribute__ ((__nothrow__ , __leaf__));

extern int __libc_current_sigrtmax (void) __attribute__ ((__nothrow__ , __leaf__));




# 36 "/usr/include/glib-2.0/glib/gbacktrace.h" 2



extern
void g_on_error_query (const gchar *prg_name);
extern
void g_on_error_stack_trace (const gchar *prg_name);
# 64 "/usr/include/glib-2.0/glib/gbacktrace.h"

# 37 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gbase64.h" 1
# 30 "/usr/include/glib-2.0/glib/gbase64.h"


extern
gsize g_base64_encode_step (const guchar *in,
                                 gsize len,
                                 gboolean break_lines,
                                 gchar *out,
                                 gint *state,
                                 gint *save);
extern
gsize g_base64_encode_close (gboolean break_lines,
                                 gchar *out,
                                 gint *state,
                                 gint *save);
extern
gchar* g_base64_encode (const guchar *data,
                                 gsize len) __attribute__((__malloc__));
extern
gsize g_base64_decode_step (const gchar *in,
                                 gsize len,
                                 guchar *out,
                                 gint *state,
                                 guint *save);
extern
guchar *g_base64_decode (const gchar *text,
                                 gsize *out_len) __attribute__((__malloc__));
extern
guchar *g_base64_decode_inplace (gchar *text,
                                 gsize *out_len);



# 38 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gbitlock.h" 1
# 32 "/usr/include/glib-2.0/glib/gbitlock.h"


extern
void g_bit_lock (volatile gint *address,
                                           gint lock_bit);
extern
gboolean g_bit_trylock (volatile gint *address,
                                           gint lock_bit);
extern
void g_bit_unlock (volatile gint *address,
                                           gint lock_bit);

extern
void g_pointer_bit_lock (volatile void *address,
                                           gint lock_bit);
extern
gboolean g_pointer_bit_trylock (volatile void *address,
                                           gint lock_bit);
extern
void g_pointer_bit_unlock (volatile void *address,
                                           gint lock_bit);
# 76 "/usr/include/glib-2.0/glib/gbitlock.h"

# 39 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gbookmarkfile.h" 1
# 30 "/usr/include/glib-2.0/glib/gbookmarkfile.h"

# 57 "/usr/include/glib-2.0/glib/gbookmarkfile.h"
typedef enum
{
  G_BOOKMARK_FILE_ERROR_INVALID_URI,
  G_BOOKMARK_FILE_ERROR_INVALID_VALUE,
  G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED,
  G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND,
  G_BOOKMARK_FILE_ERROR_READ,
  G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING,
  G_BOOKMARK_FILE_ERROR_WRITE,
  G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND
} GBookmarkFileError;

extern
GQuark g_bookmark_file_error_quark (void);







typedef struct _GBookmarkFile GBookmarkFile;

extern
GBookmarkFile *g_bookmark_file_new (void);
extern
void g_bookmark_file_free (GBookmarkFile *bookmark);

extern
gboolean g_bookmark_file_load_from_file (GBookmarkFile *bookmark,
          const gchar *filename,
          GError **error);
extern
gboolean g_bookmark_file_load_from_data (GBookmarkFile *bookmark,
          const gchar *data,
          gsize length,
          GError **error);
extern
gboolean g_bookmark_file_load_from_data_dirs (GBookmarkFile *bookmark,
          const gchar *file,
          gchar **full_path,
          GError **error);
extern
gchar * g_bookmark_file_to_data (GBookmarkFile *bookmark,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
gboolean g_bookmark_file_to_file (GBookmarkFile *bookmark,
          const gchar *filename,
          GError **error);

extern
void g_bookmark_file_set_title (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *title);
extern
gchar * g_bookmark_file_get_title (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error) __attribute__((__malloc__));
extern
void g_bookmark_file_set_description (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *description);
extern
gchar * g_bookmark_file_get_description (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error) __attribute__((__malloc__));
extern
void g_bookmark_file_set_mime_type (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *mime_type);
extern
gchar * g_bookmark_file_get_mime_type (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error) __attribute__((__malloc__));
extern
void g_bookmark_file_set_groups (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar **groups,
          gsize length);
extern
void g_bookmark_file_add_group (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *group);
extern
gboolean g_bookmark_file_has_group (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *group,
          GError **error);
extern
gchar ** g_bookmark_file_get_groups (GBookmarkFile *bookmark,
          const gchar *uri,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
void g_bookmark_file_add_application (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          const gchar *exec);
extern
gboolean g_bookmark_file_has_application (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          GError **error);
extern
gchar ** g_bookmark_file_get_applications (GBookmarkFile *bookmark,
          const gchar *uri,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
gboolean g_bookmark_file_set_app_info (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          const gchar *exec,
          gint count,
          time_t stamp,
          GError **error);
extern
gboolean g_bookmark_file_get_app_info (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          gchar **exec,
          guint *count,
          time_t *stamp,
          GError **error);
extern
void g_bookmark_file_set_is_private (GBookmarkFile *bookmark,
          const gchar *uri,
          gboolean is_private);
extern
gboolean g_bookmark_file_get_is_private (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
extern
void g_bookmark_file_set_icon (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *href,
          const gchar *mime_type);
extern
gboolean g_bookmark_file_get_icon (GBookmarkFile *bookmark,
          const gchar *uri,
          gchar **href,
          gchar **mime_type,
          GError **error);
extern
void g_bookmark_file_set_added (GBookmarkFile *bookmark,
          const gchar *uri,
          time_t added);
extern
time_t g_bookmark_file_get_added (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
extern
void g_bookmark_file_set_modified (GBookmarkFile *bookmark,
          const gchar *uri,
          time_t modified);
extern
time_t g_bookmark_file_get_modified (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
extern
void g_bookmark_file_set_visited (GBookmarkFile *bookmark,
          const gchar *uri,
          time_t visited);
extern
time_t g_bookmark_file_get_visited (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
extern
gboolean g_bookmark_file_has_item (GBookmarkFile *bookmark,
          const gchar *uri);
extern
gint g_bookmark_file_get_size (GBookmarkFile *bookmark);
extern
gchar ** g_bookmark_file_get_uris (GBookmarkFile *bookmark,
          gsize *length) __attribute__((__malloc__));
extern
gboolean g_bookmark_file_remove_group (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *group,
          GError **error);
extern
gboolean g_bookmark_file_remove_application (GBookmarkFile *bookmark,
          const gchar *uri,
          const gchar *name,
          GError **error);
extern
gboolean g_bookmark_file_remove_item (GBookmarkFile *bookmark,
          const gchar *uri,
          GError **error);
extern
gboolean g_bookmark_file_move_item (GBookmarkFile *bookmark,
          const gchar *old_uri,
          const gchar *new_uri,
          GError **error);


# 40 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gbytes.h" 1
# 34 "/usr/include/glib-2.0/glib/gbytes.h"


extern
GBytes * g_bytes_new (gconstpointer data,
                                                 gsize size);

extern
GBytes * g_bytes_new_take (gpointer data,
                                                 gsize size);

extern
GBytes * g_bytes_new_static (gconstpointer data,
                                                 gsize size);

extern
GBytes * g_bytes_new_with_free_func (gconstpointer data,
                                                 gsize size,
                                                 GDestroyNotify free_func,
                                                 gpointer user_data);

extern
GBytes * g_bytes_new_from_bytes (GBytes *bytes,
                                                 gsize offset,
                                                 gsize length);

extern
gconstpointer g_bytes_get_data (GBytes *bytes,
                                                 gsize *size);

extern
gsize g_bytes_get_size (GBytes *bytes);

extern
GBytes * g_bytes_ref (GBytes *bytes);

extern
void g_bytes_unref (GBytes *bytes);

extern
gpointer g_bytes_unref_to_data (GBytes *bytes,
                                                 gsize *size);

extern
GByteArray * g_bytes_unref_to_array (GBytes *bytes);

extern
guint g_bytes_hash (gconstpointer bytes);

extern
gboolean g_bytes_equal (gconstpointer bytes1,
                                                 gconstpointer bytes2);

extern
gint g_bytes_compare (gconstpointer bytes1,
                                                 gconstpointer bytes2);


# 41 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gcharset.h" 1
# 30 "/usr/include/glib-2.0/glib/gcharset.h"


extern
gboolean g_get_charset (const char **charset);
extern
gchar * g_get_codeset (void);

extern
const gchar * const * g_get_language_names (void);
extern
gchar ** g_get_locale_variants (const gchar *locale);


# 42 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gchecksum.h" 1
# 31 "/usr/include/glib-2.0/glib/gchecksum.h"

# 48 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef enum {
  G_CHECKSUM_MD5,
  G_CHECKSUM_SHA1,
  G_CHECKSUM_SHA256,
  G_CHECKSUM_SHA512
} GChecksumType;
# 64 "/usr/include/glib-2.0/glib/gchecksum.h"
typedef struct _GChecksum GChecksum;

extern
gssize g_checksum_type_get_length (GChecksumType checksum_type);

extern
GChecksum * g_checksum_new (GChecksumType checksum_type);
extern
void g_checksum_reset (GChecksum *checksum);
extern
GChecksum * g_checksum_copy (const GChecksum *checksum);
extern
void g_checksum_free (GChecksum *checksum);
extern
void g_checksum_update (GChecksum *checksum,
                                                     const guchar *data,
                                                     gssize length);
extern
const gchar * g_checksum_get_string (GChecksum *checksum);
extern
void g_checksum_get_digest (GChecksum *checksum,
                                                     guint8 *buffer,
                                                     gsize *digest_len);

extern
gchar *g_compute_checksum_for_data (GChecksumType checksum_type,
                                                     const guchar *data,
                                                     gsize length);
extern
gchar *g_compute_checksum_for_string (GChecksumType checksum_type,
                                                     const gchar *str,
                                                     gssize length);

extern
gchar *g_compute_checksum_for_bytes (GChecksumType checksum_type,
                                                     GBytes *data);


# 43 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gconvert.h" 1
# 36 "/usr/include/glib-2.0/glib/gconvert.h"

# 50 "/usr/include/glib-2.0/glib/gconvert.h"
typedef enum
{
  G_CONVERT_ERROR_NO_CONVERSION,
  G_CONVERT_ERROR_ILLEGAL_SEQUENCE,
  G_CONVERT_ERROR_FAILED,
  G_CONVERT_ERROR_PARTIAL_INPUT,
  G_CONVERT_ERROR_BAD_URI,
  G_CONVERT_ERROR_NOT_ABSOLUTE_PATH
} GConvertError;
# 68 "/usr/include/glib-2.0/glib/gconvert.h"
extern
GQuark g_convert_error_quark (void);
# 78 "/usr/include/glib-2.0/glib/gconvert.h"
typedef struct _GIConv *GIConv;

extern
GIConv g_iconv_open (const gchar *to_codeset,
         const gchar *from_codeset);
extern
gsize g_iconv (GIConv converter,
         gchar **inbuf,
         gsize *inbytes_left,
         gchar **outbuf,
         gsize *outbytes_left);
extern
gint g_iconv_close (GIConv converter);


extern
gchar* g_convert (const gchar *str,
    gssize len,
    const gchar *to_codeset,
    const gchar *from_codeset,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));
extern
gchar* g_convert_with_iconv (const gchar *str,
    gssize len,
    GIConv converter,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));
extern
gchar* g_convert_with_fallback (const gchar *str,
    gssize len,
    const gchar *to_codeset,
    const gchar *from_codeset,
    const gchar *fallback,
    gsize *bytes_read,
    gsize *bytes_written,
    GError **error) __attribute__((__malloc__));




extern
gchar* g_locale_to_utf8 (const gchar *opsysstring,
      gssize len,
      gsize *bytes_read,
      gsize *bytes_written,
      GError **error) __attribute__((__malloc__));
extern
gchar* g_locale_from_utf8 (const gchar *utf8string,
      gssize len,
      gsize *bytes_read,
      gsize *bytes_written,
      GError **error) __attribute__((__malloc__));




extern
gchar* g_filename_to_utf8 (const gchar *opsysstring,
        gssize len,
        gsize *bytes_read,
        gsize *bytes_written,
        GError **error) __attribute__((__malloc__));
extern
gchar* g_filename_from_utf8 (const gchar *utf8string,
        gssize len,
        gsize *bytes_read,
        gsize *bytes_written,
        GError **error) __attribute__((__malloc__));

extern
gchar *g_filename_from_uri (const gchar *uri,
       gchar **hostname,
       GError **error) __attribute__((__malloc__));

extern
gchar *g_filename_to_uri (const gchar *filename,
       const gchar *hostname,
       GError **error) __attribute__((__malloc__));
extern
gchar *g_filename_display_name (const gchar *filename) __attribute__((__malloc__));
extern
gboolean g_get_filename_charsets (const gchar ***charsets);

extern
gchar *g_filename_display_basename (const gchar *filename) __attribute__((__malloc__));

extern
gchar **g_uri_list_extract_uris (const gchar *uri_list) __attribute__((__malloc__));
# 198 "/usr/include/glib-2.0/glib/gconvert.h"

# 44 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gdataset.h" 1
# 36 "/usr/include/glib-2.0/glib/gdataset.h"


typedef struct _GData GData;

typedef void (*GDataForeachFunc) (GQuark key_id,
                                                 gpointer data,
                                                 gpointer user_data);



extern
void g_datalist_init (GData **datalist);
extern
void g_datalist_clear (GData **datalist);
extern
gpointer g_datalist_id_get_data (GData **datalist,
      GQuark key_id);
extern
void g_datalist_id_set_data_full (GData **datalist,
      GQuark key_id,
      gpointer data,
      GDestroyNotify destroy_func);

typedef gpointer (*GDuplicateFunc) (gpointer data, gpointer user_data);

extern
gpointer g_datalist_id_dup_data (GData **datalist,
                                         GQuark key_id,
                                         GDuplicateFunc dup_func,
      gpointer user_data);
extern
gboolean g_datalist_id_replace_data (GData **datalist,
                                         GQuark key_id,
                                         gpointer oldval,
                                         gpointer newval,
                                         GDestroyNotify destroy,
      GDestroyNotify *old_destroy);

extern
gpointer g_datalist_id_remove_no_notify (GData **datalist,
      GQuark key_id);
extern
void g_datalist_foreach (GData **datalist,
      GDataForeachFunc func,
      gpointer user_data);
# 91 "/usr/include/glib-2.0/glib/gdataset.h"
extern
void g_datalist_set_flags (GData **datalist,
      guint flags);
extern
void g_datalist_unset_flags (GData **datalist,
      guint flags);
extern
guint g_datalist_get_flags (GData **datalist);
# 115 "/usr/include/glib-2.0/glib/gdataset.h"
extern
void g_dataset_destroy (gconstpointer dataset_location);
extern
gpointer g_dataset_id_get_data (gconstpointer dataset_location,
                                         GQuark key_id);
extern
gpointer g_datalist_get_data (GData **datalist,
       const gchar *key);
extern
void g_dataset_id_set_data_full (gconstpointer dataset_location,
                                         GQuark key_id,
                                         gpointer data,
                                         GDestroyNotify destroy_func);
extern
gpointer g_dataset_id_remove_no_notify (gconstpointer dataset_location,
                                         GQuark key_id);
extern
void g_dataset_foreach (gconstpointer dataset_location,
                                         GDataForeachFunc func,
                                         gpointer user_data);
# 150 "/usr/include/glib-2.0/glib/gdataset.h"

# 45 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gdate.h" 1
# 39 "/usr/include/glib-2.0/glib/gdate.h"

# 50 "/usr/include/glib-2.0/glib/gdate.h"
typedef gint32 GTime;
typedef guint16 GDateYear;
typedef guint8 GDateDay;
typedef struct _GDate GDate;


typedef enum
{
  G_DATE_DAY = 0,
  G_DATE_MONTH = 1,
  G_DATE_YEAR = 2
} GDateDMY;


typedef enum
{
  G_DATE_BAD_WEEKDAY = 0,
  G_DATE_MONDAY = 1,
  G_DATE_TUESDAY = 2,
  G_DATE_WEDNESDAY = 3,
  G_DATE_THURSDAY = 4,
  G_DATE_FRIDAY = 5,
  G_DATE_SATURDAY = 6,
  G_DATE_SUNDAY = 7
} GDateWeekday;
typedef enum
{
  G_DATE_BAD_MONTH = 0,
  G_DATE_JANUARY = 1,
  G_DATE_FEBRUARY = 2,
  G_DATE_MARCH = 3,
  G_DATE_APRIL = 4,
  G_DATE_MAY = 5,
  G_DATE_JUNE = 6,
  G_DATE_JULY = 7,
  G_DATE_AUGUST = 8,
  G_DATE_SEPTEMBER = 9,
  G_DATE_OCTOBER = 10,
  G_DATE_NOVEMBER = 11,
  G_DATE_DECEMBER = 12
} GDateMonth;
# 101 "/usr/include/glib-2.0/glib/gdate.h"
struct _GDate
{
  guint julian_days : 32;





  guint julian : 1;
  guint dmy : 1;


  guint day : 6;
  guint month : 4;
  guint year : 16;
};





extern
GDate* g_date_new (void);
extern
GDate* g_date_new_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year);
extern
GDate* g_date_new_julian (guint32 julian_day);
extern
void g_date_free (GDate *date);






extern
gboolean g_date_valid (const GDate *date);
extern
gboolean g_date_valid_day (GDateDay day) __attribute__((__const__));
extern
gboolean g_date_valid_month (GDateMonth month) __attribute__((__const__));
extern
gboolean g_date_valid_year (GDateYear year) __attribute__((__const__));
extern
gboolean g_date_valid_weekday (GDateWeekday weekday) __attribute__((__const__));
extern
gboolean g_date_valid_julian (guint32 julian_date) __attribute__((__const__));
extern
gboolean g_date_valid_dmy (GDateDay day,
                                           GDateMonth month,
                                           GDateYear year) __attribute__((__const__));

extern
GDateWeekday g_date_get_weekday (const GDate *date);
extern
GDateMonth g_date_get_month (const GDate *date);
extern
GDateYear g_date_get_year (const GDate *date);
extern
GDateDay g_date_get_day (const GDate *date);
extern
guint32 g_date_get_julian (const GDate *date);
extern
guint g_date_get_day_of_year (const GDate *date);






extern
guint g_date_get_monday_week_of_year (const GDate *date);
extern
guint g_date_get_sunday_week_of_year (const GDate *date);
extern
guint g_date_get_iso8601_week_of_year (const GDate *date);





extern
void g_date_clear (GDate *date,
                                           guint n_dates);





extern
void g_date_set_parse (GDate *date,
                                           const gchar *str);
extern
void g_date_set_time_t (GDate *date,
        time_t timet);
extern
void g_date_set_time_val (GDate *date,
        GTimeVal *timeval);

__attribute__((__deprecated__("Use '" "g_date_set_time_t" "' instead"))) extern
void g_date_set_time (GDate *date,
                                           GTime time_);

extern
void g_date_set_month (GDate *date,
                                           GDateMonth month);
extern
void g_date_set_day (GDate *date,
                                           GDateDay day);
extern
void g_date_set_year (GDate *date,
                                           GDateYear year);
extern
void g_date_set_dmy (GDate *date,
                                           GDateDay day,
                                           GDateMonth month,
                                           GDateYear y);
extern
void g_date_set_julian (GDate *date,
                                           guint32 julian_date);
extern
gboolean g_date_is_first_of_month (const GDate *date);
extern
gboolean g_date_is_last_of_month (const GDate *date);


extern
void g_date_add_days (GDate *date,
                                           guint n_days);
extern
void g_date_subtract_days (GDate *date,
                                           guint n_days);


extern
void g_date_add_months (GDate *date,
                                           guint n_months);
extern
void g_date_subtract_months (GDate *date,
                                           guint n_months);


extern
void g_date_add_years (GDate *date,
                                           guint n_years);
extern
void g_date_subtract_years (GDate *date,
                                           guint n_years);
extern
gboolean g_date_is_leap_year (GDateYear year) __attribute__((__const__));
extern
guint8 g_date_get_days_in_month (GDateMonth month,
                                           GDateYear year) __attribute__((__const__));
extern
guint8 g_date_get_monday_weeks_in_year (GDateYear year) __attribute__((__const__));
extern
guint8 g_date_get_sunday_weeks_in_year (GDateYear year) __attribute__((__const__));



extern
gint g_date_days_between (const GDate *date1,
        const GDate *date2);


extern
gint g_date_compare (const GDate *lhs,
                                           const GDate *rhs);
extern
void g_date_to_struct_tm (const GDate *date,
                                           struct tm *tm);

extern
void g_date_clamp (GDate *date,
        const GDate *min_date,
        const GDate *max_date);


extern
void g_date_order (GDate *date1, GDate *date2);




extern
gsize g_date_strftime (gchar *s,
                                           gsize slen,
                                           const gchar *format,
                                           const GDate *date);
# 309 "/usr/include/glib-2.0/glib/gdate.h"

# 46 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gdatetime.h" 1
# 33 "/usr/include/glib-2.0/glib/gdatetime.h"
# 1 "/usr/include/glib-2.0/glib/gtimezone.h" 1
# 31 "/usr/include/glib-2.0/glib/gtimezone.h"


typedef struct _GTimeZone GTimeZone;
# 50 "/usr/include/glib-2.0/glib/gtimezone.h"
typedef enum
{
  G_TIME_TYPE_STANDARD,
  G_TIME_TYPE_DAYLIGHT,
  G_TIME_TYPE_UNIVERSAL
} GTimeType;

extern
GTimeZone * g_time_zone_new (const gchar *identifier);
extern
GTimeZone * g_time_zone_new_utc (void);
extern
GTimeZone * g_time_zone_new_local (void);

extern
GTimeZone * g_time_zone_ref (GTimeZone *tz);
extern
void g_time_zone_unref (GTimeZone *tz);

extern
gint g_time_zone_find_interval (GTimeZone *tz,
                                                                         GTimeType type,
                                                                         gint64 time_);

extern
gint g_time_zone_adjust_time (GTimeZone *tz,
                                                                         GTimeType type,
                                                                         gint64 *time_);

extern
const gchar * g_time_zone_get_abbreviation (GTimeZone *tz,
                                                                         gint interval);
extern
gint32 g_time_zone_get_offset (GTimeZone *tz,
                                                                         gint interval);
extern
gboolean g_time_zone_is_dst (GTimeZone *tz,
                                                                         gint interval);


# 34 "/usr/include/glib-2.0/glib/gdatetime.h" 2


# 89 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef gint64 GTimeSpan;
# 99 "/usr/include/glib-2.0/glib/gdatetime.h"
typedef struct _GDateTime GDateTime;

extern
void g_date_time_unref (GDateTime *datetime);
extern
GDateTime * g_date_time_ref (GDateTime *datetime);

extern
GDateTime * g_date_time_new_now (GTimeZone *tz);
extern
GDateTime * g_date_time_new_now_local (void);
extern
GDateTime * g_date_time_new_now_utc (void);

extern
GDateTime * g_date_time_new_from_unix_local (gint64 t);
extern
GDateTime * g_date_time_new_from_unix_utc (gint64 t);

extern
GDateTime * g_date_time_new_from_timeval_local (const GTimeVal *tv);
extern
GDateTime * g_date_time_new_from_timeval_utc (const GTimeVal *tv);

extern
GDateTime * g_date_time_new (GTimeZone *tz,
                                                                         gint year,
                                                                         gint month,
                                                                         gint day,
                                                                         gint hour,
                                                                         gint minute,
                                                                         gdouble seconds);
extern
GDateTime * g_date_time_new_local (gint year,
                                                                         gint month,
                                                                         gint day,
                                                                         gint hour,
                                                                         gint minute,
                                                                         gdouble seconds);
extern
GDateTime * g_date_time_new_utc (gint year,
                                                                         gint month,
                                                                         gint day,
                                                                         gint hour,
                                                                         gint minute,
                                                                         gdouble seconds);

extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add (GDateTime *datetime,
                                                                         GTimeSpan timespan);

extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_years (GDateTime *datetime,
                                                                         gint years);
extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_months (GDateTime *datetime,
                                                                         gint months);
extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_weeks (GDateTime *datetime,
                                                                         gint weeks);
extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_days (GDateTime *datetime,
                                                                         gint days);

extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_hours (GDateTime *datetime,
                                                                         gint hours);
extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_minutes (GDateTime *datetime,
                                                                         gint minutes);
extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_seconds (GDateTime *datetime,
                                                                         gdouble seconds);

extern
__attribute__((warn_unused_result))
GDateTime * g_date_time_add_full (GDateTime *datetime,
                                                                         gint years,
                                                                         gint months,
                                                                         gint days,
                                                                         gint hours,
                                                                         gint minutes,
                                                                         gdouble seconds);

extern
gint g_date_time_compare (gconstpointer dt1,
                                                                         gconstpointer dt2);
extern
GTimeSpan g_date_time_difference (GDateTime *end,
                                                                         GDateTime *begin);
extern
guint g_date_time_hash (gconstpointer datetime);
extern
gboolean g_date_time_equal (gconstpointer dt1,
                                                                         gconstpointer dt2);

extern
void g_date_time_get_ymd (GDateTime *datetime,
                                                                         gint *year,
                                                                         gint *month,
                                                                         gint *day);

extern
gint g_date_time_get_year (GDateTime *datetime);
extern
gint g_date_time_get_month (GDateTime *datetime);
extern
gint g_date_time_get_day_of_month (GDateTime *datetime);

extern
gint g_date_time_get_week_numbering_year (GDateTime *datetime);
extern
gint g_date_time_get_week_of_year (GDateTime *datetime);
extern
gint g_date_time_get_day_of_week (GDateTime *datetime);

extern
gint g_date_time_get_day_of_year (GDateTime *datetime);

extern
gint g_date_time_get_hour (GDateTime *datetime);
extern
gint g_date_time_get_minute (GDateTime *datetime);
extern
gint g_date_time_get_second (GDateTime *datetime);
extern
gint g_date_time_get_microsecond (GDateTime *datetime);
extern
gdouble g_date_time_get_seconds (GDateTime *datetime);

extern
gint64 g_date_time_to_unix (GDateTime *datetime);
extern
gboolean g_date_time_to_timeval (GDateTime *datetime,
                                                                         GTimeVal *tv);

extern
GTimeSpan g_date_time_get_utc_offset (GDateTime *datetime);
extern
const gchar * g_date_time_get_timezone_abbreviation (GDateTime *datetime);
extern
gboolean g_date_time_is_daylight_savings (GDateTime *datetime);

extern
GDateTime * g_date_time_to_timezone (GDateTime *datetime,
                                                                         GTimeZone *tz);
extern
GDateTime * g_date_time_to_local (GDateTime *datetime);
extern
GDateTime * g_date_time_to_utc (GDateTime *datetime);

extern
gchar * g_date_time_format (GDateTime *datetime,
                                                                         const gchar *format) __attribute__((__malloc__));


# 47 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gdir.h" 1
# 33 "/usr/include/glib-2.0/glib/gdir.h"


typedef struct _GDir GDir;

extern
GDir * g_dir_open (const gchar *path,
            guint flags,
            GError **error);
extern
const gchar * g_dir_read_name (GDir *dir);
extern
void g_dir_rewind (GDir *dir);
extern
void g_dir_close (GDir *dir);
# 60 "/usr/include/glib-2.0/glib/gdir.h"

# 48 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/genviron.h" 1
# 36 "/usr/include/glib-2.0/glib/genviron.h"


extern
const gchar * g_getenv (const gchar *variable);
extern
gboolean g_setenv (const gchar *variable,
                                  const gchar *value,
                                  gboolean overwrite);
extern
void g_unsetenv (const gchar *variable);
extern
gchar ** g_listenv (void);

extern
gchar ** g_get_environ (void);
extern
const gchar * g_environ_getenv (gchar **envp,
                                  const gchar *variable);
extern
gchar ** g_environ_setenv (gchar **envp,
                                  const gchar *variable,
                                  const gchar *value,
                                  gboolean overwrite) __attribute__((warn_unused_result));
extern
gchar ** g_environ_unsetenv (gchar **envp,
                                  const gchar *variable) __attribute__((warn_unused_result));
# 78 "/usr/include/glib-2.0/glib/genviron.h"

# 49 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gfileutils.h" 1
# 30 "/usr/include/glib-2.0/glib/gfileutils.h"




typedef enum
{
  G_FILE_ERROR_EXIST,
  G_FILE_ERROR_ISDIR,
  G_FILE_ERROR_ACCES,
  G_FILE_ERROR_NAMETOOLONG,
  G_FILE_ERROR_NOENT,
  G_FILE_ERROR_NOTDIR,
  G_FILE_ERROR_NXIO,
  G_FILE_ERROR_NODEV,
  G_FILE_ERROR_ROFS,
  G_FILE_ERROR_TXTBSY,
  G_FILE_ERROR_FAULT,
  G_FILE_ERROR_LOOP,
  G_FILE_ERROR_NOSPC,
  G_FILE_ERROR_NOMEM,
  G_FILE_ERROR_MFILE,
  G_FILE_ERROR_NFILE,
  G_FILE_ERROR_BADF,
  G_FILE_ERROR_INVAL,
  G_FILE_ERROR_PIPE,
  G_FILE_ERROR_AGAIN,
  G_FILE_ERROR_INTR,
  G_FILE_ERROR_IO,
  G_FILE_ERROR_PERM,
  G_FILE_ERROR_NOSYS,
  G_FILE_ERROR_FAILED
} GFileError;





typedef enum
{
  G_FILE_TEST_IS_REGULAR = 1 << 0,
  G_FILE_TEST_IS_SYMLINK = 1 << 1,
  G_FILE_TEST_IS_DIR = 1 << 2,
  G_FILE_TEST_IS_EXECUTABLE = 1 << 3,
  G_FILE_TEST_EXISTS = 1 << 4
} GFileTest;

extern
GQuark g_file_error_quark (void);

extern
GFileError g_file_error_from_errno (gint err_no);

extern
gboolean g_file_test (const gchar *filename,
                              GFileTest test);
extern
gboolean g_file_get_contents (const gchar *filename,
                              gchar **contents,
                              gsize *length,
                              GError **error);
extern
gboolean g_file_set_contents (const gchar *filename,
                              const gchar *contents,
                              gssize length,
                              GError **error);
extern
gchar *g_file_read_link (const gchar *filename,
                              GError **error);


extern
gchar *g_mkdtemp (gchar *tmpl);
extern
gchar *g_mkdtemp_full (gchar *tmpl,
                               gint mode);


extern
gint g_mkstemp (gchar *tmpl);
extern
gint g_mkstemp_full (gchar *tmpl,
                               gint flags,
                               gint mode);


extern
gint g_file_open_tmp (const gchar *tmpl,
                               gchar **name_used,
                               GError **error);
extern
gchar *g_dir_make_tmp (const gchar *tmpl,
                               GError **error);

extern
gchar *g_build_path (const gchar *separator,
                               const gchar *first_element,
                               ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
extern
gchar *g_build_pathv (const gchar *separator,
                               gchar **args) __attribute__((__malloc__));

extern
gchar *g_build_filename (const gchar *first_element,
                               ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
extern
gchar *g_build_filenamev (gchar **args) __attribute__((__malloc__));

extern
gint g_mkdir_with_parents (const gchar *pathname,
                               gint mode);
# 163 "/usr/include/glib-2.0/glib/gfileutils.h"
extern
gboolean g_path_is_absolute (const gchar *file_name);
extern
const gchar *g_path_skip_root (const gchar *file_name);

__attribute__((__deprecated__("Use '" "g_path_get_basename" "' instead"))) extern
const gchar *g_basename (const gchar *file_name);




extern
gchar *g_get_current_dir (void);
extern
gchar *g_path_get_basename (const gchar *file_name) __attribute__((__malloc__));
extern
gchar *g_path_get_dirname (const gchar *file_name) __attribute__((__malloc__));
# 206 "/usr/include/glib-2.0/glib/gfileutils.h"

# 51 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/ggettext.h" 1
# 36 "/usr/include/glib-2.0/glib/ggettext.h"


extern
const gchar *g_strip_context (const gchar *msgid,
                              const gchar *msgval) __attribute__((__format_arg__ (1)));

extern
const gchar *g_dgettext (const gchar *domain,
                              const gchar *msgid) __attribute__((__format_arg__ (2)));
extern
const gchar *g_dcgettext (const gchar *domain,
                              const gchar *msgid,
                              gint category) __attribute__((__format_arg__ (2)));
extern
const gchar *g_dngettext (const gchar *domain,
                              const gchar *msgid,
                              const gchar *msgid_plural,
                              gulong n) __attribute__((__format_arg__ (3)));
extern
const gchar *g_dpgettext (const gchar *domain,
                              const gchar *msgctxtid,
                              gsize msgidoffset) __attribute__((__format_arg__ (2)));
extern
const gchar *g_dpgettext2 (const gchar *domain,
                              const gchar *context,
                              const gchar *msgid) __attribute__((__format_arg__ (3)));


# 52 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/ghash.h" 1
# 35 "/usr/include/glib-2.0/glib/ghash.h"
# 1 "/usr/include/glib-2.0/glib/glist.h" 1
# 34 "/usr/include/glib-2.0/glib/glist.h"
# 1 "/usr/include/glib-2.0/glib/gmem.h" 1
# 36 "/usr/include/glib-2.0/glib/gmem.h"

# 51 "/usr/include/glib-2.0/glib/gmem.h"
typedef struct _GMemVTable GMemVTable;
# 70 "/usr/include/glib-2.0/glib/gmem.h"
extern
void g_free (gpointer mem);

extern
void g_clear_pointer (gpointer *pp,
                           GDestroyNotify destroy);

extern
gpointer g_malloc (gsize n_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern
gpointer g_malloc0 (gsize n_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern
gpointer g_realloc (gpointer mem,
      gsize n_bytes) __attribute__((warn_unused_result));
extern
gpointer g_try_malloc (gsize n_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern
gpointer g_try_malloc0 (gsize n_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern
gpointer g_try_realloc (gpointer mem,
      gsize n_bytes) __attribute__((warn_unused_result));

extern
gpointer g_malloc_n (gsize n_blocks,
      gsize n_block_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2)));
extern
gpointer g_malloc0_n (gsize n_blocks,
      gsize n_block_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2)));
extern
gpointer g_realloc_n (gpointer mem,
      gsize n_blocks,
      gsize n_block_bytes) __attribute__((warn_unused_result));
extern
gpointer g_try_malloc_n (gsize n_blocks,
      gsize n_block_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2)));
extern
gpointer g_try_malloc0_n (gsize n_blocks,
      gsize n_block_bytes) __attribute__((__malloc__)) __attribute__((__alloc_size__(1,2)));
extern
gpointer g_try_realloc_n (gpointer mem,
      gsize n_blocks,
      gsize n_block_bytes) __attribute__((warn_unused_result));
# 274 "/usr/include/glib-2.0/glib/gmem.h"
struct _GMemVTable {
  gpointer (*malloc) (gsize n_bytes);
  gpointer (*realloc) (gpointer mem,
      gsize n_bytes);
  void (*free) (gpointer mem);

  gpointer (*calloc) (gsize n_blocks,
      gsize n_block_bytes);
  gpointer (*try_malloc) (gsize n_bytes);
  gpointer (*try_realloc) (gpointer mem,
      gsize n_bytes);
};
extern
void g_mem_set_vtable (GMemVTable *vtable);
extern
gboolean g_mem_is_system_malloc (void);

extern gboolean g_mem_gc_friendly;



extern GMemVTable *glib_mem_profiler_table;
extern
void g_mem_profile (void);


# 35 "/usr/include/glib-2.0/glib/glist.h" 2
# 1 "/usr/include/glib-2.0/glib/gnode.h" 1
# 36 "/usr/include/glib-2.0/glib/gnode.h"


typedef struct _GNode GNode;


typedef enum
{
  G_TRAVERSE_LEAVES = 1 << 0,
  G_TRAVERSE_NON_LEAVES = 1 << 1,
  G_TRAVERSE_ALL = G_TRAVERSE_LEAVES | G_TRAVERSE_NON_LEAVES,
  G_TRAVERSE_MASK = 0x03,
  G_TRAVERSE_LEAFS = G_TRAVERSE_LEAVES,
  G_TRAVERSE_NON_LEAFS = G_TRAVERSE_NON_LEAVES
} GTraverseFlags;


typedef enum
{
  G_IN_ORDER,
  G_PRE_ORDER,
  G_POST_ORDER,
  G_LEVEL_ORDER
} GTraverseType;

typedef gboolean (*GNodeTraverseFunc) (GNode *node,
       gpointer data);
typedef void (*GNodeForeachFunc) (GNode *node,
       gpointer data);
# 77 "/usr/include/glib-2.0/glib/gnode.h"
typedef gpointer (*GCopyFunc) (gconstpointer src,
                                                 gpointer data);



struct _GNode
{
  gpointer data;
  GNode *next;
  GNode *prev;
  GNode *parent;
  GNode *children;
};
# 115 "/usr/include/glib-2.0/glib/gnode.h"
extern
GNode* g_node_new (gpointer data);
extern
void g_node_destroy (GNode *root);
extern
void g_node_unlink (GNode *node);
extern
GNode* g_node_copy_deep (GNode *node,
     GCopyFunc copy_func,
     gpointer data);
extern
GNode* g_node_copy (GNode *node);
extern
GNode* g_node_insert (GNode *parent,
     gint position,
     GNode *node);
extern
GNode* g_node_insert_before (GNode *parent,
     GNode *sibling,
     GNode *node);
extern
GNode* g_node_insert_after (GNode *parent,
     GNode *sibling,
     GNode *node);
extern
GNode* g_node_prepend (GNode *parent,
     GNode *node);
extern
guint g_node_n_nodes (GNode *root,
     GTraverseFlags flags);
extern
GNode* g_node_get_root (GNode *node);
extern
gboolean g_node_is_ancestor (GNode *node,
     GNode *descendant);
extern
guint g_node_depth (GNode *node);
extern
GNode* g_node_find (GNode *root,
     GTraverseType order,
     GTraverseFlags flags,
     gpointer data);
# 240 "/usr/include/glib-2.0/glib/gnode.h"
extern
void g_node_traverse (GNode *root,
     GTraverseType order,
     GTraverseFlags flags,
     gint max_depth,
     GNodeTraverseFunc func,
     gpointer data);






extern
guint g_node_max_height (GNode *root);

extern
void g_node_children_foreach (GNode *node,
      GTraverseFlags flags,
      GNodeForeachFunc func,
      gpointer data);
extern
void g_node_reverse_children (GNode *node);
extern
guint g_node_n_children (GNode *node);
extern
GNode* g_node_nth_child (GNode *node,
      guint n);
extern
GNode* g_node_last_child (GNode *node);
extern
GNode* g_node_find_child (GNode *node,
      GTraverseFlags flags,
      gpointer data);
extern
gint g_node_child_position (GNode *node,
      GNode *child);
extern
gint g_node_child_index (GNode *node,
      gpointer data);

extern
GNode* g_node_first_sibling (GNode *node);
extern
GNode* g_node_last_sibling (GNode *node);
# 322 "/usr/include/glib-2.0/glib/gnode.h"

# 36 "/usr/include/glib-2.0/glib/glist.h" 2



typedef struct _GList GList;

struct _GList
{
  gpointer data;
  GList *next;
  GList *prev;
};



extern
GList* g_list_alloc (void) __attribute__((warn_unused_result));
extern
void g_list_free (GList *list);
extern
void g_list_free_1 (GList *list);

extern
void g_list_free_full (GList *list,
      GDestroyNotify free_func);
extern
GList* g_list_append (GList *list,
      gpointer data) __attribute__((warn_unused_result));
extern
GList* g_list_prepend (GList *list,
      gpointer data) __attribute__((warn_unused_result));
extern
GList* g_list_insert (GList *list,
      gpointer data,
      gint position) __attribute__((warn_unused_result));
extern
GList* g_list_insert_sorted (GList *list,
      gpointer data,
      GCompareFunc func) __attribute__((warn_unused_result));
extern
GList* g_list_insert_sorted_with_data (GList *list,
      gpointer data,
      GCompareDataFunc func,
      gpointer user_data) __attribute__((warn_unused_result));
extern
GList* g_list_insert_before (GList *list,
      GList *sibling,
      gpointer data) __attribute__((warn_unused_result));
extern
GList* g_list_concat (GList *list1,
      GList *list2) __attribute__((warn_unused_result));
extern
GList* g_list_remove (GList *list,
      gconstpointer data) __attribute__((warn_unused_result));
extern
GList* g_list_remove_all (GList *list,
      gconstpointer data) __attribute__((warn_unused_result));
extern
GList* g_list_remove_link (GList *list,
      GList *llink) __attribute__((warn_unused_result));
extern
GList* g_list_delete_link (GList *list,
      GList *link_) __attribute__((warn_unused_result));
extern
GList* g_list_reverse (GList *list) __attribute__((warn_unused_result));
extern
GList* g_list_copy (GList *list) __attribute__((warn_unused_result));

extern
GList* g_list_copy_deep (GList *list,
      GCopyFunc func,
      gpointer user_data) __attribute__((warn_unused_result));

extern
GList* g_list_nth (GList *list,
      guint n);
extern
GList* g_list_nth_prev (GList *list,
      guint n);
extern
GList* g_list_find (GList *list,
      gconstpointer data);
extern
GList* g_list_find_custom (GList *list,
      gconstpointer data,
      GCompareFunc func);
extern
gint g_list_position (GList *list,
      GList *llink);
extern
gint g_list_index (GList *list,
      gconstpointer data);
extern
GList* g_list_last (GList *list);
extern
GList* g_list_first (GList *list);
extern
guint g_list_length (GList *list);
extern
void g_list_foreach (GList *list,
      GFunc func,
      gpointer user_data);
extern
GList* g_list_sort (GList *list,
      GCompareFunc compare_func) __attribute__((warn_unused_result));
extern
GList* g_list_sort_with_data (GList *list,
      GCompareDataFunc compare_func,
      gpointer user_data) __attribute__((warn_unused_result));
extern
gpointer g_list_nth_data (GList *list,
      guint n);






# 36 "/usr/include/glib-2.0/glib/ghash.h" 2



typedef struct _GHashTable GHashTable;

typedef gboolean (*GHRFunc) (gpointer key,
                               gpointer value,
                               gpointer user_data);

typedef struct _GHashTableIter GHashTableIter;

struct _GHashTableIter
{

  gpointer dummy1;
  gpointer dummy2;
  gpointer dummy3;
  int dummy4;
  gboolean dummy5;
  gpointer dummy6;
};

extern
GHashTable* g_hash_table_new (GHashFunc hash_func,
                                            GEqualFunc key_equal_func);
extern
GHashTable* g_hash_table_new_full (GHashFunc hash_func,
                                            GEqualFunc key_equal_func,
                                            GDestroyNotify key_destroy_func,
                                            GDestroyNotify value_destroy_func);
extern
void g_hash_table_destroy (GHashTable *hash_table);
extern
void g_hash_table_insert (GHashTable *hash_table,
                                            gpointer key,
                                            gpointer value);
extern
void g_hash_table_replace (GHashTable *hash_table,
                                            gpointer key,
                                            gpointer value);
extern
void g_hash_table_add (GHashTable *hash_table,
                                            gpointer key);
extern
gboolean g_hash_table_remove (GHashTable *hash_table,
                                            gconstpointer key);
extern
void g_hash_table_remove_all (GHashTable *hash_table);
extern
gboolean g_hash_table_steal (GHashTable *hash_table,
                                            gconstpointer key);
extern
void g_hash_table_steal_all (GHashTable *hash_table);
extern
gpointer g_hash_table_lookup (GHashTable *hash_table,
                                            gconstpointer key);
extern
gboolean g_hash_table_contains (GHashTable *hash_table,
                                            gconstpointer key);
extern
gboolean g_hash_table_lookup_extended (GHashTable *hash_table,
                                            gconstpointer lookup_key,
                                            gpointer *orig_key,
                                            gpointer *value);
extern
void g_hash_table_foreach (GHashTable *hash_table,
                                            GHFunc func,
                                            gpointer user_data);
extern
gpointer g_hash_table_find (GHashTable *hash_table,
                                            GHRFunc predicate,
                                            gpointer user_data);
extern
guint g_hash_table_foreach_remove (GHashTable *hash_table,
                                            GHRFunc func,
                                            gpointer user_data);
extern
guint g_hash_table_foreach_steal (GHashTable *hash_table,
                                            GHRFunc func,
                                            gpointer user_data);
extern
guint g_hash_table_size (GHashTable *hash_table);
extern
GList * g_hash_table_get_keys (GHashTable *hash_table);
extern
GList * g_hash_table_get_values (GHashTable *hash_table);

extern
void g_hash_table_iter_init (GHashTableIter *iter,
                                            GHashTable *hash_table);
extern
gboolean g_hash_table_iter_next (GHashTableIter *iter,
                                            gpointer *key,
                                            gpointer *value);
extern
GHashTable* g_hash_table_iter_get_hash_table (GHashTableIter *iter);
extern
void g_hash_table_iter_remove (GHashTableIter *iter);
extern
void g_hash_table_iter_replace (GHashTableIter *iter,
                                            gpointer value);
extern
void g_hash_table_iter_steal (GHashTableIter *iter);

extern
GHashTable* g_hash_table_ref (GHashTable *hash_table);
extern
void g_hash_table_unref (GHashTable *hash_table);
# 152 "/usr/include/glib-2.0/glib/ghash.h"
extern
gboolean g_str_equal (gconstpointer v1,
                         gconstpointer v2);
extern
guint g_str_hash (gconstpointer v);

extern
gboolean g_int_equal (gconstpointer v1,
                         gconstpointer v2);
extern
guint g_int_hash (gconstpointer v);

extern
gboolean g_int64_equal (gconstpointer v1,
                         gconstpointer v2);
extern
guint g_int64_hash (gconstpointer v);

extern
gboolean g_double_equal (gconstpointer v1,
                         gconstpointer v2);
extern
guint g_double_hash (gconstpointer v);

extern
guint g_direct_hash (gconstpointer v) __attribute__((__const__));
extern
gboolean g_direct_equal (gconstpointer v1,
                         gconstpointer v2) __attribute__((__const__));


# 53 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/ghmac.h" 1
# 29 "/usr/include/glib-2.0/glib/ghmac.h"
# 1 "/usr/include/glib-2.0/glib/gchecksum.h" 1
# 30 "/usr/include/glib-2.0/glib/ghmac.h" 2


# 42 "/usr/include/glib-2.0/glib/ghmac.h"
typedef struct _GHmac GHmac;

extern
GHmac * g_hmac_new (GChecksumType digest_type,
                                                     const guchar *key,
                                                     gsize key_len);
extern
GHmac * g_hmac_copy (const GHmac *hmac);
extern
GHmac * g_hmac_ref (GHmac *hmac);
extern
void g_hmac_unref (GHmac *hmac);
extern
void g_hmac_update (GHmac *hmac,
                                                     const guchar *data,
                                                     gssize length);
extern
const gchar * g_hmac_get_string (GHmac *hmac);
extern
void g_hmac_get_digest (GHmac *hmac,
                                                     guint8 *buffer,
                                                     gsize *digest_len);

extern
gchar *g_compute_hmac_for_data (GChecksumType digest_type,
                                                     const guchar *key,
                                                     gsize key_len,
                                                     const guchar *data,
                                                     gsize length);
extern
gchar *g_compute_hmac_for_string (GChecksumType digest_type,
                                                     const guchar *key,
                                                     gsize key_len,
                                                     const gchar *str,
                                                     gssize length);


# 54 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/ghook.h" 1
# 36 "/usr/include/glib-2.0/glib/ghook.h"




typedef struct _GHook GHook;
typedef struct _GHookList GHookList;

typedef gint (*GHookCompareFunc) (GHook *new_hook,
       GHook *sibling);
typedef gboolean (*GHookFindFunc) (GHook *hook,
       gpointer data);
typedef void (*GHookMarshaller) (GHook *hook,
       gpointer marshal_data);
typedef gboolean (*GHookCheckMarshaller) (GHook *hook,
       gpointer marshal_data);
typedef void (*GHookFunc) (gpointer data);
typedef gboolean (*GHookCheckFunc) (gpointer data);
typedef void (*GHookFinalizeFunc) (GHookList *hook_list,
       GHook *hook);
typedef enum
{
  G_HOOK_FLAG_ACTIVE = 1 << 0,
  G_HOOK_FLAG_IN_CALL = 1 << 1,
  G_HOOK_FLAG_MASK = 0x0f
} GHookFlagMask;




struct _GHookList
{
  gulong seq_id;
  guint hook_size : 16;
  guint is_setup : 1;
  GHook *hooks;
  gpointer dummy3;
  GHookFinalizeFunc finalize_hook;
  gpointer dummy[2];
};
struct _GHook
{
  gpointer data;
  GHook *next;
  GHook *prev;
  guint ref_count;
  gulong hook_id;
  guint flags;
  gpointer func;
  GDestroyNotify destroy;
};
# 106 "/usr/include/glib-2.0/glib/ghook.h"
extern
void g_hook_list_init (GHookList *hook_list,
      guint hook_size);
extern
void g_hook_list_clear (GHookList *hook_list);
extern
GHook* g_hook_alloc (GHookList *hook_list);
extern
void g_hook_free (GHookList *hook_list,
      GHook *hook);
extern
GHook * g_hook_ref (GHookList *hook_list,
      GHook *hook);
extern
void g_hook_unref (GHookList *hook_list,
      GHook *hook);
extern
gboolean g_hook_destroy (GHookList *hook_list,
      gulong hook_id);
extern
void g_hook_destroy_link (GHookList *hook_list,
      GHook *hook);
extern
void g_hook_prepend (GHookList *hook_list,
      GHook *hook);
extern
void g_hook_insert_before (GHookList *hook_list,
      GHook *sibling,
      GHook *hook);
extern
void g_hook_insert_sorted (GHookList *hook_list,
      GHook *hook,
      GHookCompareFunc func);
extern
GHook* g_hook_get (GHookList *hook_list,
      gulong hook_id);
extern
GHook* g_hook_find (GHookList *hook_list,
      gboolean need_valids,
      GHookFindFunc func,
      gpointer data);
extern
GHook* g_hook_find_data (GHookList *hook_list,
      gboolean need_valids,
      gpointer data);
extern
GHook* g_hook_find_func (GHookList *hook_list,
      gboolean need_valids,
      gpointer func);
extern
GHook* g_hook_find_func_data (GHookList *hook_list,
      gboolean need_valids,
      gpointer func,
      gpointer data);

extern
GHook* g_hook_first_valid (GHookList *hook_list,
      gboolean may_be_in_call);



extern
GHook* g_hook_next_valid (GHookList *hook_list,
      GHook *hook,
      gboolean may_be_in_call);

extern
gint g_hook_compare_ids (GHook *new_hook,
      GHook *sibling);





extern
void g_hook_list_invoke (GHookList *hook_list,
      gboolean may_recurse);



extern
void g_hook_list_invoke_check (GHookList *hook_list,
      gboolean may_recurse);


extern
void g_hook_list_marshal (GHookList *hook_list,
      gboolean may_recurse,
      GHookMarshaller marshaller,
      gpointer marshal_data);
extern
void g_hook_list_marshal_check (GHookList *hook_list,
      gboolean may_recurse,
      GHookCheckMarshaller marshaller,
      gpointer marshal_data);


# 55 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/ghostutils.h" 1
# 29 "/usr/include/glib-2.0/glib/ghostutils.h"


extern
gboolean g_hostname_is_non_ascii (const gchar *hostname);
extern
gboolean g_hostname_is_ascii_encoded (const gchar *hostname);
extern
gboolean g_hostname_is_ip_address (const gchar *hostname);

extern
gchar *g_hostname_to_ascii (const gchar *hostname);
extern
gchar *g_hostname_to_unicode (const gchar *hostname);


# 56 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/giochannel.h" 1
# 35 "/usr/include/glib-2.0/glib/giochannel.h"
# 1 "/usr/include/glib-2.0/glib/gmain.h" 1
# 27 "/usr/include/glib-2.0/glib/gmain.h"
# 1 "/usr/include/glib-2.0/glib/gpoll.h" 1
# 29 "/usr/include/glib-2.0/glib/gpoll.h"

# 61 "/usr/include/glib-2.0/glib/gpoll.h"
typedef struct _GPollFD GPollFD;
# 76 "/usr/include/glib-2.0/glib/gpoll.h"
typedef gint (*GPollFunc) (GPollFD *ufds,
                                 guint nfsd,
                                 gint timeout_);
# 93 "/usr/include/glib-2.0/glib/gpoll.h"
struct _GPollFD
{



  gint fd;

  gushort events;
  gushort revents;
};
# 114 "/usr/include/glib-2.0/glib/gpoll.h"
extern
gint g_poll (GPollFD *fds,
      guint nfds,
      gint timeout);


# 28 "/usr/include/glib-2.0/glib/gmain.h" 2
# 1 "/usr/include/glib-2.0/glib/gslist.h" 1
# 37 "/usr/include/glib-2.0/glib/gslist.h"


typedef struct _GSList GSList;

struct _GSList
{
  gpointer data;
  GSList *next;
};



extern
GSList* g_slist_alloc (void) __attribute__((warn_unused_result));
extern
void g_slist_free (GSList *list);
extern
void g_slist_free_1 (GSList *list);

extern
void g_slist_free_full (GSList *list,
       GDestroyNotify free_func);
extern
GSList* g_slist_append (GSList *list,
       gpointer data) __attribute__((warn_unused_result));
extern
GSList* g_slist_prepend (GSList *list,
       gpointer data) __attribute__((warn_unused_result));
extern
GSList* g_slist_insert (GSList *list,
       gpointer data,
       gint position) __attribute__((warn_unused_result));
extern
GSList* g_slist_insert_sorted (GSList *list,
       gpointer data,
       GCompareFunc func) __attribute__((warn_unused_result));
extern
GSList* g_slist_insert_sorted_with_data (GSList *list,
       gpointer data,
       GCompareDataFunc func,
       gpointer user_data) __attribute__((warn_unused_result));
extern
GSList* g_slist_insert_before (GSList *slist,
       GSList *sibling,
       gpointer data) __attribute__((warn_unused_result));
extern
GSList* g_slist_concat (GSList *list1,
       GSList *list2) __attribute__((warn_unused_result));
extern
GSList* g_slist_remove (GSList *list,
       gconstpointer data) __attribute__((warn_unused_result));
extern
GSList* g_slist_remove_all (GSList *list,
       gconstpointer data) __attribute__((warn_unused_result));
extern
GSList* g_slist_remove_link (GSList *list,
       GSList *link_) __attribute__((warn_unused_result));
extern
GSList* g_slist_delete_link (GSList *list,
       GSList *link_) __attribute__((warn_unused_result));
extern
GSList* g_slist_reverse (GSList *list) __attribute__((warn_unused_result));
extern
GSList* g_slist_copy (GSList *list) __attribute__((warn_unused_result));

extern
GSList* g_slist_copy_deep (GSList *list,
       GCopyFunc func,
       gpointer user_data) __attribute__((warn_unused_result));
extern
GSList* g_slist_nth (GSList *list,
       guint n);
extern
GSList* g_slist_find (GSList *list,
       gconstpointer data);
extern
GSList* g_slist_find_custom (GSList *list,
       gconstpointer data,
       GCompareFunc func);
extern
gint g_slist_position (GSList *list,
       GSList *llink);
extern
gint g_slist_index (GSList *list,
       gconstpointer data);
extern
GSList* g_slist_last (GSList *list);
extern
guint g_slist_length (GSList *list);
extern
void g_slist_foreach (GSList *list,
       GFunc func,
       gpointer user_data);
extern
GSList* g_slist_sort (GSList *list,
       GCompareFunc compare_func) __attribute__((warn_unused_result));
extern
GSList* g_slist_sort_with_data (GSList *list,
       GCompareDataFunc compare_func,
       gpointer user_data) __attribute__((warn_unused_result));
extern
gpointer g_slist_nth_data (GSList *list,
       guint n);




# 29 "/usr/include/glib-2.0/glib/gmain.h" 2




typedef enum
{
  G_IO_IN =1,
  G_IO_OUT =4,
  G_IO_PRI =2,
  G_IO_ERR =8,
  G_IO_HUP =16,
  G_IO_NVAL =32
} GIOCondition;
# 50 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GMainContext GMainContext;







typedef struct _GMainLoop GMainLoop;







typedef struct _GSource GSource;
typedef struct _GSourcePrivate GSourcePrivate;
# 79 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceCallbackFuncs GSourceCallbackFuncs;
# 130 "/usr/include/glib-2.0/glib/gmain.h"
typedef struct _GSourceFuncs GSourceFuncs;
# 154 "/usr/include/glib-2.0/glib/gmain.h"
typedef gboolean (*GSourceFunc) (gpointer user_data);
# 167 "/usr/include/glib-2.0/glib/gmain.h"
typedef void (*GChildWatchFunc) (GPid pid,
                                       gint status,
                                       gpointer user_data);
struct _GSource
{

  gpointer callback_data;
  GSourceCallbackFuncs *callback_funcs;

  const GSourceFuncs *source_funcs;
  guint ref_count;

  GMainContext *context;

  gint priority;
  guint flags;
  guint source_id;

  GSList *poll_fds;

  GSource *prev;
  GSource *next;

  char *name;

  GSourcePrivate *priv;
};

struct _GSourceCallbackFuncs
{
  void (*ref) (gpointer cb_data);
  void (*unref) (gpointer cb_data);
  void (*get) (gpointer cb_data,
                 GSource *source,
                 GSourceFunc *func,
                 gpointer *data);
};







typedef void (*GSourceDummyMarshal) (void);

struct _GSourceFuncs
{
  gboolean (*prepare) (GSource *source,
                        gint *timeout_);
  gboolean (*check) (GSource *source);
  gboolean (*dispatch) (GSource *source,
                        GSourceFunc callback,
                        gpointer user_data);
  void (*finalize) (GSource *source);



  GSourceFunc closure_callback;
  GSourceDummyMarshal closure_marshal;
};
# 304 "/usr/include/glib-2.0/glib/gmain.h"
extern
GMainContext *g_main_context_new (void);
extern
GMainContext *g_main_context_ref (GMainContext *context);
extern
void g_main_context_unref (GMainContext *context);
extern
GMainContext *g_main_context_default (void);

extern
gboolean g_main_context_iteration (GMainContext *context,
                                        gboolean may_block);
extern
gboolean g_main_context_pending (GMainContext *context);



extern
GSource *g_main_context_find_source_by_id (GMainContext *context,
                                                             guint source_id);
extern
GSource *g_main_context_find_source_by_user_data (GMainContext *context,
                                                             gpointer user_data);
extern
GSource *g_main_context_find_source_by_funcs_user_data (GMainContext *context,
                                                             GSourceFuncs *funcs,
                                                             gpointer user_data);



extern
void g_main_context_wakeup (GMainContext *context);
extern
gboolean g_main_context_acquire (GMainContext *context);
extern
void g_main_context_release (GMainContext *context);
extern
gboolean g_main_context_is_owner (GMainContext *context);
extern
gboolean g_main_context_wait (GMainContext *context,
                                 GCond *cond,
                                 GMutex *mutex);

extern
gboolean g_main_context_prepare (GMainContext *context,
                                  gint *priority);
extern
gint g_main_context_query (GMainContext *context,
                                  gint max_priority,
                                  gint *timeout_,
                                  GPollFD *fds,
                                  gint n_fds);
extern
gint g_main_context_check (GMainContext *context,
                                  gint max_priority,
                                  GPollFD *fds,
                                  gint n_fds);
extern
void g_main_context_dispatch (GMainContext *context);

extern
void g_main_context_set_poll_func (GMainContext *context,
                                       GPollFunc func);
extern
GPollFunc g_main_context_get_poll_func (GMainContext *context);



extern
void g_main_context_add_poll (GMainContext *context,
                                     GPollFD *fd,
                                     gint priority);
extern
void g_main_context_remove_poll (GMainContext *context,
                                     GPollFD *fd);

extern
gint g_main_depth (void);
extern
GSource *g_main_current_source (void);



extern
void g_main_context_push_thread_default (GMainContext *context);
extern
void g_main_context_pop_thread_default (GMainContext *context);
extern
GMainContext *g_main_context_get_thread_default (void);
extern
GMainContext *g_main_context_ref_thread_default (void);



extern
GMainLoop *g_main_loop_new (GMainContext *context,
                                   gboolean is_running);
extern
void g_main_loop_run (GMainLoop *loop);
extern
void g_main_loop_quit (GMainLoop *loop);
extern
GMainLoop *g_main_loop_ref (GMainLoop *loop);
extern
void g_main_loop_unref (GMainLoop *loop);
extern
gboolean g_main_loop_is_running (GMainLoop *loop);
extern
GMainContext *g_main_loop_get_context (GMainLoop *loop);



extern
GSource *g_source_new (GSourceFuncs *source_funcs,
                                   guint struct_size);
extern
GSource *g_source_ref (GSource *source);
extern
void g_source_unref (GSource *source);

extern
guint g_source_attach (GSource *source,
                                   GMainContext *context);
extern
void g_source_destroy (GSource *source);

extern
void g_source_set_priority (GSource *source,
                                   gint priority);
extern
gint g_source_get_priority (GSource *source);
extern
void g_source_set_can_recurse (GSource *source,
                                   gboolean can_recurse);
extern
gboolean g_source_get_can_recurse (GSource *source);
extern
guint g_source_get_id (GSource *source);

extern
GMainContext *g_source_get_context (GSource *source);

extern
void g_source_set_callback (GSource *source,
                                   GSourceFunc func,
                                   gpointer data,
                                   GDestroyNotify notify);

extern
void g_source_set_funcs (GSource *source,
                                   GSourceFuncs *funcs);
extern
gboolean g_source_is_destroyed (GSource *source);

extern
void g_source_set_name (GSource *source,
                                              const char *name);
extern
const char * g_source_get_name (GSource *source);
extern
void g_source_set_name_by_id (guint tag,
                                              const char *name);

extern
void g_source_set_ready_time (GSource *source,
                                              gint64 ready_time);
extern
gint64 g_source_get_ready_time (GSource *source);


extern
gpointer g_source_add_unix_fd (GSource *source,
                                              gint fd,
                                              GIOCondition events);
extern
void g_source_modify_unix_fd (GSource *source,
                                              gpointer tag,
                                              GIOCondition new_events);
extern
void g_source_remove_unix_fd (GSource *source,
                                              gpointer tag);
extern
GIOCondition g_source_query_unix_fd (GSource *source,
                                              gpointer tag);



extern
void g_source_set_callback_indirect (GSource *source,
                                     gpointer callback_data,
                                     GSourceCallbackFuncs *callback_funcs);

extern
void g_source_add_poll (GSource *source,
           GPollFD *fd);
extern
void g_source_remove_poll (GSource *source,
           GPollFD *fd);

extern
void g_source_add_child_source (GSource *source,
           GSource *child_source);
extern
void g_source_remove_child_source (GSource *source,
           GSource *child_source);

__attribute__((__deprecated__("Use '" "g_source_get_time" "' instead"))) extern
void g_source_get_current_time (GSource *source,
                                    GTimeVal *timeval);

extern
gint64 g_source_get_time (GSource *source);







extern
GSource *g_idle_source_new (void);
extern
GSource *g_child_watch_source_new (GPid pid);
extern
GSource *g_timeout_source_new (guint interval);
extern
GSource *g_timeout_source_new_seconds (guint interval);



extern
void g_get_current_time (GTimeVal *result);
extern
gint64 g_get_monotonic_time (void);
extern
gint64 g_get_real_time (void);



extern
gboolean g_source_remove (guint tag);
extern
gboolean g_source_remove_by_user_data (gpointer user_data);
extern
gboolean g_source_remove_by_funcs_user_data (GSourceFuncs *funcs,
                                              gpointer user_data);


extern
guint g_timeout_add_full (gint priority,
                                     guint interval,
                                     GSourceFunc function,
                                     gpointer data,
                                     GDestroyNotify notify);
extern
guint g_timeout_add (guint interval,
                                     GSourceFunc function,
                                     gpointer data);
extern
guint g_timeout_add_seconds_full (gint priority,
                                     guint interval,
                                     GSourceFunc function,
                                     gpointer data,
                                     GDestroyNotify notify);
extern
guint g_timeout_add_seconds (guint interval,
                                     GSourceFunc function,
                                     gpointer data);
extern
guint g_child_watch_add_full (gint priority,
                                     GPid pid,
                                     GChildWatchFunc function,
                                     gpointer data,
                                     GDestroyNotify notify);
extern
guint g_child_watch_add (GPid pid,
                                     GChildWatchFunc function,
                                     gpointer data);
extern
guint g_idle_add (GSourceFunc function,
                                     gpointer data);
extern
guint g_idle_add_full (gint priority,
                                     GSourceFunc function,
                                     gpointer data,
                                     GDestroyNotify notify);
extern
gboolean g_idle_remove_by_data (gpointer data);

extern
void g_main_context_invoke_full (GMainContext *context,
                                     gint priority,
                                     GSourceFunc function,
                                     gpointer data,
                                     GDestroyNotify notify);
extern
void g_main_context_invoke (GMainContext *context,
                                     GSourceFunc function,
                                     gpointer data);


extern GSourceFuncs g_timeout_funcs;
extern GSourceFuncs g_child_watch_funcs;
extern GSourceFuncs g_idle_funcs;


# 36 "/usr/include/glib-2.0/glib/giochannel.h" 2
# 1 "/usr/include/glib-2.0/glib/gstring.h" 1
# 35 "/usr/include/glib-2.0/glib/gstring.h"
# 1 "/usr/include/glib-2.0/glib/gunicode.h" 1
# 32 "/usr/include/glib-2.0/glib/gunicode.h"

# 61 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint32 gunichar;
# 79 "/usr/include/glib-2.0/glib/gunicode.h"
typedef guint16 gunichar2;
# 118 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum
{
  G_UNICODE_CONTROL,
  G_UNICODE_FORMAT,
  G_UNICODE_UNASSIGNED,
  G_UNICODE_PRIVATE_USE,
  G_UNICODE_SURROGATE,
  G_UNICODE_LOWERCASE_LETTER,
  G_UNICODE_MODIFIER_LETTER,
  G_UNICODE_OTHER_LETTER,
  G_UNICODE_TITLECASE_LETTER,
  G_UNICODE_UPPERCASE_LETTER,
  G_UNICODE_SPACING_MARK,
  G_UNICODE_ENCLOSING_MARK,
  G_UNICODE_NON_SPACING_MARK,
  G_UNICODE_DECIMAL_NUMBER,
  G_UNICODE_LETTER_NUMBER,
  G_UNICODE_OTHER_NUMBER,
  G_UNICODE_CONNECT_PUNCTUATION,
  G_UNICODE_DASH_PUNCTUATION,
  G_UNICODE_CLOSE_PUNCTUATION,
  G_UNICODE_FINAL_PUNCTUATION,
  G_UNICODE_INITIAL_PUNCTUATION,
  G_UNICODE_OTHER_PUNCTUATION,
  G_UNICODE_OPEN_PUNCTUATION,
  G_UNICODE_CURRENCY_SYMBOL,
  G_UNICODE_MODIFIER_SYMBOL,
  G_UNICODE_MATH_SYMBOL,
  G_UNICODE_OTHER_SYMBOL,
  G_UNICODE_LINE_SEPARATOR,
  G_UNICODE_PARAGRAPH_SEPARATOR,
  G_UNICODE_SPACE_SEPARATOR
} GUnicodeType;
# 213 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum
{
  G_UNICODE_BREAK_MANDATORY,
  G_UNICODE_BREAK_CARRIAGE_RETURN,
  G_UNICODE_BREAK_LINE_FEED,
  G_UNICODE_BREAK_COMBINING_MARK,
  G_UNICODE_BREAK_SURROGATE,
  G_UNICODE_BREAK_ZERO_WIDTH_SPACE,
  G_UNICODE_BREAK_INSEPARABLE,
  G_UNICODE_BREAK_NON_BREAKING_GLUE,
  G_UNICODE_BREAK_CONTINGENT,
  G_UNICODE_BREAK_SPACE,
  G_UNICODE_BREAK_AFTER,
  G_UNICODE_BREAK_BEFORE,
  G_UNICODE_BREAK_BEFORE_AND_AFTER,
  G_UNICODE_BREAK_HYPHEN,
  G_UNICODE_BREAK_NON_STARTER,
  G_UNICODE_BREAK_OPEN_PUNCTUATION,
  G_UNICODE_BREAK_CLOSE_PUNCTUATION,
  G_UNICODE_BREAK_QUOTATION,
  G_UNICODE_BREAK_EXCLAMATION,
  G_UNICODE_BREAK_IDEOGRAPHIC,
  G_UNICODE_BREAK_NUMERIC,
  G_UNICODE_BREAK_INFIX_SEPARATOR,
  G_UNICODE_BREAK_SYMBOL,
  G_UNICODE_BREAK_ALPHABETIC,
  G_UNICODE_BREAK_PREFIX,
  G_UNICODE_BREAK_POSTFIX,
  G_UNICODE_BREAK_COMPLEX_CONTEXT,
  G_UNICODE_BREAK_AMBIGUOUS,
  G_UNICODE_BREAK_UNKNOWN,
  G_UNICODE_BREAK_NEXT_LINE,
  G_UNICODE_BREAK_WORD_JOINER,
  G_UNICODE_BREAK_HANGUL_L_JAMO,
  G_UNICODE_BREAK_HANGUL_V_JAMO,
  G_UNICODE_BREAK_HANGUL_T_JAMO,
  G_UNICODE_BREAK_HANGUL_LV_SYLLABLE,
  G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE,
  G_UNICODE_BREAK_CLOSE_PARANTHESIS,
  G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER,
  G_UNICODE_BREAK_HEBREW_LETTER,
  G_UNICODE_BREAK_REGIONAL_INDICATOR
} GUnicodeBreakType;
# 387 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum
{
  G_UNICODE_SCRIPT_INVALID_CODE = -1,
  G_UNICODE_SCRIPT_COMMON = 0,
  G_UNICODE_SCRIPT_INHERITED,
  G_UNICODE_SCRIPT_ARABIC,
  G_UNICODE_SCRIPT_ARMENIAN,
  G_UNICODE_SCRIPT_BENGALI,
  G_UNICODE_SCRIPT_BOPOMOFO,
  G_UNICODE_SCRIPT_CHEROKEE,
  G_UNICODE_SCRIPT_COPTIC,
  G_UNICODE_SCRIPT_CYRILLIC,
  G_UNICODE_SCRIPT_DESERET,
  G_UNICODE_SCRIPT_DEVANAGARI,
  G_UNICODE_SCRIPT_ETHIOPIC,
  G_UNICODE_SCRIPT_GEORGIAN,
  G_UNICODE_SCRIPT_GOTHIC,
  G_UNICODE_SCRIPT_GREEK,
  G_UNICODE_SCRIPT_GUJARATI,
  G_UNICODE_SCRIPT_GURMUKHI,
  G_UNICODE_SCRIPT_HAN,
  G_UNICODE_SCRIPT_HANGUL,
  G_UNICODE_SCRIPT_HEBREW,
  G_UNICODE_SCRIPT_HIRAGANA,
  G_UNICODE_SCRIPT_KANNADA,
  G_UNICODE_SCRIPT_KATAKANA,
  G_UNICODE_SCRIPT_KHMER,
  G_UNICODE_SCRIPT_LAO,
  G_UNICODE_SCRIPT_LATIN,
  G_UNICODE_SCRIPT_MALAYALAM,
  G_UNICODE_SCRIPT_MONGOLIAN,
  G_UNICODE_SCRIPT_MYANMAR,
  G_UNICODE_SCRIPT_OGHAM,
  G_UNICODE_SCRIPT_OLD_ITALIC,
  G_UNICODE_SCRIPT_ORIYA,
  G_UNICODE_SCRIPT_RUNIC,
  G_UNICODE_SCRIPT_SINHALA,
  G_UNICODE_SCRIPT_SYRIAC,
  G_UNICODE_SCRIPT_TAMIL,
  G_UNICODE_SCRIPT_TELUGU,
  G_UNICODE_SCRIPT_THAANA,
  G_UNICODE_SCRIPT_THAI,
  G_UNICODE_SCRIPT_TIBETAN,
  G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL,
  G_UNICODE_SCRIPT_YI,
  G_UNICODE_SCRIPT_TAGALOG,
  G_UNICODE_SCRIPT_HANUNOO,
  G_UNICODE_SCRIPT_BUHID,
  G_UNICODE_SCRIPT_TAGBANWA,


  G_UNICODE_SCRIPT_BRAILLE,
  G_UNICODE_SCRIPT_CYPRIOT,
  G_UNICODE_SCRIPT_LIMBU,
  G_UNICODE_SCRIPT_OSMANYA,
  G_UNICODE_SCRIPT_SHAVIAN,
  G_UNICODE_SCRIPT_LINEAR_B,
  G_UNICODE_SCRIPT_TAI_LE,
  G_UNICODE_SCRIPT_UGARITIC,


  G_UNICODE_SCRIPT_NEW_TAI_LUE,
  G_UNICODE_SCRIPT_BUGINESE,
  G_UNICODE_SCRIPT_GLAGOLITIC,
  G_UNICODE_SCRIPT_TIFINAGH,
  G_UNICODE_SCRIPT_SYLOTI_NAGRI,
  G_UNICODE_SCRIPT_OLD_PERSIAN,
  G_UNICODE_SCRIPT_KHAROSHTHI,


  G_UNICODE_SCRIPT_UNKNOWN,
  G_UNICODE_SCRIPT_BALINESE,
  G_UNICODE_SCRIPT_CUNEIFORM,
  G_UNICODE_SCRIPT_PHOENICIAN,
  G_UNICODE_SCRIPT_PHAGS_PA,
  G_UNICODE_SCRIPT_NKO,


  G_UNICODE_SCRIPT_KAYAH_LI,
  G_UNICODE_SCRIPT_LEPCHA,
  G_UNICODE_SCRIPT_REJANG,
  G_UNICODE_SCRIPT_SUNDANESE,
  G_UNICODE_SCRIPT_SAURASHTRA,
  G_UNICODE_SCRIPT_CHAM,
  G_UNICODE_SCRIPT_OL_CHIKI,
  G_UNICODE_SCRIPT_VAI,
  G_UNICODE_SCRIPT_CARIAN,
  G_UNICODE_SCRIPT_LYCIAN,
  G_UNICODE_SCRIPT_LYDIAN,


  G_UNICODE_SCRIPT_AVESTAN,
  G_UNICODE_SCRIPT_BAMUM,
  G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS,
  G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC,
  G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI,
  G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN,
  G_UNICODE_SCRIPT_JAVANESE,
  G_UNICODE_SCRIPT_KAITHI,
  G_UNICODE_SCRIPT_LISU,
  G_UNICODE_SCRIPT_MEETEI_MAYEK,
  G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN,
  G_UNICODE_SCRIPT_OLD_TURKIC,
  G_UNICODE_SCRIPT_SAMARITAN,
  G_UNICODE_SCRIPT_TAI_THAM,
  G_UNICODE_SCRIPT_TAI_VIET,


  G_UNICODE_SCRIPT_BATAK,
  G_UNICODE_SCRIPT_BRAHMI,
  G_UNICODE_SCRIPT_MANDAIC,


  G_UNICODE_SCRIPT_CHAKMA,
  G_UNICODE_SCRIPT_MEROITIC_CURSIVE,
  G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS,
  G_UNICODE_SCRIPT_MIAO,
  G_UNICODE_SCRIPT_SHARADA,
  G_UNICODE_SCRIPT_SORA_SOMPENG,
  G_UNICODE_SCRIPT_TAKRI
} GUnicodeScript;

extern
guint32 g_unicode_script_to_iso15924 (GUnicodeScript script);
extern
GUnicodeScript g_unicode_script_from_iso15924 (guint32 iso15924);



extern
gboolean g_unichar_isalnum (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isalpha (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_iscntrl (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isdigit (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isgraph (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_islower (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isprint (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_ispunct (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isspace (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isupper (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isxdigit (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_istitle (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_isdefined (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_iswide (gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_iswide_cjk(gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_iszerowidth(gunichar c) __attribute__((__const__));
extern
gboolean g_unichar_ismark (gunichar c) __attribute__((__const__));



extern
gunichar g_unichar_toupper (gunichar c) __attribute__((__const__));
extern
gunichar g_unichar_tolower (gunichar c) __attribute__((__const__));
extern
gunichar g_unichar_totitle (gunichar c) __attribute__((__const__));



extern
gint g_unichar_digit_value (gunichar c) __attribute__((__const__));

extern
gint g_unichar_xdigit_value (gunichar c) __attribute__((__const__));


extern
GUnicodeType g_unichar_type (gunichar c) __attribute__((__const__));


extern
GUnicodeBreakType g_unichar_break_type (gunichar c) __attribute__((__const__));


extern
gint g_unichar_combining_class (gunichar uc) __attribute__((__const__));

extern
gboolean g_unichar_get_mirror_char (gunichar ch,
                                    gunichar *mirrored_ch);

extern
GUnicodeScript g_unichar_get_script (gunichar ch) __attribute__((__const__));


extern
gboolean g_unichar_validate (gunichar ch) __attribute__((__const__));


extern
gboolean g_unichar_compose (gunichar a,
                            gunichar b,
                            gunichar *ch);
extern
gboolean g_unichar_decompose (gunichar ch,
                              gunichar *a,
                              gunichar *b);

extern
gsize g_unichar_fully_decompose (gunichar ch,
                                 gboolean compat,
                                 gunichar *result,
                                 gsize result_len);
# 622 "/usr/include/glib-2.0/glib/gunicode.h"
extern
void g_unicode_canonical_ordering (gunichar *string,
                                   gsize len);


__attribute__((__deprecated__)) extern
gunichar *g_unicode_canonical_decomposition (gunichar ch,
                                             gsize *result_len) __attribute__((__malloc__));



extern const gchar * const g_utf8_skip;
# 648 "/usr/include/glib-2.0/glib/gunicode.h"
extern
gunichar g_utf8_get_char (const gchar *p) __attribute__((__pure__));
extern
gunichar g_utf8_get_char_validated (const gchar *p,
                                    gssize max_len) __attribute__((__pure__));

extern
gchar* g_utf8_offset_to_pointer (const gchar *str,
                                   glong offset) __attribute__((__pure__));
extern
glong g_utf8_pointer_to_offset (const gchar *str,
                                   const gchar *pos) __attribute__((__pure__));
extern
gchar* g_utf8_prev_char (const gchar *p) __attribute__((__pure__));
extern
gchar* g_utf8_find_next_char (const gchar *p,
                                   const gchar *end) __attribute__((__pure__));
extern
gchar* g_utf8_find_prev_char (const gchar *str,
                                   const gchar *p) __attribute__((__pure__));

extern
glong g_utf8_strlen (const gchar *p,
                                   gssize max) __attribute__((__pure__));

extern
gchar *g_utf8_substring (const gchar *str,
                                   glong start_pos,
                                   glong end_pos) __attribute__((__malloc__));

extern
gchar *g_utf8_strncpy (gchar *dest,
                                   const gchar *src,
                                   gsize n);



extern
gchar* g_utf8_strchr (const gchar *p,
                       gssize len,
                       gunichar c);
extern
gchar* g_utf8_strrchr (const gchar *p,
                       gssize len,
                       gunichar c);
extern
gchar* g_utf8_strreverse (const gchar *str,
                          gssize len);

extern
gunichar2 *g_utf8_to_utf16 (const gchar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error) __attribute__((__malloc__));
extern
gunichar * g_utf8_to_ucs4 (const gchar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error) __attribute__((__malloc__));
extern
gunichar * g_utf8_to_ucs4_fast (const gchar *str,
                                glong len,
                                glong *items_written) __attribute__((__malloc__));
extern
gunichar * g_utf16_to_ucs4 (const gunichar2 *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error) __attribute__((__malloc__));
extern
gchar* g_utf16_to_utf8 (const gunichar2 *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error) __attribute__((__malloc__));
extern
gunichar2 *g_ucs4_to_utf16 (const gunichar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error) __attribute__((__malloc__));
extern
gchar* g_ucs4_to_utf8 (const gunichar *str,
                                glong len,
                                glong *items_read,
                                glong *items_written,
                                GError **error) __attribute__((__malloc__));

extern
gint g_unichar_to_utf8 (gunichar c,
                             gchar *outbuf);

extern
gboolean g_utf8_validate (const gchar *str,
                          gssize max_len,
                          const gchar **end);

extern
gchar *g_utf8_strup (const gchar *str,
                       gssize len) __attribute__((__malloc__));
extern
gchar *g_utf8_strdown (const gchar *str,
                       gssize len) __attribute__((__malloc__));
extern
gchar *g_utf8_casefold (const gchar *str,
                        gssize len) __attribute__((__malloc__));
# 781 "/usr/include/glib-2.0/glib/gunicode.h"
typedef enum {
  G_NORMALIZE_DEFAULT,
  G_NORMALIZE_NFD = G_NORMALIZE_DEFAULT,
  G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_NFC = G_NORMALIZE_DEFAULT_COMPOSE,
  G_NORMALIZE_ALL,
  G_NORMALIZE_NFKD = G_NORMALIZE_ALL,
  G_NORMALIZE_ALL_COMPOSE,
  G_NORMALIZE_NFKC = G_NORMALIZE_ALL_COMPOSE
} GNormalizeMode;

extern
gchar *g_utf8_normalize (const gchar *str,
                         gssize len,
                         GNormalizeMode mode) __attribute__((__malloc__));

extern
gint g_utf8_collate (const gchar *str1,
                           const gchar *str2) __attribute__((__pure__));
extern
gchar *g_utf8_collate_key (const gchar *str,
                           gssize len) __attribute__((__malloc__));
extern
gchar *g_utf8_collate_key_for_filename (const gchar *str,
                                        gssize len) __attribute__((__malloc__));



gchar *_g_utf8_make_valid (const gchar *name);


# 36 "/usr/include/glib-2.0/glib/gstring.h" 2

# 1 "/usr/include/glib-2.0/glib/gutils.h" 1
# 37 "/usr/include/glib-2.0/glib/gutils.h"

# 87 "/usr/include/glib-2.0/glib/gutils.h"
extern
const gchar * g_get_user_name (void);
extern
const gchar * g_get_real_name (void);
extern
const gchar * g_get_home_dir (void);
extern
const gchar * g_get_tmp_dir (void);
extern
const gchar * g_get_host_name (void);
extern
const gchar * g_get_prgname (void);
extern
void g_set_prgname (const gchar *prgname);
extern
const gchar * g_get_application_name (void);
extern
void g_set_application_name (const gchar *application_name);

extern
void g_reload_user_special_dirs_cache (void);
extern
const gchar * g_get_user_data_dir (void);
extern
const gchar * g_get_user_config_dir (void);
extern
const gchar * g_get_user_cache_dir (void);
extern
const gchar * const * g_get_system_data_dirs (void);
# 136 "/usr/include/glib-2.0/glib/gutils.h"
extern
const gchar * const * g_get_system_config_dirs (void);

extern
const gchar * g_get_user_runtime_dir (void);
# 164 "/usr/include/glib-2.0/glib/gutils.h"
typedef enum {
  G_USER_DIRECTORY_DESKTOP,
  G_USER_DIRECTORY_DOCUMENTS,
  G_USER_DIRECTORY_DOWNLOAD,
  G_USER_DIRECTORY_MUSIC,
  G_USER_DIRECTORY_PICTURES,
  G_USER_DIRECTORY_PUBLIC_SHARE,
  G_USER_DIRECTORY_TEMPLATES,
  G_USER_DIRECTORY_VIDEOS,

  G_USER_N_DIRECTORIES
} GUserDirectory;

extern
const gchar * g_get_user_special_dir (GUserDirectory directory);
# 188 "/usr/include/glib-2.0/glib/gutils.h"
typedef struct _GDebugKey GDebugKey;
struct _GDebugKey
{
  const gchar *key;
  guint value;
};



extern
guint g_parse_debug_string (const gchar *string,
         const GDebugKey *keys,
         guint nkeys);

extern
gint g_snprintf (gchar *string,
         gulong n,
         gchar const *format,
         ...) __attribute__((__format__ (__printf__, 3, 4)));
extern
gint g_vsnprintf (gchar *string,
         gulong n,
         gchar const *format,
         va_list args)
         __attribute__((__format__ (__printf__, 3, 0)));

extern
void g_nullify_pointer (gpointer *nullify_location);

typedef enum
{
  G_FORMAT_SIZE_DEFAULT = 0,
  G_FORMAT_SIZE_LONG_FORMAT = 1 << 0,
  G_FORMAT_SIZE_IEC_UNITS = 1 << 1
} GFormatSizeFlags;

extern
gchar *g_format_size_full (guint64 size,
                             GFormatSizeFlags flags);
extern
gchar *g_format_size (guint64 size);

__attribute__((__deprecated__("Use '" "g_format_size" "' instead"))) extern
gchar *g_format_size_for_display (goffset size);
# 241 "/usr/include/glib-2.0/glib/gutils.h"
typedef void (*GVoidFunc) (void);
# 252 "/usr/include/glib-2.0/glib/gutils.h"
__attribute__((__deprecated__)) extern
void g_atexit (GVoidFunc func);
# 272 "/usr/include/glib-2.0/glib/gutils.h"
extern
gchar* g_find_program_in_path (const gchar *program);



static __inline __attribute__ ((unused)) gint g_bit_nth_lsf (gulong mask,
           gint nth_bit) __attribute__((__const__));
static __inline __attribute__ ((unused)) gint g_bit_nth_msf (gulong mask,
           gint nth_bit) __attribute__((__const__));
static __inline __attribute__ ((unused)) guint g_bit_storage (gulong number) __attribute__((__const__));




static __inline __attribute__ ((unused)) gint
g_bit_nth_lsf (gulong mask,
        gint nth_bit)
{
  if ((__builtin_expect (__extension__ ({ int _g_boolean_var_; if (nth_bit < -1) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 0)))
    nth_bit = -1;
  while (nth_bit < ((8 * 8) - 1))
    {
      nth_bit++;
      if (mask & (1UL << nth_bit))
 return nth_bit;
    }
  return -1;
}
static __inline __attribute__ ((unused)) gint
g_bit_nth_msf (gulong mask,
        gint nth_bit)
{
  if (nth_bit < 0 || (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (nth_bit > 8 * 8) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 0)))
    nth_bit = 8 * 8;
  while (nth_bit > 0)
    {
      nth_bit--;
      if (mask & (1UL << nth_bit))
 return nth_bit;
    }
  return -1;
}
static __inline __attribute__ ((unused)) guint
g_bit_storage (gulong number)
{

  return (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (number) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ?
    ((8 * 8U - 1) ^ (guint) __builtin_clzl(number)) + 1 : 1;
# 331 "/usr/include/glib-2.0/glib/gutils.h"
}
# 383 "/usr/include/glib-2.0/glib/gutils.h"

# 38 "/usr/include/glib-2.0/glib/gstring.h" 2



typedef struct _GString GString;

struct _GString
{
  gchar *str;
  gsize len;
  gsize allocated_len;
};

extern
GString* g_string_new (const gchar *init);
extern
GString* g_string_new_len (const gchar *init,
                                         gssize len);
extern
GString* g_string_sized_new (gsize dfl_size);
extern
gchar* g_string_free (GString *string,
                                         gboolean free_segment);
extern
GBytes* g_string_free_to_bytes (GString *string);
extern
gboolean g_string_equal (const GString *v,
                                         const GString *v2);
extern
guint g_string_hash (const GString *str);
extern
GString* g_string_assign (GString *string,
                                         const gchar *rval);
extern
GString* g_string_truncate (GString *string,
                                         gsize len);
extern
GString* g_string_set_size (GString *string,
                                         gsize len);
extern
GString* g_string_insert_len (GString *string,
                                         gssize pos,
                                         const gchar *val,
                                         gssize len);
extern
GString* g_string_append (GString *string,
                                         const gchar *val);
extern
GString* g_string_append_len (GString *string,
                                         const gchar *val,
                                         gssize len);
extern
GString* g_string_append_c (GString *string,
                                         gchar c);
extern
GString* g_string_append_unichar (GString *string,
                                         gunichar wc);
extern
GString* g_string_prepend (GString *string,
                                         const gchar *val);
extern
GString* g_string_prepend_c (GString *string,
                                         gchar c);
extern
GString* g_string_prepend_unichar (GString *string,
                                         gunichar wc);
extern
GString* g_string_prepend_len (GString *string,
                                         const gchar *val,
                                         gssize len);
extern
GString* g_string_insert (GString *string,
                                         gssize pos,
                                         const gchar *val);
extern
GString* g_string_insert_c (GString *string,
                                         gssize pos,
                                         gchar c);
extern
GString* g_string_insert_unichar (GString *string,
                                         gssize pos,
                                         gunichar wc);
extern
GString* g_string_overwrite (GString *string,
                                         gsize pos,
                                         const gchar *val);
extern
GString* g_string_overwrite_len (GString *string,
                                         gsize pos,
                                         const gchar *val,
                                         gssize len);
extern
GString* g_string_erase (GString *string,
                                         gssize pos,
                                         gssize len);
extern
GString* g_string_ascii_down (GString *string);
extern
GString* g_string_ascii_up (GString *string);
extern
void g_string_vprintf (GString *string,
                                         const gchar *format,
                                         va_list args)
                                         __attribute__((__format__ (__printf__, 2, 0)));
extern
void g_string_printf (GString *string,
                                         const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 2, 3)));
extern
void g_string_append_vprintf (GString *string,
                                         const gchar *format,
                                         va_list args)
                                         __attribute__((__format__ (__printf__, 2, 0)));
extern
void g_string_append_printf (GString *string,
                                         const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 2, 3)));
extern
GString* g_string_append_uri_escaped (GString *string,
                                          const gchar *unescaped,
                                          const gchar *reserved_chars_allowed,
                                          gboolean allow_utf8);



static inline GString*
g_string_append_c_inline (GString *gstring,
                          gchar c)
{
  if (gstring->len + 1 < gstring->allocated_len)
    {
      gstring->str[gstring->len++] = c;
      gstring->str[gstring->len] = 0;
    }
  else
    g_string_insert_c (gstring, -1, c);
  return gstring;
}




__attribute__((__deprecated__)) extern
GString *g_string_down (GString *string);
__attribute__((__deprecated__)) extern
GString *g_string_up (GString *string);







# 37 "/usr/include/glib-2.0/glib/giochannel.h" 2






typedef struct _GIOChannel GIOChannel;
typedef struct _GIOFuncs GIOFuncs;

typedef enum
{
  G_IO_ERROR_NONE,
  G_IO_ERROR_AGAIN,
  G_IO_ERROR_INVAL,
  G_IO_ERROR_UNKNOWN
} GIOError;



typedef enum
{

  G_IO_CHANNEL_ERROR_FBIG,
  G_IO_CHANNEL_ERROR_INVAL,
  G_IO_CHANNEL_ERROR_IO,
  G_IO_CHANNEL_ERROR_ISDIR,
  G_IO_CHANNEL_ERROR_NOSPC,
  G_IO_CHANNEL_ERROR_NXIO,
  G_IO_CHANNEL_ERROR_OVERFLOW,
  G_IO_CHANNEL_ERROR_PIPE,

  G_IO_CHANNEL_ERROR_FAILED
} GIOChannelError;

typedef enum
{
  G_IO_STATUS_ERROR,
  G_IO_STATUS_NORMAL,
  G_IO_STATUS_EOF,
  G_IO_STATUS_AGAIN
} GIOStatus;

typedef enum
{
  G_SEEK_CUR,
  G_SEEK_SET,
  G_SEEK_END
} GSeekType;

typedef enum
{
  G_IO_FLAG_APPEND = 1 << 0,
  G_IO_FLAG_NONBLOCK = 1 << 1,
  G_IO_FLAG_IS_READABLE = 1 << 2,
  G_IO_FLAG_IS_WRITABLE = 1 << 3,
  G_IO_FLAG_IS_WRITEABLE = 1 << 3,
  G_IO_FLAG_IS_SEEKABLE = 1 << 4,
  G_IO_FLAG_MASK = (1 << 5) - 1,
  G_IO_FLAG_GET_MASK = G_IO_FLAG_MASK,
  G_IO_FLAG_SET_MASK = G_IO_FLAG_APPEND | G_IO_FLAG_NONBLOCK
} GIOFlags;

struct _GIOChannel
{

  gint ref_count;
  GIOFuncs *funcs;

  gchar *encoding;
  GIConv read_cd;
  GIConv write_cd;
  gchar *line_term;
  guint line_term_len;

  gsize buf_size;
  GString *read_buf;
  GString *encoded_read_buf;
  GString *write_buf;
  gchar partial_write_buf[6];



  guint use_buffer : 1;
  guint do_encode : 1;
  guint close_on_unref : 1;
  guint is_readable : 1;
  guint is_writeable : 1;
  guint is_seekable : 1;

  gpointer reserved1;
  gpointer reserved2;
};

typedef gboolean (*GIOFunc) (GIOChannel *source,
        GIOCondition condition,
        gpointer data);
struct _GIOFuncs
{
  GIOStatus (*io_read) (GIOChannel *channel,
             gchar *buf,
      gsize count,
      gsize *bytes_read,
      GError **err);
  GIOStatus (*io_write) (GIOChannel *channel,
      const gchar *buf,
      gsize count,
      gsize *bytes_written,
      GError **err);
  GIOStatus (*io_seek) (GIOChannel *channel,
      gint64 offset,
      GSeekType type,
      GError **err);
  GIOStatus (*io_close) (GIOChannel *channel,
      GError **err);
  GSource* (*io_create_watch) (GIOChannel *channel,
      GIOCondition condition);
  void (*io_free) (GIOChannel *channel);
  GIOStatus (*io_set_flags) (GIOChannel *channel,
                                  GIOFlags flags,
      GError **err);
  GIOFlags (*io_get_flags) (GIOChannel *channel);
};

extern
void g_io_channel_init (GIOChannel *channel);
extern
GIOChannel *g_io_channel_ref (GIOChannel *channel);
extern
void g_io_channel_unref (GIOChannel *channel);

__attribute__((__deprecated__("Use '" "g_io_channel_read_for" "' instead"))) extern
GIOError g_io_channel_read (GIOChannel *channel,
                                 gchar *buf,
                                 gsize count,
                                 gsize *bytes_read);

__attribute__((__deprecated__("Use '" "g_io_channel_write_chars" "' instead"))) extern
GIOError g_io_channel_write (GIOChannel *channel,
                                 const gchar *buf,
                                 gsize count,
                                 gsize *bytes_written);

__attribute__((__deprecated__("Use '" "g_io_channel_seek_position" "' instead"))) extern
GIOError g_io_channel_seek (GIOChannel *channel,
                                 gint64 offset,
                                 GSeekType type);

__attribute__((__deprecated__("Use '" "g_io_channel_shutdown" "' instead"))) extern
void g_io_channel_close (GIOChannel *channel);

extern
GIOStatus g_io_channel_shutdown (GIOChannel *channel,
     gboolean flush,
     GError **err);
extern
guint g_io_add_watch_full (GIOChannel *channel,
     gint priority,
     GIOCondition condition,
     GIOFunc func,
     gpointer user_data,
     GDestroyNotify notify);
extern
GSource * g_io_create_watch (GIOChannel *channel,
     GIOCondition condition);
extern
guint g_io_add_watch (GIOChannel *channel,
     GIOCondition condition,
     GIOFunc func,
     gpointer user_data);




extern
void g_io_channel_set_buffer_size (GIOChannel *channel,
        gsize size);
extern
gsize g_io_channel_get_buffer_size (GIOChannel *channel);
extern
GIOCondition g_io_channel_get_buffer_condition (GIOChannel *channel);
extern
GIOStatus g_io_channel_set_flags (GIOChannel *channel,
        GIOFlags flags,
        GError **error);
extern
GIOFlags g_io_channel_get_flags (GIOChannel *channel);
extern
void g_io_channel_set_line_term (GIOChannel *channel,
        const gchar *line_term,
        gint length);
extern
const gchar * g_io_channel_get_line_term (GIOChannel *channel,
        gint *length);
extern
void g_io_channel_set_buffered (GIOChannel *channel,
        gboolean buffered);
extern
gboolean g_io_channel_get_buffered (GIOChannel *channel);
extern
GIOStatus g_io_channel_set_encoding (GIOChannel *channel,
        const gchar *encoding,
        GError **error);
extern
const gchar * g_io_channel_get_encoding (GIOChannel *channel);
extern
void g_io_channel_set_close_on_unref (GIOChannel *channel,
        gboolean do_close);
extern
gboolean g_io_channel_get_close_on_unref (GIOChannel *channel);


extern
GIOStatus g_io_channel_flush (GIOChannel *channel,
        GError **error);
extern
GIOStatus g_io_channel_read_line (GIOChannel *channel,
        gchar **str_return,
        gsize *length,
        gsize *terminator_pos,
        GError **error);
extern
GIOStatus g_io_channel_read_line_string (GIOChannel *channel,
        GString *buffer,
        gsize *terminator_pos,
        GError **error);
extern
GIOStatus g_io_channel_read_to_end (GIOChannel *channel,
        gchar **str_return,
        gsize *length,
        GError **error);
extern
GIOStatus g_io_channel_read_chars (GIOChannel *channel,
        gchar *buf,
        gsize count,
        gsize *bytes_read,
        GError **error);
extern
GIOStatus g_io_channel_read_unichar (GIOChannel *channel,
        gunichar *thechar,
        GError **error);
extern
GIOStatus g_io_channel_write_chars (GIOChannel *channel,
        const gchar *buf,
        gssize count,
        gsize *bytes_written,
        GError **error);
extern
GIOStatus g_io_channel_write_unichar (GIOChannel *channel,
        gunichar thechar,
        GError **error);
extern
GIOStatus g_io_channel_seek_position (GIOChannel *channel,
        gint64 offset,
        GSeekType type,
        GError **error);
extern
GIOChannel* g_io_channel_new_file (const gchar *filename,
        const gchar *mode,
        GError **error);



extern
GQuark g_io_channel_error_quark (void);
extern
GIOChannelError g_io_channel_error_from_errno (gint en);
# 322 "/usr/include/glib-2.0/glib/giochannel.h"
extern
GIOChannel* g_io_channel_unix_new (int fd);
extern
gint g_io_channel_unix_get_fd (GIOChannel *channel);



extern GSourceFuncs g_io_watch_funcs;
# 413 "/usr/include/glib-2.0/glib/giochannel.h"

# 57 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gkeyfile.h" 1
# 32 "/usr/include/glib-2.0/glib/gkeyfile.h"


typedef enum
{
  G_KEY_FILE_ERROR_UNKNOWN_ENCODING,
  G_KEY_FILE_ERROR_PARSE,
  G_KEY_FILE_ERROR_NOT_FOUND,
  G_KEY_FILE_ERROR_KEY_NOT_FOUND,
  G_KEY_FILE_ERROR_GROUP_NOT_FOUND,
  G_KEY_FILE_ERROR_INVALID_VALUE
} GKeyFileError;



extern
GQuark g_key_file_error_quark (void);

typedef struct _GKeyFile GKeyFile;

typedef enum
{
  G_KEY_FILE_NONE = 0,
  G_KEY_FILE_KEEP_COMMENTS = 1 << 0,
  G_KEY_FILE_KEEP_TRANSLATIONS = 1 << 1
} GKeyFileFlags;

extern
GKeyFile *g_key_file_new (void);
extern
GKeyFile *g_key_file_ref (GKeyFile *key_file);
extern
void g_key_file_unref (GKeyFile *key_file);
extern
void g_key_file_free (GKeyFile *key_file);
extern
void g_key_file_set_list_separator (GKeyFile *key_file,
          gchar separator);
extern
gboolean g_key_file_load_from_file (GKeyFile *key_file,
          const gchar *file,
          GKeyFileFlags flags,
          GError **error);
extern
gboolean g_key_file_load_from_data (GKeyFile *key_file,
          const gchar *data,
          gsize length,
          GKeyFileFlags flags,
          GError **error);
extern
gboolean g_key_file_load_from_dirs (GKeyFile *key_file,
          const gchar *file,
          const gchar **search_dirs,
          gchar **full_path,
          GKeyFileFlags flags,
          GError **error);
extern
gboolean g_key_file_load_from_data_dirs (GKeyFile *key_file,
          const gchar *file,
          gchar **full_path,
          GKeyFileFlags flags,
          GError **error);
extern
gchar *g_key_file_to_data (GKeyFile *key_file,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
gchar *g_key_file_get_start_group (GKeyFile *key_file) __attribute__((__malloc__));
extern
gchar **g_key_file_get_groups (GKeyFile *key_file,
          gsize *length) __attribute__((__malloc__));
extern
gchar **g_key_file_get_keys (GKeyFile *key_file,
          const gchar *group_name,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
gboolean g_key_file_has_group (GKeyFile *key_file,
          const gchar *group_name);
extern
gboolean g_key_file_has_key (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
extern
gchar *g_key_file_get_value (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_value (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *value);
extern
gchar *g_key_file_get_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *string);
extern
gchar *g_key_file_get_locale_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_locale_string (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          const gchar *string);
extern
gboolean g_key_file_get_boolean (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
extern
void g_key_file_set_boolean (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gboolean value);
extern
gint g_key_file_get_integer (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
extern
void g_key_file_set_integer (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gint value);
extern
gint64 g_key_file_get_int64 (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
extern
void g_key_file_set_int64 (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gint64 value);
extern
guint64 g_key_file_get_uint64 (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
extern
void g_key_file_set_uint64 (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          guint64 value);
extern
gdouble g_key_file_get_double (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             GError **error);
extern
void g_key_file_set_double (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             gdouble value);
extern
gchar **g_key_file_get_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar * const list[],
          gsize length);
extern
gchar **g_key_file_get_locale_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_locale_string_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          const gchar *locale,
          const gchar * const list[],
          gsize length);
extern
gboolean *g_key_file_get_boolean_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_boolean_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gboolean list[],
          gsize length);
extern
gint *g_key_file_get_integer_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gsize *length,
          GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_double_list (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             gdouble list[],
                                             gsize length);
extern
gdouble *g_key_file_get_double_list (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             gsize *length,
                                             GError **error) __attribute__((__malloc__));
extern
void g_key_file_set_integer_list (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          gint list[],
          gsize length);
extern
gboolean g_key_file_set_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             const gchar *comment,
                                             GError **error);
extern
gchar *g_key_file_get_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
                                             GError **error) __attribute__((__malloc__));

extern
gboolean g_key_file_remove_comment (GKeyFile *key_file,
                                             const gchar *group_name,
                                             const gchar *key,
          GError **error);
extern
gboolean g_key_file_remove_key (GKeyFile *key_file,
          const gchar *group_name,
          const gchar *key,
          GError **error);
extern
gboolean g_key_file_remove_group (GKeyFile *key_file,
          const gchar *group_name,
          GError **error);
# 313 "/usr/include/glib-2.0/glib/gkeyfile.h"

# 58 "/usr/include/glib-2.0/glib.h" 2



# 1 "/usr/include/glib-2.0/glib/gmappedfile.h" 1
# 32 "/usr/include/glib-2.0/glib/gmappedfile.h"


typedef struct _GMappedFile GMappedFile;

extern
GMappedFile *g_mapped_file_new (const gchar *filename,
             gboolean writable,
             GError **error) __attribute__((__malloc__));
extern
GMappedFile *g_mapped_file_new_from_fd (gint fd,
      gboolean writable,
      GError **error) __attribute__((__malloc__));
extern
gsize g_mapped_file_get_length (GMappedFile *file);
extern
gchar *g_mapped_file_get_contents (GMappedFile *file);
extern
GBytes * g_mapped_file_get_bytes (GMappedFile *file);
extern
GMappedFile *g_mapped_file_ref (GMappedFile *file);
extern
void g_mapped_file_unref (GMappedFile *file);

__attribute__((__deprecated__("Use '" "g_mapped_file_unref" "' instead"))) extern
void g_mapped_file_free (GMappedFile *file);


# 62 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gmarkup.h" 1
# 33 "/usr/include/glib-2.0/glib/gmarkup.h"

# 51 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum
{
  G_MARKUP_ERROR_BAD_UTF8,
  G_MARKUP_ERROR_EMPTY,
  G_MARKUP_ERROR_PARSE,



  G_MARKUP_ERROR_UNKNOWN_ELEMENT,
  G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE,
  G_MARKUP_ERROR_INVALID_CONTENT,
  G_MARKUP_ERROR_MISSING_ATTRIBUTE
} GMarkupError;
# 74 "/usr/include/glib-2.0/glib/gmarkup.h"
extern
GQuark g_markup_error_quark (void);
# 93 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef enum
{
  G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1 << 0,
  G_MARKUP_TREAT_CDATA_AS_TEXT = 1 << 1,
  G_MARKUP_PREFIX_ERROR_POSITION = 1 << 2
} GMarkupParseFlags;
# 109 "/usr/include/glib-2.0/glib/gmarkup.h"
typedef struct _GMarkupParseContext GMarkupParseContext;
typedef struct _GMarkupParser GMarkupParser;
# 139 "/usr/include/glib-2.0/glib/gmarkup.h"
struct _GMarkupParser
{

  void (*start_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          const gchar **attribute_names,
                          const gchar **attribute_values,
                          gpointer user_data,
                          GError **error);


  void (*end_element) (GMarkupParseContext *context,
                          const gchar *element_name,
                          gpointer user_data,
                          GError **error);



  void (*text) (GMarkupParseContext *context,
                          const gchar *text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);






  void (*passthrough) (GMarkupParseContext *context,
                          const gchar *passthrough_text,
                          gsize text_len,
                          gpointer user_data,
                          GError **error);




  void (*error) (GMarkupParseContext *context,
                          GError *error,
                          gpointer user_data);
};

extern
GMarkupParseContext *g_markup_parse_context_new (const GMarkupParser *parser,
                                                   GMarkupParseFlags flags,
                                                   gpointer user_data,
                                                   GDestroyNotify user_data_dnotify);
extern
GMarkupParseContext *g_markup_parse_context_ref (GMarkupParseContext *context);
extern
void g_markup_parse_context_unref (GMarkupParseContext *context);
extern
void g_markup_parse_context_free (GMarkupParseContext *context);
extern
gboolean g_markup_parse_context_parse (GMarkupParseContext *context,
                                                   const gchar *text,
                                                   gssize text_len,
                                                   GError **error);
extern
void g_markup_parse_context_push (GMarkupParseContext *context,
                                                   const GMarkupParser *parser,
                                                   gpointer user_data);
extern
gpointer g_markup_parse_context_pop (GMarkupParseContext *context);

extern
gboolean g_markup_parse_context_end_parse (GMarkupParseContext *context,
                                                       GError **error);
extern
const gchar * g_markup_parse_context_get_element (GMarkupParseContext *context);
extern
const GSList * g_markup_parse_context_get_element_stack (GMarkupParseContext *context);


extern
void g_markup_parse_context_get_position (GMarkupParseContext *context,
                                                          gint *line_number,
                                                          gint *char_number);
extern
gpointer g_markup_parse_context_get_user_data (GMarkupParseContext *context);


extern
gchar* g_markup_escape_text (const gchar *text,
                             gssize length);

extern
gchar *g_markup_printf_escaped (const char *format,
    ...) __attribute__((__format__ (__printf__, 1, 2)));
extern
gchar *g_markup_vprintf_escaped (const char *format,
     va_list args) __attribute__((__format__ (__printf__, 1, 0)));

typedef enum
{
  G_MARKUP_COLLECT_INVALID,
  G_MARKUP_COLLECT_STRING,
  G_MARKUP_COLLECT_STRDUP,
  G_MARKUP_COLLECT_BOOLEAN,
  G_MARKUP_COLLECT_TRISTATE,

  G_MARKUP_COLLECT_OPTIONAL = (1 << 16)
} GMarkupCollectType;



extern
gboolean g_markup_collect_attributes (const gchar *element_name,
                                        const gchar **attribute_names,
                                        const gchar **attribute_values,
                                        GError **error,
                                        GMarkupCollectType first_type,
                                        const gchar *first_attr,
                                        ...);


# 63 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gmessages.h" 1
# 41 "/usr/include/glib-2.0/glib/gmessages.h"
       
# 42 "/usr/include/glib-2.0/glib/gmessages.h" 3






extern
gsize g_printf_string_upper_bound (const gchar* format,
         va_list args) __attribute__((__format__ (__printf__, 1, 0)));
# 59 "/usr/include/glib-2.0/glib/gmessages.h" 3
typedef enum
{

  G_LOG_FLAG_RECURSION = 1 << 0,
  G_LOG_FLAG_FATAL = 1 << 1,


  G_LOG_LEVEL_ERROR = 1 << 2,
  G_LOG_LEVEL_CRITICAL = 1 << 3,
  G_LOG_LEVEL_WARNING = 1 << 4,
  G_LOG_LEVEL_MESSAGE = 1 << 5,
  G_LOG_LEVEL_INFO = 1 << 6,
  G_LOG_LEVEL_DEBUG = 1 << 7,

  G_LOG_LEVEL_MASK = ~(G_LOG_FLAG_RECURSION | G_LOG_FLAG_FATAL)
} GLogLevelFlags;




typedef void (*GLogFunc) (const gchar *log_domain,
                                                 GLogLevelFlags log_level,
                                                 const gchar *message,
                                                 gpointer user_data);



extern
guint g_log_set_handler (const gchar *log_domain,
                                         GLogLevelFlags log_levels,
                                         GLogFunc log_func,
                                         gpointer user_data);
extern
void g_log_remove_handler (const gchar *log_domain,
                                         guint handler_id);
extern
void g_log_default_handler (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *message,
                                         gpointer unused_data);
extern
GLogFunc g_log_set_default_handler (GLogFunc log_func,
        gpointer user_data);
extern
void g_log (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 3, 4)));
extern
void g_logv (const gchar *log_domain,
                                         GLogLevelFlags log_level,
                                         const gchar *format,
                                         va_list args) __attribute__((__format__ (__printf__, 3, 0)));
extern
GLogLevelFlags g_log_set_fatal_mask (const gchar *log_domain,
                                         GLogLevelFlags fatal_mask);
extern
GLogLevelFlags g_log_set_always_fatal (GLogLevelFlags fatal_mask);


void _g_log_fallback_handler (const gchar *log_domain,
       GLogLevelFlags log_level,
       const gchar *message,
       gpointer unused_data);


extern
void g_return_if_fail_warning (const char *log_domain,
          const char *pretty_function,
          const char *expression);
extern
void g_warn_message (const char *domain,
                               const char *file,
                               int line,
                               const char *func,
                               const char *warnexpr);
__attribute__((__deprecated__)) extern
void g_assert_warning (const char *log_domain,
          const char *file,
          const int line,
                 const char *pretty_function,
                 const char *expression) __attribute__((__noreturn__));
# 246 "/usr/include/glib-2.0/glib/gmessages.h" 3
typedef void (*GPrintFunc) (const gchar *string);
extern
void g_print (const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 1, 2)));
extern
GPrintFunc g_set_print_handler (GPrintFunc func);
extern
void g_printerr (const gchar *format,
                                         ...) __attribute__((__format__ (__printf__, 1, 2)));
extern
GPrintFunc g_set_printerr_handler (GPrintFunc func);
# 417 "/usr/include/glib-2.0/glib/gmessages.h" 3

# 65 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/goption.h" 1
# 31 "/usr/include/glib-2.0/glib/goption.h"

# 40 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionContext GOptionContext;
# 53 "/usr/include/glib-2.0/glib/goption.h"
typedef struct _GOptionGroup GOptionGroup;
typedef struct _GOptionEntry GOptionEntry;
# 82 "/usr/include/glib-2.0/glib/goption.h"
typedef enum
{
  G_OPTION_FLAG_HIDDEN = 1 << 0,
  G_OPTION_FLAG_IN_MAIN = 1 << 1,
  G_OPTION_FLAG_REVERSE = 1 << 2,
  G_OPTION_FLAG_NO_ARG = 1 << 3,
  G_OPTION_FLAG_FILENAME = 1 << 4,
  G_OPTION_FLAG_OPTIONAL_ARG = 1 << 5,
  G_OPTION_FLAG_NOALIAS = 1 << 6
} GOptionFlags;
# 118 "/usr/include/glib-2.0/glib/goption.h"
typedef enum
{
  G_OPTION_ARG_NONE,
  G_OPTION_ARG_STRING,
  G_OPTION_ARG_INT,
  G_OPTION_ARG_CALLBACK,
  G_OPTION_ARG_FILENAME,
  G_OPTION_ARG_STRING_ARRAY,
  G_OPTION_ARG_FILENAME_ARRAY,
  G_OPTION_ARG_DOUBLE,
  G_OPTION_ARG_INT64
} GOptionArg;
# 148 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionArgFunc) (const gchar *option_name,
        const gchar *value,
        gpointer data,
        GError **error);
# 166 "/usr/include/glib-2.0/glib/goption.h"
typedef gboolean (*GOptionParseFunc) (GOptionContext *context,
          GOptionGroup *group,
          gpointer data,
          GError **error);
# 181 "/usr/include/glib-2.0/glib/goption.h"
typedef void (*GOptionErrorFunc) (GOptionContext *context,
      GOptionGroup *group,
      gpointer data,
      GError **error);
# 205 "/usr/include/glib-2.0/glib/goption.h"
typedef enum
{
  G_OPTION_ERROR_UNKNOWN_OPTION,
  G_OPTION_ERROR_BAD_VALUE,
  G_OPTION_ERROR_FAILED
} GOptionError;

extern
GQuark g_option_error_quark (void);
# 280 "/usr/include/glib-2.0/glib/goption.h"
struct _GOptionEntry
{
  const gchar *long_name;
  gchar short_name;
  gint flags;

  GOptionArg arg;
  gpointer arg_data;

  const gchar *description;
  const gchar *arg_description;
};
# 311 "/usr/include/glib-2.0/glib/goption.h"
extern
GOptionContext *g_option_context_new (const gchar *parameter_string);
extern
void g_option_context_set_summary (GOptionContext *context,
                                                   const gchar *summary);
extern
const gchar * g_option_context_get_summary (GOptionContext *context);
extern
void g_option_context_set_description (GOptionContext *context,
                                                   const gchar *description);
extern
const gchar * g_option_context_get_description (GOptionContext *context);
extern
void g_option_context_free (GOptionContext *context);
extern
void g_option_context_set_help_enabled (GOptionContext *context,
         gboolean help_enabled);
extern
gboolean g_option_context_get_help_enabled (GOptionContext *context);
extern
void g_option_context_set_ignore_unknown_options (GOptionContext *context,
            gboolean ignore_unknown);
extern
gboolean g_option_context_get_ignore_unknown_options (GOptionContext *context);

extern
void g_option_context_add_main_entries (GOptionContext *context,
         const GOptionEntry *entries,
         const gchar *translation_domain);
extern
gboolean g_option_context_parse (GOptionContext *context,
         gint *argc,
         gchar ***argv,
         GError **error);
extern
void g_option_context_set_translate_func (GOptionContext *context,
           GTranslateFunc func,
           gpointer data,
           GDestroyNotify destroy_notify);
extern
void g_option_context_set_translation_domain (GOptionContext *context,
        const gchar *domain);

extern
void g_option_context_add_group (GOptionContext *context,
       GOptionGroup *group);
extern
void g_option_context_set_main_group (GOptionContext *context,
            GOptionGroup *group);
extern
GOptionGroup *g_option_context_get_main_group (GOptionContext *context);
extern
gchar *g_option_context_get_help (GOptionContext *context,
                                               gboolean main_help,
                                               GOptionGroup *group);

extern
GOptionGroup *g_option_group_new (const gchar *name,
           const gchar *description,
           const gchar *help_description,
           gpointer user_data,
           GDestroyNotify destroy);
extern
void g_option_group_set_parse_hooks (GOptionGroup *group,
           GOptionParseFunc pre_parse_func,
           GOptionParseFunc post_parse_func);
extern
void g_option_group_set_error_hook (GOptionGroup *group,
           GOptionErrorFunc error_func);
extern
void g_option_group_free (GOptionGroup *group);
extern
void g_option_group_add_entries (GOptionGroup *group,
           const GOptionEntry *entries);
extern
void g_option_group_set_translate_func (GOptionGroup *group,
           GTranslateFunc func,
           gpointer data,
           GDestroyNotify destroy_notify);
extern
void g_option_group_set_translation_domain (GOptionGroup *group,
           const gchar *domain);


# 67 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gpattern.h" 1
# 29 "/usr/include/glib-2.0/glib/gpattern.h"



typedef struct _GPatternSpec GPatternSpec;

extern
GPatternSpec* g_pattern_spec_new (const gchar *pattern);
extern
void g_pattern_spec_free (GPatternSpec *pspec);
extern
gboolean g_pattern_spec_equal (GPatternSpec *pspec1,
     GPatternSpec *pspec2);
extern
gboolean g_pattern_match (GPatternSpec *pspec,
     guint string_length,
     const gchar *string,
     const gchar *string_reversed);
extern
gboolean g_pattern_match_string (GPatternSpec *pspec,
     const gchar *string);
extern
gboolean g_pattern_match_simple (const gchar *pattern,
     const gchar *string);


# 68 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gprimes.h" 1
# 36 "/usr/include/glib-2.0/glib/gprimes.h"

# 47 "/usr/include/glib-2.0/glib/gprimes.h"
extern
guint g_spaced_primes_closest (guint num) __attribute__((__const__));


# 70 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gqsort.h" 1
# 36 "/usr/include/glib-2.0/glib/gqsort.h"


extern
void g_qsort_with_data (gconstpointer pbase,
   gint total_elems,
   gsize size,
   GCompareDataFunc compare_func,
   gpointer user_data);


# 71 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gqueue.h" 1
# 36 "/usr/include/glib-2.0/glib/gqueue.h"


typedef struct _GQueue GQueue;
# 49 "/usr/include/glib-2.0/glib/gqueue.h"
struct _GQueue
{
  GList *head;
  GList *tail;
  guint length;
};
# 74 "/usr/include/glib-2.0/glib/gqueue.h"
extern
GQueue* g_queue_new (void);
extern
void g_queue_free (GQueue *queue);
extern
void g_queue_free_full (GQueue *queue,
    GDestroyNotify free_func);
extern
void g_queue_init (GQueue *queue);
extern
void g_queue_clear (GQueue *queue);
extern
gboolean g_queue_is_empty (GQueue *queue);
extern
guint g_queue_get_length (GQueue *queue);
extern
void g_queue_reverse (GQueue *queue);
extern
GQueue * g_queue_copy (GQueue *queue);
extern
void g_queue_foreach (GQueue *queue,
                                 GFunc func,
                                 gpointer user_data);
extern
GList * g_queue_find (GQueue *queue,
                                 gconstpointer data);
extern
GList * g_queue_find_custom (GQueue *queue,
                                 gconstpointer data,
                                 GCompareFunc func);
extern
void g_queue_sort (GQueue *queue,
                                 GCompareDataFunc compare_func,
                                 gpointer user_data);

extern
void g_queue_push_head (GQueue *queue,
                                 gpointer data);
extern
void g_queue_push_tail (GQueue *queue,
                                 gpointer data);
extern
void g_queue_push_nth (GQueue *queue,
                                 gpointer data,
                                 gint n);
extern
gpointer g_queue_pop_head (GQueue *queue);
extern
gpointer g_queue_pop_tail (GQueue *queue);
extern
gpointer g_queue_pop_nth (GQueue *queue,
                                 guint n);
extern
gpointer g_queue_peek_head (GQueue *queue);
extern
gpointer g_queue_peek_tail (GQueue *queue);
extern
gpointer g_queue_peek_nth (GQueue *queue,
                                 guint n);
extern
gint g_queue_index (GQueue *queue,
                                 gconstpointer data);
extern
gboolean g_queue_remove (GQueue *queue,
                                 gconstpointer data);
extern
guint g_queue_remove_all (GQueue *queue,
                                 gconstpointer data);
extern
void g_queue_insert_before (GQueue *queue,
                                 GList *sibling,
                                 gpointer data);
extern
void g_queue_insert_after (GQueue *queue,
                                 GList *sibling,
                                 gpointer data);
extern
void g_queue_insert_sorted (GQueue *queue,
                                 gpointer data,
                                 GCompareDataFunc func,
                                 gpointer user_data);

extern
void g_queue_push_head_link (GQueue *queue,
                                 GList *link_);
extern
void g_queue_push_tail_link (GQueue *queue,
                                 GList *link_);
extern
void g_queue_push_nth_link (GQueue *queue,
                                 gint n,
                                 GList *link_);
extern
GList* g_queue_pop_head_link (GQueue *queue);
extern
GList* g_queue_pop_tail_link (GQueue *queue);
extern
GList* g_queue_pop_nth_link (GQueue *queue,
                                 guint n);
extern
GList* g_queue_peek_head_link (GQueue *queue);
extern
GList* g_queue_peek_tail_link (GQueue *queue);
extern
GList* g_queue_peek_nth_link (GQueue *queue,
                                 guint n);
extern
gint g_queue_link_index (GQueue *queue,
                                 GList *link_);
extern
void g_queue_unlink (GQueue *queue,
                                 GList *link_);
extern
void g_queue_delete_link (GQueue *queue,
                                 GList *link_);


# 73 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/grand.h" 1
# 36 "/usr/include/glib-2.0/glib/grand.h"


typedef struct _GRand GRand;
# 49 "/usr/include/glib-2.0/glib/grand.h"
extern
GRand* g_rand_new_with_seed (guint32 seed);
extern
GRand* g_rand_new_with_seed_array (const guint32 *seed,
        guint seed_length);
extern
GRand* g_rand_new (void);
extern
void g_rand_free (GRand *rand_);
extern
GRand* g_rand_copy (GRand *rand_);
extern
void g_rand_set_seed (GRand *rand_,
          guint32 seed);
extern
void g_rand_set_seed_array (GRand *rand_,
          const guint32 *seed,
          guint seed_length);



extern
guint32 g_rand_int (GRand *rand_);
extern
gint32 g_rand_int_range (GRand *rand_,
          gint32 begin,
          gint32 end);
extern
gdouble g_rand_double (GRand *rand_);
extern
gdouble g_rand_double_range (GRand *rand_,
          gdouble begin,
          gdouble end);
extern
void g_random_set_seed (guint32 seed);



extern
guint32 g_random_int (void);
extern
gint32 g_random_int_range (gint32 begin,
          gint32 end);
extern
gdouble g_random_double (void);
extern
gdouble g_random_double_range (gdouble begin,
          gdouble end);



# 74 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gregex.h" 1
# 32 "/usr/include/glib-2.0/glib/gregex.h"

# 141 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum
{
  G_REGEX_ERROR_COMPILE,
  G_REGEX_ERROR_OPTIMIZE,
  G_REGEX_ERROR_REPLACE,
  G_REGEX_ERROR_MATCH,
  G_REGEX_ERROR_INTERNAL,


  G_REGEX_ERROR_STRAY_BACKSLASH = 101,
  G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
  G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
  G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
  G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
  G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
  G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
  G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
  G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
  G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
  G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
  G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
  G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
  G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
  G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
  G_REGEX_ERROR_MEMORY_ERROR = 121,
  G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
  G_REGEX_ERROR_MALFORMED_CONDITION = 126,
  G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
  G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
  G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
  G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
  G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
  G_REGEX_ERROR_INVALID_CONDITION = 135,
  G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
  G_REGEX_ERROR_INFINITE_LOOP = 140,
  G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
  G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
  G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
  G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
  G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
  G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
  G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
  G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
  G_REGEX_ERROR_DEFINE_REPETION = 155,
  G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
  G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
  G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
  G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
  G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
  G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
  G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
  G_REGEX_ERROR_MISSING_DIGIT = 163,
  G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
  G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
  G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
  G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
  G_REGEX_ERROR_MISSING_NAME = 169,
  G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
  G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
  G_REGEX_ERROR_NAME_TOO_LONG = 175,
  G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176
} GRegexError;
# 215 "/usr/include/glib-2.0/glib/gregex.h"
extern
GQuark g_regex_error_quark (void);
# 296 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum
{
  G_REGEX_CASELESS = 1 << 0,
  G_REGEX_MULTILINE = 1 << 1,
  G_REGEX_DOTALL = 1 << 2,
  G_REGEX_EXTENDED = 1 << 3,
  G_REGEX_ANCHORED = 1 << 4,
  G_REGEX_DOLLAR_ENDONLY = 1 << 5,
  G_REGEX_UNGREEDY = 1 << 9,
  G_REGEX_RAW = 1 << 11,
  G_REGEX_NO_AUTO_CAPTURE = 1 << 12,
  G_REGEX_OPTIMIZE = 1 << 13,
  G_REGEX_FIRSTLINE = 1 << 18,
  G_REGEX_DUPNAMES = 1 << 19,
  G_REGEX_NEWLINE_CR = 1 << 20,
  G_REGEX_NEWLINE_LF = 1 << 21,
  G_REGEX_NEWLINE_CRLF = G_REGEX_NEWLINE_CR | G_REGEX_NEWLINE_LF,
  G_REGEX_NEWLINE_ANYCRLF = G_REGEX_NEWLINE_CR | 1 << 22,
  G_REGEX_BSR_ANYCRLF = 1 << 23,
  G_REGEX_JAVASCRIPT_COMPAT = 1 << 25
} GRegexCompileFlags;
# 386 "/usr/include/glib-2.0/glib/gregex.h"
typedef enum
{
  G_REGEX_MATCH_ANCHORED = 1 << 4,
  G_REGEX_MATCH_NOTBOL = 1 << 7,
  G_REGEX_MATCH_NOTEOL = 1 << 8,
  G_REGEX_MATCH_NOTEMPTY = 1 << 10,
  G_REGEX_MATCH_PARTIAL = 1 << 15,
  G_REGEX_MATCH_NEWLINE_CR = 1 << 20,
  G_REGEX_MATCH_NEWLINE_LF = 1 << 21,
  G_REGEX_MATCH_NEWLINE_CRLF = G_REGEX_MATCH_NEWLINE_CR | G_REGEX_MATCH_NEWLINE_LF,
  G_REGEX_MATCH_NEWLINE_ANY = 1 << 22,
  G_REGEX_MATCH_NEWLINE_ANYCRLF = G_REGEX_MATCH_NEWLINE_CR | G_REGEX_MATCH_NEWLINE_ANY,
  G_REGEX_MATCH_BSR_ANYCRLF = 1 << 23,
  G_REGEX_MATCH_BSR_ANY = 1 << 24,
  G_REGEX_MATCH_PARTIAL_SOFT = G_REGEX_MATCH_PARTIAL,
  G_REGEX_MATCH_PARTIAL_HARD = 1 << 27,
  G_REGEX_MATCH_NOTEMPTY_ATSTART = 1 << 28
} GRegexMatchFlags;
# 413 "/usr/include/glib-2.0/glib/gregex.h"
typedef struct _GRegex GRegex;


typedef struct _GMatchInfo GMatchInfo;
# 435 "/usr/include/glib-2.0/glib/gregex.h"
typedef gboolean (*GRegexEvalCallback) (const GMatchInfo *match_info,
       GString *result,
       gpointer user_data);


extern
GRegex *g_regex_new (const gchar *pattern,
       GRegexCompileFlags compile_options,
       GRegexMatchFlags match_options,
       GError **error);
extern
GRegex *g_regex_ref (GRegex *regex);
extern
void g_regex_unref (GRegex *regex);
extern
const gchar *g_regex_get_pattern (const GRegex *regex);
extern
gint g_regex_get_max_backref (const GRegex *regex);
extern
gint g_regex_get_capture_count (const GRegex *regex);
extern
gboolean g_regex_get_has_cr_or_lf (const GRegex *regex);
extern
gint g_regex_get_string_number (const GRegex *regex,
       const gchar *name);
extern
gchar *g_regex_escape_string (const gchar *string,
       gint length);
extern
gchar *g_regex_escape_nul (const gchar *string,
       gint length);

extern
GRegexCompileFlags g_regex_get_compile_flags (const GRegex *regex);
extern
GRegexMatchFlags g_regex_get_match_flags (const GRegex *regex);


extern
gboolean g_regex_match_simple (const gchar *pattern,
       const gchar *string,
       GRegexCompileFlags compile_options,
       GRegexMatchFlags match_options);
extern
gboolean g_regex_match (const GRegex *regex,
       const gchar *string,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info);
extern
gboolean g_regex_match_full (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info,
       GError **error);
extern
gboolean g_regex_match_all (const GRegex *regex,
       const gchar *string,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info);
extern
gboolean g_regex_match_all_full (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       GMatchInfo **match_info,
       GError **error);


extern
gchar **g_regex_split_simple (const gchar *pattern,
       const gchar *string,
       GRegexCompileFlags compile_options,
       GRegexMatchFlags match_options);
extern
gchar **g_regex_split (const GRegex *regex,
       const gchar *string,
       GRegexMatchFlags match_options);
extern
gchar **g_regex_split_full (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       gint max_tokens,
       GError **error);


extern
gchar *g_regex_replace (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       const gchar *replacement,
       GRegexMatchFlags match_options,
       GError **error);
extern
gchar *g_regex_replace_literal (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       const gchar *replacement,
       GRegexMatchFlags match_options,
       GError **error);
extern
gchar *g_regex_replace_eval (const GRegex *regex,
       const gchar *string,
       gssize string_len,
       gint start_position,
       GRegexMatchFlags match_options,
       GRegexEvalCallback eval,
       gpointer user_data,
       GError **error);
extern
gboolean g_regex_check_replacement (const gchar *replacement,
       gboolean *has_references,
       GError **error);


extern
GRegex *g_match_info_get_regex (const GMatchInfo *match_info);
extern
const gchar *g_match_info_get_string (const GMatchInfo *match_info);

extern
GMatchInfo *g_match_info_ref (GMatchInfo *match_info);
extern
void g_match_info_unref (GMatchInfo *match_info);
extern
void g_match_info_free (GMatchInfo *match_info);
extern
gboolean g_match_info_next (GMatchInfo *match_info,
       GError **error);
extern
gboolean g_match_info_matches (const GMatchInfo *match_info);
extern
gint g_match_info_get_match_count (const GMatchInfo *match_info);
extern
gboolean g_match_info_is_partial_match (const GMatchInfo *match_info);
extern
gchar *g_match_info_expand_references(const GMatchInfo *match_info,
       const gchar *string_to_expand,
       GError **error);
extern
gchar *g_match_info_fetch (const GMatchInfo *match_info,
       gint match_num);
extern
gboolean g_match_info_fetch_pos (const GMatchInfo *match_info,
       gint match_num,
       gint *start_pos,
       gint *end_pos);
extern
gchar *g_match_info_fetch_named (const GMatchInfo *match_info,
       const gchar *name);
extern
gboolean g_match_info_fetch_named_pos (const GMatchInfo *match_info,
       const gchar *name,
       gint *start_pos,
       gint *end_pos);
extern
gchar **g_match_info_fetch_all (const GMatchInfo *match_info);


# 75 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gscanner.h" 1
# 37 "/usr/include/glib-2.0/glib/gscanner.h"


typedef struct _GScanner GScanner;
typedef struct _GScannerConfig GScannerConfig;
typedef union _GTokenValue GTokenValue;

typedef void (*GScannerMsgFunc) (GScanner *scanner,
       gchar *message,
       gboolean error);
# 64 "/usr/include/glib-2.0/glib/gscanner.h"
typedef enum
{
  G_ERR_UNKNOWN,
  G_ERR_UNEXP_EOF,
  G_ERR_UNEXP_EOF_IN_STRING,
  G_ERR_UNEXP_EOF_IN_COMMENT,
  G_ERR_NON_DIGIT_IN_CONST,
  G_ERR_DIGIT_RADIX,
  G_ERR_FLOAT_RADIX,
  G_ERR_FLOAT_MALFORMED
} GErrorType;


typedef enum
{
  G_TOKEN_EOF = 0,

  G_TOKEN_LEFT_PAREN = '(',
  G_TOKEN_RIGHT_PAREN = ')',
  G_TOKEN_LEFT_CURLY = '{',
  G_TOKEN_RIGHT_CURLY = '}',
  G_TOKEN_LEFT_BRACE = '[',
  G_TOKEN_RIGHT_BRACE = ']',
  G_TOKEN_EQUAL_SIGN = '=',
  G_TOKEN_COMMA = ',',

  G_TOKEN_NONE = 256,

  G_TOKEN_ERROR,

  G_TOKEN_CHAR,
  G_TOKEN_BINARY,
  G_TOKEN_OCTAL,
  G_TOKEN_INT,
  G_TOKEN_HEX,
  G_TOKEN_FLOAT,
  G_TOKEN_STRING,

  G_TOKEN_SYMBOL,
  G_TOKEN_IDENTIFIER,
  G_TOKEN_IDENTIFIER_NULL,

  G_TOKEN_COMMENT_SINGLE,
  G_TOKEN_COMMENT_MULTI,


  G_TOKEN_LAST
} GTokenType;

union _GTokenValue
{
  gpointer v_symbol;
  gchar *v_identifier;
  gulong v_binary;
  gulong v_octal;
  gulong v_int;
  guint64 v_int64;
  gdouble v_float;
  gulong v_hex;
  gchar *v_string;
  gchar *v_comment;
  guchar v_char;
  guint v_error;
};

struct _GScannerConfig
{


  gchar *cset_skip_characters;
  gchar *cset_identifier_first;
  gchar *cset_identifier_nth;
  gchar *cpair_comment_single;



  guint case_sensitive : 1;




  guint skip_comment_multi : 1;
  guint skip_comment_single : 1;
  guint scan_comment_multi : 1;
  guint scan_identifier : 1;
  guint scan_identifier_1char : 1;
  guint scan_identifier_NULL : 1;
  guint scan_symbols : 1;
  guint scan_binary : 1;
  guint scan_octal : 1;
  guint scan_float : 1;
  guint scan_hex : 1;
  guint scan_hex_dollar : 1;
  guint scan_string_sq : 1;
  guint scan_string_dq : 1;
  guint numbers_2_int : 1;
  guint int_2_float : 1;
  guint identifier_2_string : 1;
  guint char_2_token : 1;
  guint symbol_2_token : 1;
  guint scope_0_fallback : 1;
  guint store_int64 : 1;


  guint padding_dummy;
};

struct _GScanner
{

  gpointer user_data;
  guint max_parse_errors;


  guint parse_errors;


  const gchar *input_name;


  GData *qdata;


  GScannerConfig *config;


  GTokenType token;
  GTokenValue value;
  guint line;
  guint position;


  GTokenType next_token;
  GTokenValue next_value;
  guint next_line;
  guint next_position;



  GHashTable *symbol_table;
  gint input_fd;
  const gchar *text;
  const gchar *text_end;
  gchar *buffer;
  guint scope_id;



  GScannerMsgFunc msg_handler;
};

extern
GScanner* g_scanner_new (const GScannerConfig *config_templ);
extern
void g_scanner_destroy (GScanner *scanner);
extern
void g_scanner_input_file (GScanner *scanner,
       gint input_fd);
extern
void g_scanner_sync_file_offset (GScanner *scanner);
extern
void g_scanner_input_text (GScanner *scanner,
       const gchar *text,
       guint text_len);
extern
GTokenType g_scanner_get_next_token (GScanner *scanner);
extern
GTokenType g_scanner_peek_next_token (GScanner *scanner);
extern
GTokenType g_scanner_cur_token (GScanner *scanner);
extern
GTokenValue g_scanner_cur_value (GScanner *scanner);
extern
guint g_scanner_cur_line (GScanner *scanner);
extern
guint g_scanner_cur_position (GScanner *scanner);
extern
gboolean g_scanner_eof (GScanner *scanner);
extern
guint g_scanner_set_scope (GScanner *scanner,
       guint scope_id);
extern
void g_scanner_scope_add_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol,
       gpointer value);
extern
void g_scanner_scope_remove_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol);
extern
gpointer g_scanner_scope_lookup_symbol (GScanner *scanner,
       guint scope_id,
       const gchar *symbol);
extern
void g_scanner_scope_foreach_symbol (GScanner *scanner,
       guint scope_id,
       GHFunc func,
       gpointer user_data);
extern
gpointer g_scanner_lookup_symbol (GScanner *scanner,
       const gchar *symbol);
extern
void g_scanner_unexp_token (GScanner *scanner,
       GTokenType expected_token,
       const gchar *identifier_spec,
       const gchar *symbol_spec,
       const gchar *symbol_name,
       const gchar *message,
       gint is_error);
extern
void g_scanner_error (GScanner *scanner,
       const gchar *format,
       ...) __attribute__((__format__ (__printf__, 2, 3)));
extern
void g_scanner_warn (GScanner *scanner,
       const gchar *format,
       ...) __attribute__((__format__ (__printf__, 2, 3)));
# 303 "/usr/include/glib-2.0/glib/gscanner.h"

# 76 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gsequence.h" 1
# 30 "/usr/include/glib-2.0/glib/gsequence.h"


typedef struct _GSequence GSequence;
typedef struct _GSequenceNode GSequenceIter;

typedef gint (* GSequenceIterCompareFunc) (GSequenceIter *a,
                                           GSequenceIter *b,
                                           gpointer data);



extern
GSequence * g_sequence_new (GDestroyNotify data_destroy);
extern
void g_sequence_free (GSequence *seq);
extern
gint g_sequence_get_length (GSequence *seq);
extern
void g_sequence_foreach (GSequence *seq,
                                              GFunc func,
                                              gpointer user_data);
extern
void g_sequence_foreach_range (GSequenceIter *begin,
                                              GSequenceIter *end,
                                              GFunc func,
                                              gpointer user_data);
extern
void g_sequence_sort (GSequence *seq,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
extern
void g_sequence_sort_iter (GSequence *seq,
                                              GSequenceIterCompareFunc cmp_func,
                                              gpointer cmp_data);



extern
GSequenceIter *g_sequence_get_begin_iter (GSequence *seq);
extern
GSequenceIter *g_sequence_get_end_iter (GSequence *seq);
extern
GSequenceIter *g_sequence_get_iter_at_pos (GSequence *seq,
                                              gint pos);
extern
GSequenceIter *g_sequence_append (GSequence *seq,
                                              gpointer data);
extern
GSequenceIter *g_sequence_prepend (GSequence *seq,
                                              gpointer data);
extern
GSequenceIter *g_sequence_insert_before (GSequenceIter *iter,
                                              gpointer data);
extern
void g_sequence_move (GSequenceIter *src,
                                              GSequenceIter *dest);
extern
void g_sequence_swap (GSequenceIter *a,
                                              GSequenceIter *b);
extern
GSequenceIter *g_sequence_insert_sorted (GSequence *seq,
                                              gpointer data,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
extern
GSequenceIter *g_sequence_insert_sorted_iter (GSequence *seq,
                                              gpointer data,
                                              GSequenceIterCompareFunc iter_cmp,
                                              gpointer cmp_data);
extern
void g_sequence_sort_changed (GSequenceIter *iter,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
extern
void g_sequence_sort_changed_iter (GSequenceIter *iter,
                                              GSequenceIterCompareFunc iter_cmp,
                                              gpointer cmp_data);
extern
void g_sequence_remove (GSequenceIter *iter);
extern
void g_sequence_remove_range (GSequenceIter *begin,
                                              GSequenceIter *end);
extern
void g_sequence_move_range (GSequenceIter *dest,
                                              GSequenceIter *begin,
                                              GSequenceIter *end);
extern
GSequenceIter *g_sequence_search (GSequence *seq,
                                              gpointer data,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
extern
GSequenceIter *g_sequence_search_iter (GSequence *seq,
                                              gpointer data,
                                              GSequenceIterCompareFunc iter_cmp,
                                              gpointer cmp_data);
extern
GSequenceIter *g_sequence_lookup (GSequence *seq,
                                              gpointer data,
                                              GCompareDataFunc cmp_func,
                                              gpointer cmp_data);
extern
GSequenceIter *g_sequence_lookup_iter (GSequence *seq,
                                              gpointer data,
                                              GSequenceIterCompareFunc iter_cmp,
                                              gpointer cmp_data);



extern
gpointer g_sequence_get (GSequenceIter *iter);
extern
void g_sequence_set (GSequenceIter *iter,
                                              gpointer data);


extern
gboolean g_sequence_iter_is_begin (GSequenceIter *iter);
extern
gboolean g_sequence_iter_is_end (GSequenceIter *iter);
extern
GSequenceIter *g_sequence_iter_next (GSequenceIter *iter);
extern
GSequenceIter *g_sequence_iter_prev (GSequenceIter *iter);
extern
gint g_sequence_iter_get_position (GSequenceIter *iter);
extern
GSequenceIter *g_sequence_iter_move (GSequenceIter *iter,
                                              gint delta);
extern
GSequence * g_sequence_iter_get_sequence (GSequenceIter *iter);



extern
gint g_sequence_iter_compare (GSequenceIter *a,
                                              GSequenceIter *b);
extern
GSequenceIter *g_sequence_range_get_midpoint (GSequenceIter *begin,
                                              GSequenceIter *end);


# 77 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gshell.h" 1
# 30 "/usr/include/glib-2.0/glib/gshell.h"




typedef enum
{

  G_SHELL_ERROR_BAD_QUOTING,

  G_SHELL_ERROR_EMPTY_STRING,
  G_SHELL_ERROR_FAILED
} GShellError;

extern
GQuark g_shell_error_quark (void);

extern
gchar* g_shell_quote (const gchar *unquoted_string);
extern
gchar* g_shell_unquote (const gchar *quoted_string,
                             GError **error);
extern
gboolean g_shell_parse_argv (const gchar *command_line,
                             gint *argcp,
                             gchar ***argvp,
                             GError **error);


# 78 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gslice.h" 1
# 29 "/usr/include/glib-2.0/glib/gslice.h"




extern
gpointer g_slice_alloc (gsize block_size) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern
gpointer g_slice_alloc0 (gsize block_size) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern
gpointer g_slice_copy (gsize block_size,
                                         gconstpointer mem_block) __attribute__((__malloc__)) __attribute__((__alloc_size__(1)));
extern
void g_slice_free1 (gsize block_size,
      gpointer mem_block);
extern
void g_slice_free_chain_with_offset (gsize block_size,
      gpointer mem_chain,
      gsize next_offset);
# 77 "/usr/include/glib-2.0/glib/gslice.h"
typedef enum {
  G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
  G_SLICE_CONFIG_BYPASS_MAGAZINES,
  G_SLICE_CONFIG_WORKING_SET_MSECS,
  G_SLICE_CONFIG_COLOR_INCREMENT,
  G_SLICE_CONFIG_CHUNK_SIZES,
  G_SLICE_CONFIG_CONTENTION_COUNTER
} GSliceConfig;

__attribute__((__deprecated__)) extern
void g_slice_set_config (GSliceConfig ckey, gint64 value);
__attribute__((__deprecated__)) extern
gint64 g_slice_get_config (GSliceConfig ckey);
__attribute__((__deprecated__)) extern
gint64* g_slice_get_config_state (GSliceConfig ckey, gint64 address, guint *n_values);







# 79 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gspawn.h" 1
# 30 "/usr/include/glib-2.0/glib/gspawn.h"

# 70 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum
{
  G_SPAWN_ERROR_FORK,
  G_SPAWN_ERROR_READ,
  G_SPAWN_ERROR_CHDIR,
  G_SPAWN_ERROR_ACCES,
  G_SPAWN_ERROR_PERM,
  G_SPAWN_ERROR_TOO_BIG,

  G_SPAWN_ERROR_2BIG = G_SPAWN_ERROR_TOO_BIG,

  G_SPAWN_ERROR_NOEXEC,
  G_SPAWN_ERROR_NAMETOOLONG,
  G_SPAWN_ERROR_NOENT,
  G_SPAWN_ERROR_NOMEM,
  G_SPAWN_ERROR_NOTDIR,
  G_SPAWN_ERROR_LOOP,
  G_SPAWN_ERROR_TXTBUSY,
  G_SPAWN_ERROR_IO,
  G_SPAWN_ERROR_NFILE,
  G_SPAWN_ERROR_MFILE,
  G_SPAWN_ERROR_INVAL,
  G_SPAWN_ERROR_ISDIR,
  G_SPAWN_ERROR_LIBBAD,
  G_SPAWN_ERROR_FAILED


} GSpawnError;
# 143 "/usr/include/glib-2.0/glib/gspawn.h"
typedef void (* GSpawnChildSetupFunc) (gpointer user_data);
# 172 "/usr/include/glib-2.0/glib/gspawn.h"
typedef enum
{
  G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1 << 0,
  G_SPAWN_DO_NOT_REAP_CHILD = 1 << 1,

  G_SPAWN_SEARCH_PATH = 1 << 2,

  G_SPAWN_STDOUT_TO_DEV_NULL = 1 << 3,
  G_SPAWN_STDERR_TO_DEV_NULL = 1 << 4,
  G_SPAWN_CHILD_INHERITS_STDIN = 1 << 5,
  G_SPAWN_FILE_AND_ARGV_ZERO = 1 << 6,
  G_SPAWN_SEARCH_PATH_FROM_ENVP = 1 << 7
} GSpawnFlags;

extern
GQuark g_spawn_error_quark (void);
extern
GQuark g_spawn_exit_error_quark (void);

extern
gboolean g_spawn_async (const gchar *working_directory,
                        gchar **argv,
                        gchar **envp,
                        GSpawnFlags flags,
                        GSpawnChildSetupFunc child_setup,
                        gpointer user_data,
                        GPid *child_pid,
                        GError **error);





extern
gboolean g_spawn_async_with_pipes (const gchar *working_directory,
                                   gchar **argv,
                                   gchar **envp,
                                   GSpawnFlags flags,
                                   GSpawnChildSetupFunc child_setup,
                                   gpointer user_data,
                                   GPid *child_pid,
                                   gint *standard_input,
                                   gint *standard_output,
                                   gint *standard_error,
                                   GError **error);






extern
gboolean g_spawn_sync (const gchar *working_directory,
                               gchar **argv,
                               gchar **envp,
                               GSpawnFlags flags,
                               GSpawnChildSetupFunc child_setup,
                               gpointer user_data,
                               gchar **standard_output,
                               gchar **standard_error,
                               gint *exit_status,
                               GError **error);

extern
gboolean g_spawn_command_line_sync (const gchar *command_line,
                                     gchar **standard_output,
                                     gchar **standard_error,
                                     gint *exit_status,
                                     GError **error);
extern
gboolean g_spawn_command_line_async (const gchar *command_line,
                                     GError **error);

extern
gboolean g_spawn_check_exit_status (gint exit_status,
        GError **error);

extern
void g_spawn_close_pid (GPid pid);
# 303 "/usr/include/glib-2.0/glib/gspawn.h"

# 81 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gstrfuncs.h" 1
# 38 "/usr/include/glib-2.0/glib/gstrfuncs.h"



typedef enum {
  G_ASCII_ALNUM = 1 << 0,
  G_ASCII_ALPHA = 1 << 1,
  G_ASCII_CNTRL = 1 << 2,
  G_ASCII_DIGIT = 1 << 3,
  G_ASCII_GRAPH = 1 << 4,
  G_ASCII_LOWER = 1 << 5,
  G_ASCII_PRINT = 1 << 6,
  G_ASCII_PUNCT = 1 << 7,
  G_ASCII_SPACE = 1 << 8,
  G_ASCII_UPPER = 1 << 9,
  G_ASCII_XDIGIT = 1 << 10
} GAsciiType;

extern const guint16 * const g_ascii_table;
# 90 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern
gchar g_ascii_tolower (gchar c) __attribute__((__const__));
extern
gchar g_ascii_toupper (gchar c) __attribute__((__const__));

extern
gint g_ascii_digit_value (gchar c) __attribute__((__const__));
extern
gint g_ascii_xdigit_value (gchar c) __attribute__((__const__));





extern
gchar* g_strdelimit (gchar *string,
     const gchar *delimiters,
     gchar new_delimiter);
extern
gchar* g_strcanon (gchar *string,
     const gchar *valid_chars,
     gchar substitutor);
extern
const gchar * g_strerror (gint errnum) __attribute__((__const__));
extern
const gchar * g_strsignal (gint signum) __attribute__((__const__));
extern
gchar * g_strreverse (gchar *string);
extern
gsize g_strlcpy (gchar *dest,
     const gchar *src,
     gsize dest_size);
extern
gsize g_strlcat (gchar *dest,
     const gchar *src,
     gsize dest_size);
extern
gchar * g_strstr_len (const gchar *haystack,
     gssize haystack_len,
     const gchar *needle);
extern
gchar * g_strrstr (const gchar *haystack,
     const gchar *needle);
extern
gchar * g_strrstr_len (const gchar *haystack,
     gssize haystack_len,
     const gchar *needle);

extern
gboolean g_str_has_suffix (const gchar *str,
     const gchar *suffix);
extern
gboolean g_str_has_prefix (const gchar *str,
     const gchar *prefix);



extern
gdouble g_strtod (const gchar *nptr,
     gchar **endptr);
extern
gdouble g_ascii_strtod (const gchar *nptr,
     gchar **endptr);
extern
guint64 g_ascii_strtoull (const gchar *nptr,
     gchar **endptr,
     guint base);
extern
gint64 g_ascii_strtoll (const gchar *nptr,
     gchar **endptr,
     guint base);




extern
gchar * g_ascii_dtostr (gchar *buffer,
     gint buf_len,
     gdouble d);
extern
gchar * g_ascii_formatd (gchar *buffer,
     gint buf_len,
     const gchar *format,
     gdouble d);


extern
gchar* g_strchug (gchar *string);

extern
gchar* g_strchomp (gchar *string);



extern
gint g_ascii_strcasecmp (const gchar *s1,
        const gchar *s2);
extern
gint g_ascii_strncasecmp (const gchar *s1,
        const gchar *s2,
        gsize n);
extern
gchar* g_ascii_strdown (const gchar *str,
        gssize len) __attribute__((__malloc__));
extern
gchar* g_ascii_strup (const gchar *str,
        gssize len) __attribute__((__malloc__));


__attribute__((__deprecated__)) extern
gint g_strcasecmp (const gchar *s1,
                                        const gchar *s2);
__attribute__((__deprecated__)) extern
gint g_strncasecmp (const gchar *s1,
                                        const gchar *s2,
                                        guint n);
__attribute__((__deprecated__)) extern
gchar* g_strdown (gchar *string);
__attribute__((__deprecated__)) extern
gchar* g_strup (gchar *string);





extern
gchar* g_strdup (const gchar *str) __attribute__((__malloc__));
extern
gchar* g_strdup_printf (const gchar *format,
     ...) __attribute__((__format__ (__printf__, 1, 2))) __attribute__((__malloc__));
extern
gchar* g_strdup_vprintf (const gchar *format,
     va_list args) __attribute__((__format__ (__printf__, 1, 0)))
     __attribute__((__malloc__));
extern
gchar* g_strndup (const gchar *str,
     gsize n) __attribute__((__malloc__));
extern
gchar* g_strnfill (gsize length,
     gchar fill_char) __attribute__((__malloc__));
extern
gchar* g_strconcat (const gchar *string1,
     ...) __attribute__((__malloc__)) __attribute__((__sentinel__));
extern
gchar* g_strjoin (const gchar *separator,
     ...) __attribute__((__malloc__)) __attribute__((__sentinel__));





extern
gchar* g_strcompress (const gchar *source) __attribute__((__malloc__));
# 252 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern
gchar* g_strescape (const gchar *source,
     const gchar *exceptions) __attribute__((__malloc__));

extern
gpointer g_memdup (gconstpointer mem,
     guint byte_size) __attribute__((__malloc__)) __attribute__((__alloc_size__(2)));
# 269 "/usr/include/glib-2.0/glib/gstrfuncs.h"
extern
gchar** g_strsplit (const gchar *string,
     const gchar *delimiter,
     gint max_tokens) __attribute__((__malloc__));
extern
gchar ** g_strsplit_set (const gchar *string,
     const gchar *delimiters,
     gint max_tokens) __attribute__((__malloc__));
extern
gchar* g_strjoinv (const gchar *separator,
     gchar **str_array) __attribute__((__malloc__));
extern
void g_strfreev (gchar **str_array);
extern
gchar** g_strdupv (gchar **str_array) __attribute__((__malloc__));
extern
guint g_strv_length (gchar **str_array);

extern
gchar* g_stpcpy (gchar *dest,
                                        const char *src);


# 82 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gstringchunk.h" 1
# 36 "/usr/include/glib-2.0/glib/gstringchunk.h"


typedef struct _GStringChunk GStringChunk;

extern
GStringChunk* g_string_chunk_new (gsize size);
extern
void g_string_chunk_free (GStringChunk *chunk);
extern
void g_string_chunk_clear (GStringChunk *chunk);
extern
gchar* g_string_chunk_insert (GStringChunk *chunk,
                                           const gchar *string);
extern
gchar* g_string_chunk_insert_len (GStringChunk *chunk,
                                           const gchar *string,
                                           gssize len);
extern
gchar* g_string_chunk_insert_const (GStringChunk *chunk,
                                           const gchar *string);


# 84 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gtestutils.h" 1
# 33 "/usr/include/glib-2.0/glib/gtestutils.h"


typedef struct GTestCase GTestCase;
typedef struct GTestSuite GTestSuite;
typedef void (*GTestFunc) (void);
typedef void (*GTestDataFunc) (gconstpointer user_data);
typedef void (*GTestFixtureFunc) (gpointer fixture,
                                  gconstpointer user_data);
# 79 "/usr/include/glib-2.0/glib/gtestutils.h"
extern
int g_strcmp0 (const char *str1,
                                         const char *str2);


extern
void g_test_minimized_result (double minimized_quantity,
                                         const char *format,
                                         ...) __attribute__((__format__ (__printf__, 2, 3)));
extern
void g_test_maximized_result (double maximized_quantity,
                                         const char *format,
                                         ...) __attribute__((__format__ (__printf__, 2, 3)));


extern
void g_test_init (int *argc,
                                         char ***argv,
                                         ...);
# 108 "/usr/include/glib-2.0/glib/gtestutils.h"
extern
int g_test_run (void);

extern
void g_test_add_func (const char *testpath,
                                         GTestFunc test_func);

extern
void g_test_add_data_func (const char *testpath,
                                         gconstpointer test_data,
                                         GTestDataFunc test_func);

extern
void g_test_add_data_func_full (const char *testpath,
                                         gpointer test_data,
                                         GTestDataFunc test_func,
                                         GDestroyNotify data_free_func);


extern
void g_test_fail (void);
# 144 "/usr/include/glib-2.0/glib/gtestutils.h"
extern
void g_test_message (const char *format,
                                         ...) __attribute__((__format__ (__printf__, 1, 2)));
extern
void g_test_bug_base (const char *uri_pattern);
extern
void g_test_bug (const char *bug_uri_snippet);

extern
void g_test_timer_start (void);
extern
double g_test_timer_elapsed (void);
extern
double g_test_timer_last (void);


extern
void g_test_queue_free (gpointer gfree_pointer);
extern
void g_test_queue_destroy (GDestroyNotify destroy_func,
                                         gpointer destroy_data);



typedef enum {
  G_TEST_TRAP_SILENCE_STDOUT = 1 << 7,
  G_TEST_TRAP_SILENCE_STDERR = 1 << 8,
  G_TEST_TRAP_INHERIT_STDIN = 1 << 9
} GTestTrapFlags;
extern
gboolean g_test_trap_fork (guint64 usec_timeout,
                                         GTestTrapFlags test_trap_flags);
extern
gboolean g_test_trap_has_passed (void);
extern
gboolean g_test_trap_reached_timeout (void);
# 189 "/usr/include/glib-2.0/glib/gtestutils.h"
extern
gint32 g_test_rand_int (void);
extern
gint32 g_test_rand_int_range (gint32 begin,
                                         gint32 end);
extern
double g_test_rand_double (void);
extern
double g_test_rand_double_range (double range_start,
                                         double range_end);


extern
GTestCase* g_test_create_case (const char *test_name,
                                         gsize data_size,
                                         gconstpointer test_data,
                                         GTestFixtureFunc data_setup,
                                         GTestFixtureFunc data_test,
                                         GTestFixtureFunc data_teardown);
extern
GTestSuite* g_test_create_suite (const char *suite_name);
extern
GTestSuite* g_test_get_root (void);
extern
void g_test_suite_add (GTestSuite *suite,
                                         GTestCase *test_case);
extern
void g_test_suite_add_suite (GTestSuite *suite,
                                         GTestSuite *nestedsuite);
extern
int g_test_run_suite (GTestSuite *suite);


extern
void g_test_trap_assertions (const char *domain,
                                         const char *file,
                                         int line,
                                         const char *func,
                                         guint64 assertion_flags,
                                         const char *pattern);
extern
void g_assertion_message (const char *domain,
                                         const char *file,
                                         int line,
                                         const char *func,
                                         const char *message) __attribute__((__noreturn__));
extern
void g_assertion_message_expr (const char *domain,
                                         const char *file,
                                         int line,
                                         const char *func,
                                         const char *expr) __attribute__((__noreturn__));
extern
void g_assertion_message_cmpstr (const char *domain,
                                         const char *file,
                                         int line,
                                         const char *func,
                                         const char *expr,
                                         const char *arg1,
                                         const char *cmp,
                                         const char *arg2) __attribute__((__noreturn__));
extern
void g_assertion_message_cmpnum (const char *domain,
                                         const char *file,
                                         int line,
                                         const char *func,
                                         const char *expr,
                                         long double arg1,
                                         const char *cmp,
                                         long double arg2,
                                         char numtype) __attribute__((__noreturn__));
extern
void g_assertion_message_error (const char *domain,
                                         const char *file,
                                         int line,
                                         const char *func,
                                         const char *expr,
                                         const GError *error,
                                         GQuark error_domain,
                                         int error_code) __attribute__((__noreturn__));
extern
void g_test_add_vtable (const char *testpath,
                                         gsize data_size,
                                         gconstpointer test_data,
                                         GTestFixtureFunc data_setup,
                                         GTestFixtureFunc data_test,
                                         GTestFixtureFunc data_teardown);
typedef struct {
  gboolean test_initialized;
  gboolean test_quick;
  gboolean test_perf;
  gboolean test_verbose;
  gboolean test_quiet;
  gboolean test_undefined;
} GTestConfig;
extern const GTestConfig * const g_test_config_vars;


typedef enum {
  G_TEST_LOG_NONE,
  G_TEST_LOG_ERROR,
  G_TEST_LOG_START_BINARY,
  G_TEST_LOG_LIST_CASE,
  G_TEST_LOG_SKIP_CASE,
  G_TEST_LOG_START_CASE,
  G_TEST_LOG_STOP_CASE,
  G_TEST_LOG_MIN_RESULT,
  G_TEST_LOG_MAX_RESULT,
  G_TEST_LOG_MESSAGE
} GTestLogType;

typedef struct {
  GTestLogType log_type;
  guint n_strings;
  gchar **strings;
  guint n_nums;
  long double *nums;
} GTestLogMsg;
typedef struct {

  GString *data;
  GSList *msgs;
} GTestLogBuffer;

extern
const char* g_test_log_type_name (GTestLogType log_type);
extern
GTestLogBuffer* g_test_log_buffer_new (void);
extern
void g_test_log_buffer_free (GTestLogBuffer *tbuffer);
extern
void g_test_log_buffer_push (GTestLogBuffer *tbuffer,
                                         guint n_bytes,
                                         const guint8 *bytes);
extern
GTestLogMsg* g_test_log_buffer_pop (GTestLogBuffer *tbuffer);
extern
void g_test_log_msg_free (GTestLogMsg *tmsg);
# 341 "/usr/include/glib-2.0/glib/gtestutils.h"
typedef gboolean (*GTestLogFatalFunc) (const gchar *log_domain,
                                                 GLogLevelFlags log_level,
                                                 const gchar *message,
                                                 gpointer user_data);
extern
void
g_test_log_set_fatal_handler (GTestLogFatalFunc log_func,
                                         gpointer user_data);

extern
void g_test_expect_message (const gchar *log_domain,
                                                  GLogLevelFlags log_level,
                                                  const gchar *pattern);
extern
void g_test_assert_expected_messages_internal (const char *domain,
                                                  const char *file,
                                                  int line,
                                                  const char *func);




# 85 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gthreadpool.h" 1
# 36 "/usr/include/glib-2.0/glib/gthreadpool.h"


typedef struct _GThreadPool GThreadPool;




struct _GThreadPool
{
  GFunc func;
  gpointer user_data;
  gboolean exclusive;
};

extern
GThreadPool * g_thread_pool_new (GFunc func,
                                                 gpointer user_data,
                                                 gint max_threads,
                                                 gboolean exclusive,
                                                 GError **error);
extern
void g_thread_pool_free (GThreadPool *pool,
                                                 gboolean immediate,
                                                 gboolean wait_);
extern
gboolean g_thread_pool_push (GThreadPool *pool,
                                                 gpointer data,
                                                 GError **error);
extern
guint g_thread_pool_unprocessed (GThreadPool *pool);
extern
void g_thread_pool_set_sort_function (GThreadPool *pool,
                                                 GCompareDataFunc func,
                                                 gpointer user_data);
extern
gboolean g_thread_pool_set_max_threads (GThreadPool *pool,
                                                 gint max_threads,
                                                 GError **error);
extern
gint g_thread_pool_get_max_threads (GThreadPool *pool);
extern
guint g_thread_pool_get_num_threads (GThreadPool *pool);

extern
void g_thread_pool_set_max_unused_threads (gint max_threads);
extern
gint g_thread_pool_get_max_unused_threads (void);
extern
guint g_thread_pool_get_num_unused_threads (void);
extern
void g_thread_pool_stop_unused_threads (void);
extern
void g_thread_pool_set_max_idle_time (guint interval);
extern
guint g_thread_pool_get_max_idle_time (void);


# 87 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gtimer.h" 1
# 36 "/usr/include/glib-2.0/glib/gtimer.h"






typedef struct _GTimer GTimer;



extern
GTimer* g_timer_new (void);
extern
void g_timer_destroy (GTimer *timer);
extern
void g_timer_start (GTimer *timer);
extern
void g_timer_stop (GTimer *timer);
extern
void g_timer_reset (GTimer *timer);
extern
void g_timer_continue (GTimer *timer);
extern
gdouble g_timer_elapsed (GTimer *timer,
      gulong *microseconds);

extern
void g_usleep (gulong microseconds);

extern
void g_time_val_add (GTimeVal *time_,
                                  glong microseconds);
extern
gboolean g_time_val_from_iso8601 (const gchar *iso_date,
      GTimeVal *time_);
extern
gchar* g_time_val_to_iso8601 (GTimeVal *time_) __attribute__((__malloc__));


# 88 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gtrashstack.h" 1
# 36 "/usr/include/glib-2.0/glib/gtrashstack.h"


typedef struct _GTrashStack GTrashStack;
struct _GTrashStack
{
  GTrashStack *next;
};

static __inline __attribute__ ((unused)) void g_trash_stack_push (GTrashStack **stack_p,
                                              gpointer data_p);
static __inline __attribute__ ((unused)) gpointer g_trash_stack_pop (GTrashStack **stack_p);
static __inline __attribute__ ((unused)) gpointer g_trash_stack_peek (GTrashStack **stack_p);
static __inline __attribute__ ((unused)) guint g_trash_stack_height (GTrashStack **stack_p);



static __inline __attribute__ ((unused)) void
g_trash_stack_push (GTrashStack **stack_p,
                    gpointer data_p)
{
  GTrashStack *data = (GTrashStack *) data_p;

  data->next = *stack_p;
  *stack_p = data;
}
static __inline __attribute__ ((unused)) gpointer
g_trash_stack_pop (GTrashStack **stack_p)
{
  GTrashStack *data;

  data = *stack_p;
  if (data)
    {
      *stack_p = data->next;



      data->next = ((void *)0);
    }

  return data;
}
static __inline __attribute__ ((unused)) gpointer
g_trash_stack_peek (GTrashStack **stack_p)
{
  GTrashStack *data;

  data = *stack_p;

  return data;
}
static __inline __attribute__ ((unused)) guint
g_trash_stack_height (GTrashStack **stack_p)
{
  GTrashStack *data;
  guint i = 0;

  for (data = *stack_p; data; data = data->next)
    i++;

  return i;
}




# 90 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gtree.h" 1
# 36 "/usr/include/glib-2.0/glib/gtree.h"


typedef struct _GTree GTree;

typedef gboolean (*GTraverseFunc) (gpointer key,
                                   gpointer value,
                                   gpointer data);



extern
GTree* g_tree_new (GCompareFunc key_compare_func);
extern
GTree* g_tree_new_with_data (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data);
extern
GTree* g_tree_new_full (GCompareDataFunc key_compare_func,
                                 gpointer key_compare_data,
                                 GDestroyNotify key_destroy_func,
                                 GDestroyNotify value_destroy_func);
extern
GTree* g_tree_ref (GTree *tree);
extern
void g_tree_unref (GTree *tree);
extern
void g_tree_destroy (GTree *tree);
extern
void g_tree_insert (GTree *tree,
                                 gpointer key,
                                 gpointer value);
extern
void g_tree_replace (GTree *tree,
                                 gpointer key,
                                 gpointer value);
extern
gboolean g_tree_remove (GTree *tree,
                                 gconstpointer key);
extern
gboolean g_tree_steal (GTree *tree,
                                 gconstpointer key);
extern
gpointer g_tree_lookup (GTree *tree,
                                 gconstpointer key);
extern
gboolean g_tree_lookup_extended (GTree *tree,
                                 gconstpointer lookup_key,
                                 gpointer *orig_key,
                                 gpointer *value);
extern
void g_tree_foreach (GTree *tree,
                                 GTraverseFunc func,
                                 gpointer user_data);

__attribute__((__deprecated__)) extern
void g_tree_traverse (GTree *tree,
                                 GTraverseFunc traverse_func,
                                 GTraverseType traverse_type,
                                 gpointer user_data);

extern
gpointer g_tree_search (GTree *tree,
                                 GCompareFunc search_func,
                                 gconstpointer user_data);
extern
gint g_tree_height (GTree *tree);
extern
gint g_tree_nnodes (GTree *tree);


# 91 "/usr/include/glib-2.0/glib.h" 2


# 1 "/usr/include/glib-2.0/glib/gurifuncs.h" 1
# 32 "/usr/include/glib-2.0/glib/gurifuncs.h"

# 69 "/usr/include/glib-2.0/glib/gurifuncs.h"
extern
char * g_uri_unescape_string (const char *escaped_string,
          const char *illegal_characters);
extern
char * g_uri_unescape_segment (const char *escaped_string,
          const char *escaped_string_end,
          const char *illegal_characters);
extern
char * g_uri_parse_scheme (const char *uri);
extern
char * g_uri_escape_string (const char *unescaped,
          const char *reserved_chars_allowed,
          gboolean allow_utf8);


# 94 "/usr/include/glib-2.0/glib.h" 2

# 1 "/usr/include/glib-2.0/glib/gvarianttype.h" 1
# 33 "/usr/include/glib-2.0/glib/gvarianttype.h"

# 44 "/usr/include/glib-2.0/glib/gvarianttype.h"
typedef struct _GVariantType GVariantType;
# 297 "/usr/include/glib-2.0/glib/gvarianttype.h"
extern
gboolean g_variant_type_string_is_valid (const gchar *type_string);
extern
gboolean g_variant_type_string_scan (const gchar *string,
                                                                         const gchar *limit,
                                                                         const gchar **endptr);


extern
void g_variant_type_free (GVariantType *type);
extern
GVariantType * g_variant_type_copy (const GVariantType *type);
extern
GVariantType * g_variant_type_new (const gchar *type_string);


extern
gsize g_variant_type_get_string_length (const GVariantType *type);
extern
const gchar * g_variant_type_peek_string (const GVariantType *type);
extern
gchar * g_variant_type_dup_string (const GVariantType *type);


extern
gboolean g_variant_type_is_definite (const GVariantType *type);
extern
gboolean g_variant_type_is_container (const GVariantType *type);
extern
gboolean g_variant_type_is_basic (const GVariantType *type);
extern
gboolean g_variant_type_is_maybe (const GVariantType *type);
extern
gboolean g_variant_type_is_array (const GVariantType *type);
extern
gboolean g_variant_type_is_tuple (const GVariantType *type);
extern
gboolean g_variant_type_is_dict_entry (const GVariantType *type);
extern
gboolean g_variant_type_is_variant (const GVariantType *type);


extern
guint g_variant_type_hash (gconstpointer type);
extern
gboolean g_variant_type_equal (gconstpointer type1,
                                                                         gconstpointer type2);


extern
gboolean g_variant_type_is_subtype_of (const GVariantType *type,
                                                                         const GVariantType *supertype);


extern
const GVariantType * g_variant_type_element (const GVariantType *type);
extern
const GVariantType * g_variant_type_first (const GVariantType *type);
extern
const GVariantType * g_variant_type_next (const GVariantType *type);
extern
gsize g_variant_type_n_items (const GVariantType *type);
extern
const GVariantType * g_variant_type_key (const GVariantType *type);
extern
const GVariantType * g_variant_type_value (const GVariantType *type);


extern
GVariantType * g_variant_type_new_array (const GVariantType *element);
extern
GVariantType * g_variant_type_new_maybe (const GVariantType *element);
extern
GVariantType * g_variant_type_new_tuple (const GVariantType * const *items,
                                                                         gint length);
extern
GVariantType * g_variant_type_new_dict_entry (const GVariantType *key,
                                                                         const GVariantType *value);


extern
const GVariantType * g_variant_type_checked_ (const gchar *);


# 96 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gvariant.h" 1
# 34 "/usr/include/glib-2.0/glib/gvariant.h"


typedef struct _GVariant GVariant;

typedef enum
{
  G_VARIANT_CLASS_BOOLEAN = 'b',
  G_VARIANT_CLASS_BYTE = 'y',
  G_VARIANT_CLASS_INT16 = 'n',
  G_VARIANT_CLASS_UINT16 = 'q',
  G_VARIANT_CLASS_INT32 = 'i',
  G_VARIANT_CLASS_UINT32 = 'u',
  G_VARIANT_CLASS_INT64 = 'x',
  G_VARIANT_CLASS_UINT64 = 't',
  G_VARIANT_CLASS_HANDLE = 'h',
  G_VARIANT_CLASS_DOUBLE = 'd',
  G_VARIANT_CLASS_STRING = 's',
  G_VARIANT_CLASS_OBJECT_PATH = 'o',
  G_VARIANT_CLASS_SIGNATURE = 'g',
  G_VARIANT_CLASS_VARIANT = 'v',
  G_VARIANT_CLASS_MAYBE = 'm',
  G_VARIANT_CLASS_ARRAY = 'a',
  G_VARIANT_CLASS_TUPLE = '(',
  G_VARIANT_CLASS_DICT_ENTRY = '{'
} GVariantClass;

extern
void g_variant_unref (GVariant *value);
extern
GVariant * g_variant_ref (GVariant *value);
extern
GVariant * g_variant_ref_sink (GVariant *value);
extern
gboolean g_variant_is_floating (GVariant *value);
extern
GVariant * g_variant_take_ref (GVariant *value);

extern
const GVariantType * g_variant_get_type (GVariant *value);
extern
const gchar * g_variant_get_type_string (GVariant *value);
extern
gboolean g_variant_is_of_type (GVariant *value,
                                                                         const GVariantType *type);
extern
gboolean g_variant_is_container (GVariant *value);
extern
GVariantClass g_variant_classify (GVariant *value);
extern
GVariant * g_variant_new_boolean (gboolean value);
extern
GVariant * g_variant_new_byte (guchar value);
extern
GVariant * g_variant_new_int16 (gint16 value);
extern
GVariant * g_variant_new_uint16 (guint16 value);
extern
GVariant * g_variant_new_int32 (gint32 value);
extern
GVariant * g_variant_new_uint32 (guint32 value);
extern
GVariant * g_variant_new_int64 (gint64 value);
extern
GVariant * g_variant_new_uint64 (guint64 value);
extern
GVariant * g_variant_new_handle (gint32 value);
extern
GVariant * g_variant_new_double (gdouble value);
extern
GVariant * g_variant_new_string (const gchar *string);
extern
GVariant * g_variant_new_object_path (const gchar *object_path);
extern
gboolean g_variant_is_object_path (const gchar *string);
extern
GVariant * g_variant_new_signature (const gchar *signature);
extern
gboolean g_variant_is_signature (const gchar *string);
extern
GVariant * g_variant_new_variant (GVariant *value);
extern
GVariant * g_variant_new_strv (const gchar * const *strv,
                                                                         gssize length);
extern
GVariant * g_variant_new_objv (const gchar * const *strv,
                                                                         gssize length);
extern
GVariant * g_variant_new_bytestring (const gchar *string);
extern
GVariant * g_variant_new_bytestring_array (const gchar * const *strv,
                                                                         gssize length);
extern
GVariant * g_variant_new_fixed_array (const GVariantType *element_type,
                                                                         gconstpointer elements,
                                                                         gsize n_elements,
                                                                         gsize element_size);
extern
gboolean g_variant_get_boolean (GVariant *value);
extern
guchar g_variant_get_byte (GVariant *value);
extern
gint16 g_variant_get_int16 (GVariant *value);
extern
guint16 g_variant_get_uint16 (GVariant *value);
extern
gint32 g_variant_get_int32 (GVariant *value);
extern
guint32 g_variant_get_uint32 (GVariant *value);
extern
gint64 g_variant_get_int64 (GVariant *value);
extern
guint64 g_variant_get_uint64 (GVariant *value);
extern
gint32 g_variant_get_handle (GVariant *value);
extern
gdouble g_variant_get_double (GVariant *value);
extern
GVariant * g_variant_get_variant (GVariant *value);
extern
const gchar * g_variant_get_string (GVariant *value,
                                                                         gsize *length);
extern
gchar * g_variant_dup_string (GVariant *value,
                                                                         gsize *length);
extern
const gchar ** g_variant_get_strv (GVariant *value,
                                                                         gsize *length);
extern
gchar ** g_variant_dup_strv (GVariant *value,
                                                                         gsize *length);
extern
const gchar ** g_variant_get_objv (GVariant *value,
                                                                         gsize *length);
extern
gchar ** g_variant_dup_objv (GVariant *value,
                                                                         gsize *length);
extern
const gchar * g_variant_get_bytestring (GVariant *value);
extern
gchar * g_variant_dup_bytestring (GVariant *value,
                                                                         gsize *length);
extern
const gchar ** g_variant_get_bytestring_array (GVariant *value,
                                                                         gsize *length);
extern
gchar ** g_variant_dup_bytestring_array (GVariant *value,
                                                                         gsize *length);

extern
GVariant * g_variant_new_maybe (const GVariantType *child_type,
                                                                         GVariant *child);
extern
GVariant * g_variant_new_array (const GVariantType *child_type,
                                                                         GVariant * const *children,
                                                                         gsize n_children);
extern
GVariant * g_variant_new_tuple (GVariant * const *children,
                                                                         gsize n_children);
extern
GVariant * g_variant_new_dict_entry (GVariant *key,
                                                                         GVariant *value);

extern
GVariant * g_variant_get_maybe (GVariant *value);
extern
gsize g_variant_n_children (GVariant *value);
extern
void g_variant_get_child (GVariant *value,
                                                                         gsize index_,
                                                                         const gchar *format_string,
                                                                         ...);
extern
GVariant * g_variant_get_child_value (GVariant *value,
                                                                         gsize index_);
extern
gboolean g_variant_lookup (GVariant *dictionary,
                                                                         const gchar *key,
                                                                         const gchar *format_string,
                                                                         ...);
extern
GVariant * g_variant_lookup_value (GVariant *dictionary,
                                                                         const gchar *key,
                                                                         const GVariantType *expected_type);
extern
gconstpointer g_variant_get_fixed_array (GVariant *value,
                                                                         gsize *n_elements,
                                                                         gsize element_size);

extern
gsize g_variant_get_size (GVariant *value);
extern
gconstpointer g_variant_get_data (GVariant *value);
extern
GBytes * g_variant_get_data_as_bytes (GVariant *value);
extern
void g_variant_store (GVariant *value,
                                                                         gpointer data);

extern
gchar * g_variant_print (GVariant *value,
                                                                         gboolean type_annotate);
extern
GString * g_variant_print_string (GVariant *value,
                                                                         GString *string,
                                                                         gboolean type_annotate);

extern
guint g_variant_hash (gconstpointer value);
extern
gboolean g_variant_equal (gconstpointer one,
                                                                         gconstpointer two);

extern
GVariant * g_variant_get_normal_form (GVariant *value);
extern
gboolean g_variant_is_normal_form (GVariant *value);
extern
GVariant * g_variant_byteswap (GVariant *value);

extern
GVariant * g_variant_new_from_bytes (const GVariantType *type,
                                                                         GBytes *bytes,
                                                                         gboolean trusted);
extern
GVariant * g_variant_new_from_data (const GVariantType *type,
                                                                         gconstpointer data,
                                                                         gsize size,
                                                                         gboolean trusted,
                                                                         GDestroyNotify notify,
                                                                         gpointer user_data);

typedef struct _GVariantIter GVariantIter;
struct _GVariantIter {

  gsize x[16];
};

extern
GVariantIter * g_variant_iter_new (GVariant *value);
extern
gsize g_variant_iter_init (GVariantIter *iter,
                                                                         GVariant *value);
extern
GVariantIter * g_variant_iter_copy (GVariantIter *iter);
extern
gsize g_variant_iter_n_children (GVariantIter *iter);
extern
void g_variant_iter_free (GVariantIter *iter);
extern
GVariant * g_variant_iter_next_value (GVariantIter *iter);
extern
gboolean g_variant_iter_next (GVariantIter *iter,
                                                                         const gchar *format_string,
                                                                         ...);
extern
gboolean g_variant_iter_loop (GVariantIter *iter,
                                                                         const gchar *format_string,
                                                                         ...);


typedef struct _GVariantBuilder GVariantBuilder;
struct _GVariantBuilder {

  gsize x[16];
};

typedef enum
{
  G_VARIANT_PARSE_ERROR_FAILED,
  G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED,
  G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE,
  G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED,
  G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END,
  G_VARIANT_PARSE_ERROR_INVALID_CHARACTER,
  G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING,
  G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH,
  G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE,
  G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING,
  G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE,
  G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE,
  G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG,
  G_VARIANT_PARSE_ERROR_TYPE_ERROR,
  G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN,
  G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD,
  G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT,
  G_VARIANT_PARSE_ERROR_VALUE_EXPECTED
} GVariantParseError;


extern
GQuark g_variant_parser_get_error_quark (void);

extern
GVariantBuilder * g_variant_builder_new (const GVariantType *type);
extern
void g_variant_builder_unref (GVariantBuilder *builder);
extern
GVariantBuilder * g_variant_builder_ref (GVariantBuilder *builder);
extern
void g_variant_builder_init (GVariantBuilder *builder,
                                                                         const GVariantType *type);
extern
GVariant * g_variant_builder_end (GVariantBuilder *builder);
extern
void g_variant_builder_clear (GVariantBuilder *builder);
extern
void g_variant_builder_open (GVariantBuilder *builder,
                                                                         const GVariantType *type);
extern
void g_variant_builder_close (GVariantBuilder *builder);
extern
void g_variant_builder_add_value (GVariantBuilder *builder,
                                                                         GVariant *value);
extern
void g_variant_builder_add (GVariantBuilder *builder,
                                                                         const gchar *format_string,
                                                                         ...);
extern
void g_variant_builder_add_parsed (GVariantBuilder *builder,
                                                                         const gchar *format,
                                                                         ...);

extern
GVariant * g_variant_new (const gchar *format_string,
                                                                         ...);
extern
void g_variant_get (GVariant *value,
                                                                         const gchar *format_string,
                                                                         ...);
extern
GVariant * g_variant_new_va (const gchar *format_string,
                                                                         const gchar **endptr,
                                                                         va_list *app);
extern
void g_variant_get_va (GVariant *value,
                                                                         const gchar *format_string,
                                                                         const gchar **endptr,
                                                                         va_list *app);
extern
gboolean g_variant_check_format_string (GVariant *value,
                                                                         const gchar *format_string,
                                                                         gboolean copy_only);

extern
GVariant * g_variant_parse (const GVariantType *type,
                                                                         const gchar *text,
                                                                         const gchar *limit,
                                                                         const gchar **endptr,
                                                                         GError **error);
extern
GVariant * g_variant_new_parsed (const gchar *format,
                                                                         ...);
extern
GVariant * g_variant_new_parsed_va (const gchar *format,
                                                                         va_list *app);

extern
gint g_variant_compare (gconstpointer one,
                                                                         gconstpointer two);

# 97 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/gversion.h" 1
# 36 "/usr/include/glib-2.0/glib/gversion.h"


extern const guint glib_major_version;
extern const guint glib_minor_version;
extern const guint glib_micro_version;
extern const guint glib_interface_age;
extern const guint glib_binary_age;

extern
const gchar * glib_check_version (guint required_major,
                                  guint required_minor,
                                  guint required_micro);








# 98 "/usr/include/glib-2.0/glib.h" 2






# 1 "/usr/include/glib-2.0/glib/deprecated/gallocator.h" 1
# 27 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"


typedef struct _GAllocator GAllocator;
typedef struct _GMemChunk GMemChunk;
# 44 "/usr/include/glib-2.0/glib/deprecated/gallocator.h"
__attribute__((__deprecated__)) extern
GMemChunk * g_mem_chunk_new (const gchar *name,
                                         gint atom_size,
                                         gsize area_size,
                                         gint type);
__attribute__((__deprecated__)) extern
void g_mem_chunk_destroy (GMemChunk *mem_chunk);
__attribute__((__deprecated__)) extern
gpointer g_mem_chunk_alloc (GMemChunk *mem_chunk);
__attribute__((__deprecated__)) extern
gpointer g_mem_chunk_alloc0 (GMemChunk *mem_chunk);
__attribute__((__deprecated__)) extern
void g_mem_chunk_free (GMemChunk *mem_chunk,
                                         gpointer mem);
__attribute__((__deprecated__)) extern
void g_mem_chunk_clean (GMemChunk *mem_chunk);
__attribute__((__deprecated__)) extern
void g_mem_chunk_reset (GMemChunk *mem_chunk);
__attribute__((__deprecated__)) extern
void g_mem_chunk_print (GMemChunk *mem_chunk);
__attribute__((__deprecated__)) extern
void g_mem_chunk_info (void);
__attribute__((__deprecated__)) extern
void g_blow_chunks (void);


__attribute__((__deprecated__)) extern
GAllocator * g_allocator_new (const gchar *name,
                                         guint n_preallocs);
__attribute__((__deprecated__)) extern
void g_allocator_free (GAllocator *allocator);
__attribute__((__deprecated__)) extern
void g_list_push_allocator (GAllocator *allocator);
__attribute__((__deprecated__)) extern
void g_list_pop_allocator (void);
__attribute__((__deprecated__)) extern
void g_slist_push_allocator (GAllocator *allocator);
__attribute__((__deprecated__)) extern
void g_slist_pop_allocator (void);
__attribute__((__deprecated__)) extern
void g_node_push_allocator (GAllocator *allocator);
__attribute__((__deprecated__)) extern
void g_node_pop_allocator (void);


# 105 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/deprecated/gcache.h" 1
# 36 "/usr/include/glib-2.0/glib/deprecated/gcache.h"


typedef struct _GCache GCache;

typedef gpointer (*GCacheNewFunc) (gpointer key);
typedef gpointer (*GCacheDupFunc) (gpointer value);
typedef void (*GCacheDestroyFunc) (gpointer value);



__attribute__((__deprecated__)) extern
GCache* g_cache_new (GCacheNewFunc value_new_func,
                                GCacheDestroyFunc value_destroy_func,
                                GCacheDupFunc key_dup_func,
                                GCacheDestroyFunc key_destroy_func,
                                GHashFunc hash_key_func,
                                GHashFunc hash_value_func,
                                GEqualFunc key_equal_func);
__attribute__((__deprecated__)) extern
void g_cache_destroy (GCache *cache);
__attribute__((__deprecated__)) extern
gpointer g_cache_insert (GCache *cache,
                                gpointer key);
__attribute__((__deprecated__)) extern
void g_cache_remove (GCache *cache,
                                gconstpointer value);
__attribute__((__deprecated__)) extern
void g_cache_key_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);
__attribute__((__deprecated__)) extern
void g_cache_value_foreach (GCache *cache,
                                GHFunc func,
                                gpointer user_data);


# 106 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h" 1
# 36 "/usr/include/glib-2.0/glib/deprecated/gcompletion.h"


typedef struct _GCompletion GCompletion;

typedef gchar* (*GCompletionFunc) (gpointer);




typedef gint (*GCompletionStrncmpFunc) (const gchar *s1,
                                        const gchar *s2,
                                        gsize n);

struct _GCompletion
{
  GList* items;
  GCompletionFunc func;

  gchar* prefix;
  GList* cache;
  GCompletionStrncmpFunc strncmp_func;
};

__attribute__((__deprecated__)) extern
GCompletion* g_completion_new (GCompletionFunc func);
__attribute__((__deprecated__)) extern
void g_completion_add_items (GCompletion* cmp,
                                         GList* items);
__attribute__((__deprecated__)) extern
void g_completion_remove_items (GCompletion* cmp,
                                         GList* items);
__attribute__((__deprecated__)) extern
void g_completion_clear_items (GCompletion* cmp);
__attribute__((__deprecated__)) extern
GList* g_completion_complete (GCompletion* cmp,
                                         const gchar* prefix,
                                         gchar** new_prefix);
__attribute__((__deprecated__)) extern
GList* g_completion_complete_utf8 (GCompletion *cmp,
                                         const gchar* prefix,
                                         gchar** new_prefix);
__attribute__((__deprecated__)) extern
void g_completion_set_compare (GCompletion *cmp,
                                         GCompletionStrncmpFunc strncmp_func);
__attribute__((__deprecated__)) extern
void g_completion_free (GCompletion* cmp);


# 107 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/deprecated/gmain.h" 1
# 36 "/usr/include/glib-2.0/glib/deprecated/gmain.h"

# 136 "/usr/include/glib-2.0/glib/deprecated/gmain.h"

# 108 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/deprecated/grel.h" 1
# 36 "/usr/include/glib-2.0/glib/deprecated/grel.h"


typedef struct _GRelation GRelation;
typedef struct _GTuples GTuples;

struct _GTuples
{
  guint len;
};
# 69 "/usr/include/glib-2.0/glib/deprecated/grel.h"
__attribute__((__deprecated__)) extern
GRelation* g_relation_new (gint fields);
__attribute__((__deprecated__)) extern
void g_relation_destroy (GRelation *relation);
__attribute__((__deprecated__)) extern
void g_relation_index (GRelation *relation,
                               gint field,
                               GHashFunc hash_func,
                               GEqualFunc key_equal_func);
__attribute__((__deprecated__)) extern
void g_relation_insert (GRelation *relation,
                               ...);
__attribute__((__deprecated__)) extern
gint g_relation_delete (GRelation *relation,
                               gconstpointer key,
                               gint field);
__attribute__((__deprecated__)) extern
GTuples* g_relation_select (GRelation *relation,
                               gconstpointer key,
                               gint field);
__attribute__((__deprecated__)) extern
gint g_relation_count (GRelation *relation,
                               gconstpointer key,
                               gint field);
__attribute__((__deprecated__)) extern
gboolean g_relation_exists (GRelation *relation,
                               ...);
__attribute__((__deprecated__)) extern
void g_relation_print (GRelation *relation);
__attribute__((__deprecated__)) extern
void g_tuples_destroy (GTuples *tuples);
__attribute__((__deprecated__)) extern
gpointer g_tuples_index (GTuples *tuples,
                               gint index_,
                               gint field);


# 109 "/usr/include/glib-2.0/glib.h" 2
# 1 "/usr/include/glib-2.0/glib/deprecated/gthread.h" 1
# 36 "/usr/include/glib-2.0/glib/deprecated/gthread.h"


typedef enum
{
  G_THREAD_PRIORITY_LOW,
  G_THREAD_PRIORITY_NORMAL,
  G_THREAD_PRIORITY_HIGH,
  G_THREAD_PRIORITY_URGENT
} GThreadPriority;

struct _GThread
{

  GThreadFunc func;
  gpointer data;
  gboolean joinable;
  GThreadPriority priority;
};

typedef struct _GThreadFunctions GThreadFunctions;
struct _GThreadFunctions
{
  GMutex* (*mutex_new) (void);
  void (*mutex_lock) (GMutex *mutex);
  gboolean (*mutex_trylock) (GMutex *mutex);
  void (*mutex_unlock) (GMutex *mutex);
  void (*mutex_free) (GMutex *mutex);
  GCond* (*cond_new) (void);
  void (*cond_signal) (GCond *cond);
  void (*cond_broadcast) (GCond *cond);
  void (*cond_wait) (GCond *cond,
                                   GMutex *mutex);
  gboolean (*cond_timed_wait) (GCond *cond,
                                   GMutex *mutex,
                                   GTimeVal *end_time);
  void (*cond_free) (GCond *cond);
  GPrivate* (*private_new) (GDestroyNotify destructor);
  gpointer (*private_get) (GPrivate *private_key);
  void (*private_set) (GPrivate *private_key,
                                   gpointer data);
  void (*thread_create) (GThreadFunc func,
                                   gpointer data,
                                   gulong stack_size,
                                   gboolean joinable,
                                   gboolean bound,
                                   GThreadPriority priority,
                                   gpointer thread,
                                   GError **error);
  void (*thread_yield) (void);
  void (*thread_join) (gpointer thread);
  void (*thread_exit) (void);
  void (*thread_set_priority)(gpointer thread,
                                   GThreadPriority priority);
  void (*thread_self) (gpointer thread);
  gboolean (*thread_equal) (gpointer thread1,
                                   gpointer thread2);
};

extern GThreadFunctions g_thread_functions_for_glib_use;
extern gboolean g_thread_use_default_impl;

extern guint64 (*g_thread_gettime) (void);

__attribute__((__deprecated__("Use '" "g_thread_new" "' instead"))) extern
GThread *g_thread_create (GThreadFunc func,
                                gpointer data,
                                gboolean joinable,
                                GError **error);

__attribute__((__deprecated__("Use '" "g_thread_new" "' instead"))) extern
GThread *g_thread_create_full (GThreadFunc func,
                                gpointer data,
                                gulong stack_size,
                                gboolean joinable,
                                gboolean bound,
                                GThreadPriority priority,
                                GError **error);

__attribute__((__deprecated__)) extern
void g_thread_set_priority (GThread *thread,
                                GThreadPriority priority);

__attribute__((__deprecated__)) extern
void g_thread_foreach (GFunc thread_func,
                                gpointer user_data);


# 1 "/usr/include/pthread.h" 1 3 4
# 22 "/usr/include/pthread.h" 3 4
# 1 "/usr/include/endian.h" 1 3 4
# 36 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/endian.h" 1 3 4
# 37 "/usr/include/endian.h" 2 3 4
# 60 "/usr/include/endian.h" 3 4
# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 28 "/usr/include/bits/byteswap.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/bits/byteswap.h" 2 3 4






# 1 "/usr/include/bits/byteswap-16.h" 1 3 4
# 36 "/usr/include/bits/byteswap.h" 2 3 4
# 44 "/usr/include/bits/byteswap.h" 3 4
static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
# 108 "/usr/include/bits/byteswap.h" 3 4
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
# 61 "/usr/include/endian.h" 2 3 4
# 23 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/sched.h" 1 3 4
# 29 "/usr/include/sched.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 30 "/usr/include/sched.h" 2 3 4
# 42 "/usr/include/sched.h" 3 4
# 1 "/usr/include/bits/sched.h" 1 3 4
# 73 "/usr/include/bits/sched.h" 3 4
struct sched_param
  {
    int __sched_priority;
  };


# 96 "/usr/include/bits/sched.h" 3 4








struct __sched_param
  {
    int __sched_priority;
  };
# 119 "/usr/include/bits/sched.h" 3 4
typedef unsigned long int __cpu_mask;






typedef struct
{
  __cpu_mask __bits[1024 / (8 * sizeof (__cpu_mask))];
} cpu_set_t;
# 202 "/usr/include/bits/sched.h" 3 4


extern int __sched_cpucount (size_t __setsize, const cpu_set_t *__setp)
  __attribute__ ((__nothrow__ , __leaf__));
extern cpu_set_t *__sched_cpualloc (size_t __count) __attribute__ ((__nothrow__ , __leaf__)) ;
extern void __sched_cpufree (cpu_set_t *__set) __attribute__ ((__nothrow__ , __leaf__));


# 43 "/usr/include/sched.h" 2 3 4







extern int sched_setparam (__pid_t __pid, const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getparam (__pid_t __pid, struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_setscheduler (__pid_t __pid, int __policy,
          const struct sched_param *__param) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_getscheduler (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_yield (void) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_max (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_get_priority_min (int __algorithm) __attribute__ ((__nothrow__ , __leaf__));


extern int sched_rr_get_interval (__pid_t __pid, struct timespec *__t) __attribute__ ((__nothrow__ , __leaf__));
# 125 "/usr/include/sched.h" 3 4

# 24 "/usr/include/pthread.h" 2 3 4



# 1 "/usr/include/bits/setjmp.h" 1 3 4
# 26 "/usr/include/bits/setjmp.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 27 "/usr/include/bits/setjmp.h" 2 3 4




typedef long int __jmp_buf[8];
# 28 "/usr/include/pthread.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 29 "/usr/include/pthread.h" 2 3 4



enum
{
  PTHREAD_CREATE_JOINABLE,

  PTHREAD_CREATE_DETACHED

};



enum
{
  PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_ADAPTIVE_NP

  ,
  PTHREAD_MUTEX_NORMAL = PTHREAD_MUTEX_TIMED_NP,
  PTHREAD_MUTEX_RECURSIVE = PTHREAD_MUTEX_RECURSIVE_NP,
  PTHREAD_MUTEX_ERRORCHECK = PTHREAD_MUTEX_ERRORCHECK_NP,
  PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL





};




enum
{
  PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_STALLED_NP = PTHREAD_MUTEX_STALLED,
  PTHREAD_MUTEX_ROBUST,
  PTHREAD_MUTEX_ROBUST_NP = PTHREAD_MUTEX_ROBUST
};





enum
{
  PTHREAD_PRIO_NONE,
  PTHREAD_PRIO_INHERIT,
  PTHREAD_PRIO_PROTECT
};
# 113 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_RWLOCK_PREFER_READER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NP,
  PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP,
  PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP
};
# 154 "/usr/include/pthread.h" 3 4
enum
{
  PTHREAD_INHERIT_SCHED,

  PTHREAD_EXPLICIT_SCHED

};



enum
{
  PTHREAD_SCOPE_SYSTEM,

  PTHREAD_SCOPE_PROCESS

};



enum
{
  PTHREAD_PROCESS_PRIVATE,

  PTHREAD_PROCESS_SHARED

};
# 189 "/usr/include/pthread.h" 3 4
struct _pthread_cleanup_buffer
{
  void (*__routine) (void *);
  void *__arg;
  int __canceltype;
  struct _pthread_cleanup_buffer *__prev;
};


enum
{
  PTHREAD_CANCEL_ENABLE,

  PTHREAD_CANCEL_DISABLE

};
enum
{
  PTHREAD_CANCEL_DEFERRED,

  PTHREAD_CANCEL_ASYNCHRONOUS

};
# 227 "/usr/include/pthread.h" 3 4





extern int pthread_create (pthread_t *__restrict __newthread,
      const pthread_attr_t *__restrict __attr,
      void *(*__start_routine) (void *),
      void *__restrict __arg) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 3)));





extern void pthread_exit (void *__retval) __attribute__ ((__noreturn__));







extern int pthread_join (pthread_t __th, void **__thread_return);
# 270 "/usr/include/pthread.h" 3 4
extern int pthread_detach (pthread_t __th) __attribute__ ((__nothrow__ , __leaf__));



extern pthread_t pthread_self (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


extern int pthread_equal (pthread_t __thread1, pthread_t __thread2)
  __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));







extern int pthread_attr_init (pthread_attr_t *__attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_destroy (pthread_attr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getdetachstate (const pthread_attr_t *__attr,
     int *__detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setdetachstate (pthread_attr_t *__attr,
     int __detachstate)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getguardsize (const pthread_attr_t *__attr,
          size_t *__guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setguardsize (pthread_attr_t *__attr,
          size_t __guardsize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getschedparam (const pthread_attr_t *__restrict __attr,
           struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedparam (pthread_attr_t *__restrict __attr,
           const struct sched_param *__restrict
           __param) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_getschedpolicy (const pthread_attr_t *__restrict
     __attr, int *__restrict __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setschedpolicy (pthread_attr_t *__attr, int __policy)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getinheritsched (const pthread_attr_t *__restrict
      __attr, int *__restrict __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setinheritsched (pthread_attr_t *__attr,
      int __inherit)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getscope (const pthread_attr_t *__restrict __attr,
      int *__restrict __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_attr_setscope (pthread_attr_t *__attr, int __scope)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_attr_getstackaddr (const pthread_attr_t *__restrict
          __attr, void **__restrict __stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) __attribute__ ((__deprecated__));





extern int pthread_attr_setstackaddr (pthread_attr_t *__attr,
          void *__stackaddr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__));


extern int pthread_attr_getstacksize (const pthread_attr_t *__restrict
          __attr, size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_attr_setstacksize (pthread_attr_t *__attr,
          size_t __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_attr_getstack (const pthread_attr_t *__restrict __attr,
      void **__restrict __stackaddr,
      size_t *__restrict __stacksize)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_attr_setstack (pthread_attr_t *__attr, void *__stackaddr,
      size_t __stacksize) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 420 "/usr/include/pthread.h" 3 4
extern int pthread_setschedparam (pthread_t __target_thread, int __policy,
      const struct sched_param *__param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3)));


extern int pthread_getschedparam (pthread_t __target_thread,
      int *__restrict __policy,
      struct sched_param *__restrict __param)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));


extern int pthread_setschedprio (pthread_t __target_thread, int __prio)
     __attribute__ ((__nothrow__ , __leaf__));
# 485 "/usr/include/pthread.h" 3 4
extern int pthread_once (pthread_once_t *__once_control,
    void (*__init_routine) (void)) __attribute__ ((__nonnull__ (1, 2)));
# 497 "/usr/include/pthread.h" 3 4
extern int pthread_setcancelstate (int __state, int *__oldstate);



extern int pthread_setcanceltype (int __type, int *__oldtype);


extern int pthread_cancel (pthread_t __th);




extern void pthread_testcancel (void);




typedef struct
{
  struct
  {
    __jmp_buf __cancel_jmp_buf;
    int __mask_was_saved;
  } __cancel_jmp_buf[1];
  void *__pad[4];
} __pthread_unwind_buf_t __attribute__ ((__aligned__));
# 531 "/usr/include/pthread.h" 3 4
struct __pthread_cleanup_frame
{
  void (*__cancel_routine) (void *);
  void *__cancel_arg;
  int __do_it;
  int __cancel_type;
};
# 671 "/usr/include/pthread.h" 3 4
extern void __pthread_register_cancel (__pthread_unwind_buf_t *__buf)
     ;
# 683 "/usr/include/pthread.h" 3 4
extern void __pthread_unregister_cancel (__pthread_unwind_buf_t *__buf)
  ;
# 724 "/usr/include/pthread.h" 3 4
extern void __pthread_unwind_next (__pthread_unwind_buf_t *__buf)
     __attribute__ ((__noreturn__))

     __attribute__ ((__weak__))

     ;



struct __jmp_buf_tag;
extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask) __attribute__ ((__nothrow__));





extern int pthread_mutex_init (pthread_mutex_t *__mutex,
          const pthread_mutexattr_t *__mutexattr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_destroy (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_trylock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutex_lock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_timedlock (pthread_mutex_t *__restrict __mutex,
        const struct timespec *__restrict
        __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_unlock (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutex_getprioceiling (const pthread_mutex_t *
      __restrict __mutex,
      int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutex_setprioceiling (pthread_mutex_t *__restrict __mutex,
      int __prioceiling,
      int *__restrict __old_ceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3)));




extern int pthread_mutex_consistent (pthread_mutex_t *__mutex)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 797 "/usr/include/pthread.h" 3 4
extern int pthread_mutexattr_init (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_destroy (pthread_mutexattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getpshared (const pthread_mutexattr_t *
      __restrict __attr,
      int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setpshared (pthread_mutexattr_t *__attr,
      int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_gettype (const pthread_mutexattr_t *__restrict
          __attr, int *__restrict __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int pthread_mutexattr_settype (pthread_mutexattr_t *__attr, int __kind)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getprotocol (const pthread_mutexattr_t *
       __restrict __attr,
       int *__restrict __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_mutexattr_setprotocol (pthread_mutexattr_t *__attr,
       int __protocol)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *
          __restrict __attr,
          int *__restrict __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_mutexattr_setprioceiling (pthread_mutexattr_t *__attr,
          int __prioceiling)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_mutexattr_getrobust (const pthread_mutexattr_t *__attr,
     int *__robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));







extern int pthread_mutexattr_setrobust (pthread_mutexattr_t *__attr,
     int __robustness)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 879 "/usr/include/pthread.h" 3 4
extern int pthread_rwlock_init (pthread_rwlock_t *__restrict __rwlock,
    const pthread_rwlockattr_t *__restrict
    __attr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_destroy (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_rdlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_tryrdlock (pthread_rwlock_t *__rwlock)
  __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedrdlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_wrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlock_trywrlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_rwlock_timedwrlock (pthread_rwlock_t *__restrict __rwlock,
           const struct timespec *__restrict
           __abstime) __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1, 2)));



extern int pthread_rwlock_unlock (pthread_rwlock_t *__rwlock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));





extern int pthread_rwlockattr_init (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_destroy (pthread_rwlockattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setpshared (pthread_rwlockattr_t *__attr,
       int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_rwlockattr_getkind_np (const pthread_rwlockattr_t *
       __restrict __attr,
       int *__restrict __pref)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_rwlockattr_setkind_np (pthread_rwlockattr_t *__attr,
       int __pref) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







extern int pthread_cond_init (pthread_cond_t *__restrict __cond,
         const pthread_condattr_t *__restrict __cond_attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_destroy (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_signal (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_cond_broadcast (pthread_cond_t *__cond)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_cond_wait (pthread_cond_t *__restrict __cond,
         pthread_mutex_t *__restrict __mutex)
     __attribute__ ((__nonnull__ (1, 2)));
# 991 "/usr/include/pthread.h" 3 4
extern int pthread_cond_timedwait (pthread_cond_t *__restrict __cond,
       pthread_mutex_t *__restrict __mutex,
       const struct timespec *__restrict __abstime)
     __attribute__ ((__nonnull__ (1, 2, 3)));




extern int pthread_condattr_init (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_destroy (pthread_condattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_condattr_getpshared (const pthread_condattr_t *
     __restrict __attr,
     int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setpshared (pthread_condattr_t *__attr,
     int __pshared) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_condattr_getclock (const pthread_condattr_t *
          __restrict __attr,
          __clockid_t *__restrict __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_condattr_setclock (pthread_condattr_t *__attr,
          __clockid_t __clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1035 "/usr/include/pthread.h" 3 4
extern int pthread_spin_init (pthread_spinlock_t *__lock, int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_destroy (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_lock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_trylock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_spin_unlock (pthread_spinlock_t *__lock)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));






extern int pthread_barrier_init (pthread_barrier_t *__restrict __barrier,
     const pthread_barrierattr_t *__restrict
     __attr, unsigned int __count)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_destroy (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrier_wait (pthread_barrier_t *__barrier)
     __attribute__ ((__nothrow__)) __attribute__ ((__nonnull__ (1)));



extern int pthread_barrierattr_init (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_destroy (pthread_barrierattr_t *__attr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_barrierattr_getpshared (const pthread_barrierattr_t *
        __restrict __attr,
        int *__restrict __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int pthread_barrierattr_setpshared (pthread_barrierattr_t *__attr,
        int __pshared)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 1102 "/usr/include/pthread.h" 3 4
extern int pthread_key_create (pthread_key_t *__key,
          void (*__destr_function) (void *))
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int pthread_key_delete (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern void *pthread_getspecific (pthread_key_t __key) __attribute__ ((__nothrow__ , __leaf__));


extern int pthread_setspecific (pthread_key_t __key,
    const void *__pointer) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int pthread_getcpuclockid (pthread_t __thread_id,
      __clockid_t *__clock_id)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));
# 1136 "/usr/include/pthread.h" 3 4
extern int pthread_atfork (void (*__prepare) (void),
      void (*__parent) (void),
      void (*__child) (void)) __attribute__ ((__nothrow__ , __leaf__));




extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) pthread_equal (pthread_t __thread1, pthread_t __thread2)
{
  return __thread1 == __thread2;
}



# 124 "/usr/include/glib-2.0/glib/deprecated/gthread.h" 2




typedef struct
{
  GMutex *mutex;


  pthread_mutex_t unused;

} GStaticMutex;
# 144 "/usr/include/glib-2.0/glib/deprecated/gthread.h"
__attribute__((__deprecated__("Use '" "g_mutex_init" "' instead"))) extern
void g_static_mutex_init (GStaticMutex *mutex);
__attribute__((__deprecated__("Use '" "g_mutex_clear" "' instead"))) extern
void g_static_mutex_free (GStaticMutex *mutex);
__attribute__((__deprecated__("Use '" "GMutex" "' instead"))) extern
GMutex *g_static_mutex_get_mutex_impl (GStaticMutex *mutex);

typedef struct _GStaticRecMutex GStaticRecMutex;
struct _GStaticRecMutex
{

  GStaticMutex mutex;
  guint depth;


  union {



    pthread_t owner;

    gdouble dummy;
  } unused;
};


__attribute__((__deprecated__("Use '" "g_rec_mutex_init" "' instead"))) extern
void g_static_rec_mutex_init (GStaticRecMutex *mutex);

__attribute__((__deprecated__("Use '" "g_rec_mutex_lock" "' instead"))) extern
void g_static_rec_mutex_lock (GStaticRecMutex *mutex);

__attribute__((__deprecated__("Use '" "g_rec_mutex_try_lock" "' instead"))) extern
gboolean g_static_rec_mutex_trylock (GStaticRecMutex *mutex);

__attribute__((__deprecated__("Use '" "g_rec_mutex_unlock" "' instead"))) extern
void g_static_rec_mutex_unlock (GStaticRecMutex *mutex);

__attribute__((__deprecated__)) extern
void g_static_rec_mutex_lock_full (GStaticRecMutex *mutex,
                                         guint depth);

__attribute__((__deprecated__)) extern
guint g_static_rec_mutex_unlock_full (GStaticRecMutex *mutex);

__attribute__((__deprecated__("Use '" "g_rec_mutex_free" "' instead"))) extern
void g_static_rec_mutex_free (GStaticRecMutex *mutex);

typedef struct _GStaticRWLock GStaticRWLock;
struct _GStaticRWLock
{

  GStaticMutex mutex;
  GCond *read_cond;
  GCond *write_cond;
  guint read_counter;
  gboolean have_writer;
  guint want_to_read;
  guint want_to_write;
};



__attribute__((__deprecated__("Use '" "g_rw_lock_init" "' instead"))) extern
void g_static_rw_lock_init (GStaticRWLock *lock);

__attribute__((__deprecated__("Use '" "g_rw_lock_reader_lock" "' instead"))) extern
void g_static_rw_lock_reader_lock (GStaticRWLock *lock);

__attribute__((__deprecated__("Use '" "g_rw_lock_reader_trylock" "' instead"))) extern
gboolean g_static_rw_lock_reader_trylock (GStaticRWLock *lock);

__attribute__((__deprecated__("Use '" "g_rw_lock_reader_unlock" "' instead"))) extern
void g_static_rw_lock_reader_unlock (GStaticRWLock *lock);

__attribute__((__deprecated__("Use '" "g_rw_lock_writer_lock" "' instead"))) extern
void g_static_rw_lock_writer_lock (GStaticRWLock *lock);

__attribute__((__deprecated__("Use '" "g_rw_lock_writer_trylock" "' instead"))) extern
gboolean g_static_rw_lock_writer_trylock (GStaticRWLock *lock);

__attribute__((__deprecated__("Use '" "g_rw_lock_writer_unlock" "' instead"))) extern
void g_static_rw_lock_writer_unlock (GStaticRWLock *lock);

__attribute__((__deprecated__("Use '" "g_rw_lock_free" "' instead"))) extern
void g_static_rw_lock_free (GStaticRWLock *lock);

__attribute__((__deprecated__)) extern
GPrivate * g_private_new (GDestroyNotify notify);

typedef struct _GStaticPrivate GStaticPrivate;
struct _GStaticPrivate
{

  guint index;
};


__attribute__((__deprecated__)) extern
void g_static_private_init (GStaticPrivate *private_key);

__attribute__((__deprecated__("Use '" "g_private_get" "' instead"))) extern
gpointer g_static_private_get (GStaticPrivate *private_key);

__attribute__((__deprecated__("Use '" "g_private_set" "' instead"))) extern
void g_static_private_set (GStaticPrivate *private_key,
                                          gpointer data,
                                          GDestroyNotify notify);

__attribute__((__deprecated__)) extern
void g_static_private_free (GStaticPrivate *private_key);

__attribute__((__deprecated__)) extern
gboolean g_once_init_enter_impl (volatile gsize *location);

__attribute__((__deprecated__)) extern
void g_thread_init (gpointer vtable);
__attribute__((__deprecated__)) extern
void g_thread_init_with_errorcheck_mutexes (gpointer vtable);

__attribute__((__deprecated__)) extern
gboolean g_thread_get_initialized (void);

extern gboolean g_threads_got_initialized;



__attribute__((__deprecated__)) extern
GMutex * g_mutex_new (void);
__attribute__((__deprecated__)) extern
void g_mutex_free (GMutex *mutex);
__attribute__((__deprecated__)) extern
GCond * g_cond_new (void);
__attribute__((__deprecated__)) extern
void g_cond_free (GCond *cond);
__attribute__((__deprecated__)) extern
gboolean g_cond_timed_wait (GCond *cond,
                                         GMutex *mutex,
                                         GTimeVal *timeval);


# 110 "/usr/include/glib-2.0/glib.h" 2
# 31 "src/bnet.h" 2
# 1 "/usr/include/unistd.h" 1 3 4
# 27 "/usr/include/unistd.h" 3 4

# 202 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/bits/posix_opt.h" 1 3 4
# 203 "/usr/include/unistd.h" 2 3 4



# 1 "/usr/include/bits/environments.h" 1 3 4
# 22 "/usr/include/bits/environments.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/environments.h" 2 3 4
# 207 "/usr/include/unistd.h" 2 3 4
# 220 "/usr/include/unistd.h" 3 4
typedef __ssize_t ssize_t;





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 227 "/usr/include/unistd.h" 2 3 4





typedef __gid_t gid_t;
# 243 "/usr/include/unistd.h" 3 4
typedef __off_t off_t;
# 255 "/usr/include/unistd.h" 3 4
typedef __useconds_t useconds_t;
# 267 "/usr/include/unistd.h" 3 4
typedef __intptr_t intptr_t;






typedef __socklen_t socklen_t;
# 287 "/usr/include/unistd.h" 3 4
extern int access (const char *__name, int __type) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 304 "/usr/include/unistd.h" 3 4
extern int faccessat (int __fd, const char *__file, int __type, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;
# 334 "/usr/include/unistd.h" 3 4
extern __off_t lseek (int __fd, __off_t __offset, int __whence) __attribute__ ((__nothrow__ , __leaf__));
# 353 "/usr/include/unistd.h" 3 4
extern int close (int __fd);






extern ssize_t read (int __fd, void *__buf, size_t __nbytes) ;





extern ssize_t write (int __fd, const void *__buf, size_t __n) ;
# 376 "/usr/include/unistd.h" 3 4
extern ssize_t pread (int __fd, void *__buf, size_t __nbytes,
        __off_t __offset) ;






extern ssize_t pwrite (int __fd, const void *__buf, size_t __n,
         __off_t __offset) ;
# 417 "/usr/include/unistd.h" 3 4
extern int pipe (int __pipedes[2]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 432 "/usr/include/unistd.h" 3 4
extern unsigned int alarm (unsigned int __seconds) __attribute__ ((__nothrow__ , __leaf__));
# 444 "/usr/include/unistd.h" 3 4
extern unsigned int sleep (unsigned int __seconds);







extern __useconds_t ualarm (__useconds_t __value, __useconds_t __interval)
     __attribute__ ((__nothrow__ , __leaf__));






extern int usleep (__useconds_t __useconds);
# 469 "/usr/include/unistd.h" 3 4
extern int pause (void);



extern int chown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchown (int __fd, __uid_t __owner, __gid_t __group) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int lchown (const char *__file, __uid_t __owner, __gid_t __group)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;






extern int fchownat (int __fd, const char *__file, __uid_t __owner,
       __gid_t __group, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int chdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int fchdir (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;
# 511 "/usr/include/unistd.h" 3 4
extern char *getcwd (char *__buf, size_t __size) __attribute__ ((__nothrow__ , __leaf__)) ;
# 525 "/usr/include/unistd.h" 3 4
extern char *getwd (char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) __attribute__ ((__deprecated__)) ;




extern int dup (int __fd) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int dup2 (int __fd, int __fd2) __attribute__ ((__nothrow__ , __leaf__));
# 543 "/usr/include/unistd.h" 3 4
extern char **__environ;







extern int execve (const char *__path, char *const __argv[],
     char *const __envp[]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int fexecve (int __fd, char *const __argv[], char *const __envp[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern int execv (const char *__path, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execle (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execl (const char *__path, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern int execvp (const char *__file, char *const __argv[])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern int execlp (const char *__file, const char *__arg, ...)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 598 "/usr/include/unistd.h" 3 4
extern int nice (int __inc) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void _exit (int __status) __attribute__ ((__noreturn__));





# 1 "/usr/include/bits/confname.h" 1 3 4
# 25 "/usr/include/bits/confname.h" 3 4
enum
  {
    _PC_LINK_MAX,

    _PC_MAX_CANON,

    _PC_MAX_INPUT,

    _PC_NAME_MAX,

    _PC_PATH_MAX,

    _PC_PIPE_BUF,

    _PC_CHOWN_RESTRICTED,

    _PC_NO_TRUNC,

    _PC_VDISABLE,

    _PC_SYNC_IO,

    _PC_ASYNC_IO,

    _PC_PRIO_IO,

    _PC_SOCK_MAXBUF,

    _PC_FILESIZEBITS,

    _PC_REC_INCR_XFER_SIZE,

    _PC_REC_MAX_XFER_SIZE,

    _PC_REC_MIN_XFER_SIZE,

    _PC_REC_XFER_ALIGN,

    _PC_ALLOC_SIZE_MIN,

    _PC_SYMLINK_MAX,

    _PC_2_SYMLINKS

  };


enum
  {
    _SC_ARG_MAX,

    _SC_CHILD_MAX,

    _SC_CLK_TCK,

    _SC_NGROUPS_MAX,

    _SC_OPEN_MAX,

    _SC_STREAM_MAX,

    _SC_TZNAME_MAX,

    _SC_JOB_CONTROL,

    _SC_SAVED_IDS,

    _SC_REALTIME_SIGNALS,

    _SC_PRIORITY_SCHEDULING,

    _SC_TIMERS,

    _SC_ASYNCHRONOUS_IO,

    _SC_PRIORITIZED_IO,

    _SC_SYNCHRONIZED_IO,

    _SC_FSYNC,

    _SC_MAPPED_FILES,

    _SC_MEMLOCK,

    _SC_MEMLOCK_RANGE,

    _SC_MEMORY_PROTECTION,

    _SC_MESSAGE_PASSING,

    _SC_SEMAPHORES,

    _SC_SHARED_MEMORY_OBJECTS,

    _SC_AIO_LISTIO_MAX,

    _SC_AIO_MAX,

    _SC_AIO_PRIO_DELTA_MAX,

    _SC_DELAYTIMER_MAX,

    _SC_MQ_OPEN_MAX,

    _SC_MQ_PRIO_MAX,

    _SC_VERSION,

    _SC_PAGESIZE,


    _SC_RTSIG_MAX,

    _SC_SEM_NSEMS_MAX,

    _SC_SEM_VALUE_MAX,

    _SC_SIGQUEUE_MAX,

    _SC_TIMER_MAX,




    _SC_BC_BASE_MAX,

    _SC_BC_DIM_MAX,

    _SC_BC_SCALE_MAX,

    _SC_BC_STRING_MAX,

    _SC_COLL_WEIGHTS_MAX,

    _SC_EQUIV_CLASS_MAX,

    _SC_EXPR_NEST_MAX,

    _SC_LINE_MAX,

    _SC_RE_DUP_MAX,

    _SC_CHARCLASS_NAME_MAX,


    _SC_2_VERSION,

    _SC_2_C_BIND,

    _SC_2_C_DEV,

    _SC_2_FORT_DEV,

    _SC_2_FORT_RUN,

    _SC_2_SW_DEV,

    _SC_2_LOCALEDEF,


    _SC_PII,

    _SC_PII_XTI,

    _SC_PII_SOCKET,

    _SC_PII_INTERNET,

    _SC_PII_OSI,

    _SC_POLL,

    _SC_SELECT,

    _SC_UIO_MAXIOV,

    _SC_IOV_MAX = _SC_UIO_MAXIOV,

    _SC_PII_INTERNET_STREAM,

    _SC_PII_INTERNET_DGRAM,

    _SC_PII_OSI_COTS,

    _SC_PII_OSI_CLTS,

    _SC_PII_OSI_M,

    _SC_T_IOV_MAX,



    _SC_THREADS,

    _SC_THREAD_SAFE_FUNCTIONS,

    _SC_GETGR_R_SIZE_MAX,

    _SC_GETPW_R_SIZE_MAX,

    _SC_LOGIN_NAME_MAX,

    _SC_TTY_NAME_MAX,

    _SC_THREAD_DESTRUCTOR_ITERATIONS,

    _SC_THREAD_KEYS_MAX,

    _SC_THREAD_STACK_MIN,

    _SC_THREAD_THREADS_MAX,

    _SC_THREAD_ATTR_STACKADDR,

    _SC_THREAD_ATTR_STACKSIZE,

    _SC_THREAD_PRIORITY_SCHEDULING,

    _SC_THREAD_PRIO_INHERIT,

    _SC_THREAD_PRIO_PROTECT,

    _SC_THREAD_PROCESS_SHARED,


    _SC_NPROCESSORS_CONF,

    _SC_NPROCESSORS_ONLN,

    _SC_PHYS_PAGES,

    _SC_AVPHYS_PAGES,

    _SC_ATEXIT_MAX,

    _SC_PASS_MAX,


    _SC_XOPEN_VERSION,

    _SC_XOPEN_XCU_VERSION,

    _SC_XOPEN_UNIX,

    _SC_XOPEN_CRYPT,

    _SC_XOPEN_ENH_I18N,

    _SC_XOPEN_SHM,


    _SC_2_CHAR_TERM,

    _SC_2_C_VERSION,

    _SC_2_UPE,


    _SC_XOPEN_XPG2,

    _SC_XOPEN_XPG3,

    _SC_XOPEN_XPG4,


    _SC_CHAR_BIT,

    _SC_CHAR_MAX,

    _SC_CHAR_MIN,

    _SC_INT_MAX,

    _SC_INT_MIN,

    _SC_LONG_BIT,

    _SC_WORD_BIT,

    _SC_MB_LEN_MAX,

    _SC_NZERO,

    _SC_SSIZE_MAX,

    _SC_SCHAR_MAX,

    _SC_SCHAR_MIN,

    _SC_SHRT_MAX,

    _SC_SHRT_MIN,

    _SC_UCHAR_MAX,

    _SC_UINT_MAX,

    _SC_ULONG_MAX,

    _SC_USHRT_MAX,


    _SC_NL_ARGMAX,

    _SC_NL_LANGMAX,

    _SC_NL_MSGMAX,

    _SC_NL_NMAX,

    _SC_NL_SETMAX,

    _SC_NL_TEXTMAX,


    _SC_XBS5_ILP32_OFF32,

    _SC_XBS5_ILP32_OFFBIG,

    _SC_XBS5_LP64_OFF64,

    _SC_XBS5_LPBIG_OFFBIG,


    _SC_XOPEN_LEGACY,

    _SC_XOPEN_REALTIME,

    _SC_XOPEN_REALTIME_THREADS,


    _SC_ADVISORY_INFO,

    _SC_BARRIERS,

    _SC_BASE,

    _SC_C_LANG_SUPPORT,

    _SC_C_LANG_SUPPORT_R,

    _SC_CLOCK_SELECTION,

    _SC_CPUTIME,

    _SC_THREAD_CPUTIME,

    _SC_DEVICE_IO,

    _SC_DEVICE_SPECIFIC,

    _SC_DEVICE_SPECIFIC_R,

    _SC_FD_MGMT,

    _SC_FIFO,

    _SC_PIPE,

    _SC_FILE_ATTRIBUTES,

    _SC_FILE_LOCKING,

    _SC_FILE_SYSTEM,

    _SC_MONOTONIC_CLOCK,

    _SC_MULTI_PROCESS,

    _SC_SINGLE_PROCESS,

    _SC_NETWORKING,

    _SC_READER_WRITER_LOCKS,

    _SC_SPIN_LOCKS,

    _SC_REGEXP,

    _SC_REGEX_VERSION,

    _SC_SHELL,

    _SC_SIGNALS,

    _SC_SPAWN,

    _SC_SPORADIC_SERVER,

    _SC_THREAD_SPORADIC_SERVER,

    _SC_SYSTEM_DATABASE,

    _SC_SYSTEM_DATABASE_R,

    _SC_TIMEOUTS,

    _SC_TYPED_MEMORY_OBJECTS,

    _SC_USER_GROUPS,

    _SC_USER_GROUPS_R,

    _SC_2_PBS,

    _SC_2_PBS_ACCOUNTING,

    _SC_2_PBS_LOCATE,

    _SC_2_PBS_MESSAGE,

    _SC_2_PBS_TRACK,

    _SC_SYMLOOP_MAX,

    _SC_STREAMS,

    _SC_2_PBS_CHECKPOINT,


    _SC_V6_ILP32_OFF32,

    _SC_V6_ILP32_OFFBIG,

    _SC_V6_LP64_OFF64,

    _SC_V6_LPBIG_OFFBIG,


    _SC_HOST_NAME_MAX,

    _SC_TRACE,

    _SC_TRACE_EVENT_FILTER,

    _SC_TRACE_INHERIT,

    _SC_TRACE_LOG,


    _SC_LEVEL1_ICACHE_SIZE,

    _SC_LEVEL1_ICACHE_ASSOC,

    _SC_LEVEL1_ICACHE_LINESIZE,

    _SC_LEVEL1_DCACHE_SIZE,

    _SC_LEVEL1_DCACHE_ASSOC,

    _SC_LEVEL1_DCACHE_LINESIZE,

    _SC_LEVEL2_CACHE_SIZE,

    _SC_LEVEL2_CACHE_ASSOC,

    _SC_LEVEL2_CACHE_LINESIZE,

    _SC_LEVEL3_CACHE_SIZE,

    _SC_LEVEL3_CACHE_ASSOC,

    _SC_LEVEL3_CACHE_LINESIZE,

    _SC_LEVEL4_CACHE_SIZE,

    _SC_LEVEL4_CACHE_ASSOC,

    _SC_LEVEL4_CACHE_LINESIZE,



    _SC_IPV6 = _SC_LEVEL1_ICACHE_SIZE + 50,

    _SC_RAW_SOCKETS,


    _SC_V7_ILP32_OFF32,

    _SC_V7_ILP32_OFFBIG,

    _SC_V7_LP64_OFF64,

    _SC_V7_LPBIG_OFFBIG,


    _SC_SS_REPL_MAX,


    _SC_TRACE_EVENT_NAME_MAX,

    _SC_TRACE_NAME_MAX,

    _SC_TRACE_SYS_MAX,

    _SC_TRACE_USER_EVENT_MAX,


    _SC_XOPEN_STREAMS,


    _SC_THREAD_ROBUST_PRIO_INHERIT,

    _SC_THREAD_ROBUST_PRIO_PROTECT

  };


enum
  {
    _CS_PATH,


    _CS_V6_WIDTH_RESTRICTED_ENVS,



    _CS_GNU_LIBC_VERSION,

    _CS_GNU_LIBPTHREAD_VERSION,


    _CS_V5_WIDTH_RESTRICTED_ENVS,



    _CS_V7_WIDTH_RESTRICTED_ENVS,



    _CS_LFS_CFLAGS = 1000,

    _CS_LFS_LDFLAGS,

    _CS_LFS_LIBS,

    _CS_LFS_LINTFLAGS,

    _CS_LFS64_CFLAGS,

    _CS_LFS64_LDFLAGS,

    _CS_LFS64_LIBS,

    _CS_LFS64_LINTFLAGS,


    _CS_XBS5_ILP32_OFF32_CFLAGS = 1100,

    _CS_XBS5_ILP32_OFF32_LDFLAGS,

    _CS_XBS5_ILP32_OFF32_LIBS,

    _CS_XBS5_ILP32_OFF32_LINTFLAGS,

    _CS_XBS5_ILP32_OFFBIG_CFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LDFLAGS,

    _CS_XBS5_ILP32_OFFBIG_LIBS,

    _CS_XBS5_ILP32_OFFBIG_LINTFLAGS,

    _CS_XBS5_LP64_OFF64_CFLAGS,

    _CS_XBS5_LP64_OFF64_LDFLAGS,

    _CS_XBS5_LP64_OFF64_LIBS,

    _CS_XBS5_LP64_OFF64_LINTFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_CFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LDFLAGS,

    _CS_XBS5_LPBIG_OFFBIG_LIBS,

    _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V6_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFF32_LIBS,

    _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V6_LP64_OFF64_CFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V6_LP64_OFF64_LIBS,

    _CS_POSIX_V6_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS,


    _CS_POSIX_V7_ILP32_OFF32_CFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFF32_LIBS,

    _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_ILP32_OFFBIG_LIBS,

    _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS,

    _CS_POSIX_V7_LP64_OFF64_CFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LDFLAGS,

    _CS_POSIX_V7_LP64_OFF64_LIBS,

    _CS_POSIX_V7_LP64_OFF64_LINTFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LIBS,

    _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS,


    _CS_V6_ENV,

    _CS_V7_ENV

  };
# 610 "/usr/include/unistd.h" 2 3 4


extern long int pathconf (const char *__path, int __name)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int fpathconf (int __fd, int __name) __attribute__ ((__nothrow__ , __leaf__));


extern long int sysconf (int __name) __attribute__ ((__nothrow__ , __leaf__));



extern size_t confstr (int __name, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __pid_t getppid (void) __attribute__ ((__nothrow__ , __leaf__));




extern __pid_t getpgrp (void) __attribute__ ((__nothrow__ , __leaf__));
# 646 "/usr/include/unistd.h" 3 4
extern __pid_t __getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));

extern __pid_t getpgid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));






extern int setpgid (__pid_t __pid, __pid_t __pgid) __attribute__ ((__nothrow__ , __leaf__));
# 672 "/usr/include/unistd.h" 3 4
extern int setpgrp (void) __attribute__ ((__nothrow__ , __leaf__));
# 689 "/usr/include/unistd.h" 3 4
extern __pid_t setsid (void) __attribute__ ((__nothrow__ , __leaf__));



extern __pid_t getsid (__pid_t __pid) __attribute__ ((__nothrow__ , __leaf__));



extern __uid_t getuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __uid_t geteuid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getgid (void) __attribute__ ((__nothrow__ , __leaf__));


extern __gid_t getegid (void) __attribute__ ((__nothrow__ , __leaf__));




extern int getgroups (int __size, __gid_t __list[]) __attribute__ ((__nothrow__ , __leaf__)) ;
# 722 "/usr/include/unistd.h" 3 4
extern int setuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setreuid (__uid_t __ruid, __uid_t __euid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int seteuid (__uid_t __uid) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int setgid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setregid (__gid_t __rgid, __gid_t __egid) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int setegid (__gid_t __gid) __attribute__ ((__nothrow__ , __leaf__)) ;
# 778 "/usr/include/unistd.h" 3 4
extern __pid_t fork (void) __attribute__ ((__nothrow__));







extern __pid_t vfork (void) __attribute__ ((__nothrow__ , __leaf__));





extern char *ttyname (int __fd) __attribute__ ((__nothrow__ , __leaf__));



extern int ttyname_r (int __fd, char *__buf, size_t __buflen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2))) ;



extern int isatty (int __fd) __attribute__ ((__nothrow__ , __leaf__));





extern int ttyslot (void) __attribute__ ((__nothrow__ , __leaf__));




extern int link (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int linkat (int __fromfd, const char *__from, int __tofd,
     const char *__to, int __flags)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4))) ;




extern int symlink (const char *__from, const char *__to)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern ssize_t readlink (const char *__restrict __path,
    char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2))) ;




extern int symlinkat (const char *__from, int __tofd,
        const char *__to) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 3))) ;


extern ssize_t readlinkat (int __fd, const char *__restrict __path,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3))) ;



extern int unlink (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern int unlinkat (int __fd, const char *__name, int __flag)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern int rmdir (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern __pid_t tcgetpgrp (int __fd) __attribute__ ((__nothrow__ , __leaf__));


extern int tcsetpgrp (int __fd, __pid_t __pgrp_id) __attribute__ ((__nothrow__ , __leaf__));






extern char *getlogin (void);







extern int getlogin_r (char *__name, size_t __name_len) __attribute__ ((__nonnull__ (1)));




extern int setlogin (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 893 "/usr/include/unistd.h" 3 4
# 1 "/usr/include/getopt.h" 1 3 4
# 58 "/usr/include/getopt.h" 3 4
extern char *optarg;
# 72 "/usr/include/getopt.h" 3 4
extern int optind;




extern int opterr;



extern int optopt;
# 151 "/usr/include/getopt.h" 3 4
extern int getopt (int ___argc, char *const *___argv, const char *__shortopts)
       __attribute__ ((__nothrow__ , __leaf__));
# 894 "/usr/include/unistd.h" 2 3 4







extern int gethostname (char *__name, size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int sethostname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern int sethostid (long int __id) __attribute__ ((__nothrow__ , __leaf__)) ;





extern int getdomainname (char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
extern int setdomainname (const char *__name, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;





extern int vhangup (void) __attribute__ ((__nothrow__ , __leaf__));


extern int revoke (const char *__file) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;







extern int profil (unsigned short int *__sample_buffer, size_t __size,
     size_t __offset, unsigned int __scale)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int acct (const char *__name) __attribute__ ((__nothrow__ , __leaf__));



extern char *getusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void endusershell (void) __attribute__ ((__nothrow__ , __leaf__));
extern void setusershell (void) __attribute__ ((__nothrow__ , __leaf__));





extern int daemon (int __nochdir, int __noclose) __attribute__ ((__nothrow__ , __leaf__)) ;






extern int chroot (const char *__path) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;



extern char *getpass (const char *__prompt) __attribute__ ((__nonnull__ (1)));







extern int fsync (int __fd);
# 991 "/usr/include/unistd.h" 3 4
extern long int gethostid (void);


extern void sync (void) __attribute__ ((__nothrow__ , __leaf__));





extern int getpagesize (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




extern int getdtablesize (void) __attribute__ ((__nothrow__ , __leaf__));
# 1015 "/usr/include/unistd.h" 3 4
extern int truncate (const char *__file, __off_t __length)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 1038 "/usr/include/unistd.h" 3 4
extern int ftruncate (int __fd, __off_t __length) __attribute__ ((__nothrow__ , __leaf__)) ;
# 1059 "/usr/include/unistd.h" 3 4
extern int brk (void *__addr) __attribute__ ((__nothrow__ , __leaf__)) ;





extern void *sbrk (intptr_t __delta) __attribute__ ((__nothrow__ , __leaf__));
# 1080 "/usr/include/unistd.h" 3 4
extern long int syscall (long int __sysno, ...) __attribute__ ((__nothrow__ , __leaf__));
# 1103 "/usr/include/unistd.h" 3 4
extern int lockf (int __fd, int __cmd, __off_t __len) ;
# 1134 "/usr/include/unistd.h" 3 4
extern int fdatasync (int __fildes);
# 1172 "/usr/include/unistd.h" 3 4

# 32 "src/bnet.h" 2
# 1 "/usr/include/string.h" 1 3 4
# 27 "/usr/include/string.h" 3 4





# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 33 "/usr/include/string.h" 2 3 4









extern void *memcpy (void *__restrict __dest, const void *__restrict __src,
       size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void *memmove (void *__dest, const void *__src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern void *memccpy (void *__restrict __dest, const void *__restrict __src,
        int __c, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));





extern void *memset (void *__s, int __c, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int memcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 92 "/usr/include/string.h" 3 4
extern void *memchr (const void *__s, int __c, size_t __n)
      __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 123 "/usr/include/string.h" 3 4


extern char *strcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern char *strcat (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern char *strncat (char *__restrict __dest, const char *__restrict __src,
        size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern int strncmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strcoll (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));

extern size_t strxfrm (char *__restrict __dest,
         const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

# 162 "/usr/include/string.h" 3 4
extern int strcoll_l (const char *__s1, const char *__s2, __locale_t __l)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2, 3)));

extern size_t strxfrm_l (char *__dest, const char *__src, size_t __n,
    __locale_t __l) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));





extern char *strdup (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));






extern char *strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) __attribute__ ((__nonnull__ (1)));
# 207 "/usr/include/string.h" 3 4

# 232 "/usr/include/string.h" 3 4
extern char *strchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 259 "/usr/include/string.h" 3 4
extern char *strrchr (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));


# 278 "/usr/include/string.h" 3 4



extern size_t strcspn (const char *__s, const char *__reject)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern size_t strspn (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 311 "/usr/include/string.h" 3 4
extern char *strpbrk (const char *__s, const char *__accept)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 338 "/usr/include/string.h" 3 4
extern char *strstr (const char *__haystack, const char *__needle)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strtok (char *__restrict __s, const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));




extern char *__strtok_r (char *__restrict __s,
    const char *__restrict __delim,
    char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));

extern char *strtok_r (char *__restrict __s, const char *__restrict __delim,
         char **__restrict __save_ptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 3)));
# 393 "/usr/include/string.h" 3 4


extern size_t strlen (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern size_t strnlen (const char *__string, size_t __maxlen)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));





extern char *strerror (int __errnum) __attribute__ ((__nothrow__ , __leaf__));

# 423 "/usr/include/string.h" 3 4
extern int strerror_r (int __errnum, char *__buf, size_t __buflen) __asm__ ("" "__xpg_strerror_r") __attribute__ ((__nothrow__ , __leaf__))

                        __attribute__ ((__nonnull__ (2)));
# 441 "/usr/include/string.h" 3 4
extern char *strerror_l (int __errnum, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));





extern void __bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));



extern void bcopy (const void *__src, void *__dest, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern void bzero (void *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern int bcmp (const void *__s1, const void *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 485 "/usr/include/string.h" 3 4
extern char *index (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));
# 513 "/usr/include/string.h" 3 4
extern char *rindex (const char *__s, int __c)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1)));




extern int ffs (int __i) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 532 "/usr/include/string.h" 3 4
extern int strcasecmp (const char *__s1, const char *__s2)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));


extern int strncasecmp (const char *__s1, const char *__s2, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1, 2)));
# 555 "/usr/include/string.h" 3 4
extern char *strsep (char **__restrict __stringp,
       const char *__restrict __delim)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));




extern char *strsignal (int __sig) __attribute__ ((__nothrow__ , __leaf__));


extern char *__stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpcpy (char *__restrict __dest, const char *__restrict __src)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));



extern char *__stpncpy (char *__restrict __dest,
   const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern char *stpncpy (char *__restrict __dest,
        const char *__restrict __src, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 630 "/usr/include/string.h" 3 4
# 1 "/usr/include/bits/string.h" 1 3 4
# 631 "/usr/include/string.h" 2 3 4


# 1 "/usr/include/bits/string2.h" 1 3 4
# 393 "/usr/include/bits/string2.h" 3 4
extern void *__rawmemchr (const void *__s, int __c);
# 968 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strcspn_c1 (const char *__s, int __reject);
extern __inline size_t
__strcspn_c1 (const char *__s, int __reject)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c2 (const char *__s, int __reject1,
         int __reject2);
extern __inline size_t
__strcspn_c2 (const char *__s, int __reject1, int __reject2)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2)
    ++__result;
  return __result;
}

extern __inline size_t __strcspn_c3 (const char *__s, int __reject1,
         int __reject2, int __reject3);
extern __inline size_t
__strcspn_c3 (const char *__s, int __reject1, int __reject2,
       int __reject3)
{
  register size_t __result = 0;
  while (__s[__result] != '\0' && __s[__result] != __reject1
  && __s[__result] != __reject2 && __s[__result] != __reject3)
    ++__result;
  return __result;
}
# 1044 "/usr/include/bits/string2.h" 3 4
extern __inline size_t __strspn_c1 (const char *__s, int __accept);
extern __inline size_t
__strspn_c1 (const char *__s, int __accept)
{
  register size_t __result = 0;

  while (__s[__result] == __accept)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline size_t
__strspn_c2 (const char *__s, int __accept1, int __accept2)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2)
    ++__result;
  return __result;
}

extern __inline size_t __strspn_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline size_t
__strspn_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{
  register size_t __result = 0;

  while (__s[__result] == __accept1 || __s[__result] == __accept2
  || __s[__result] == __accept3)
    ++__result;
  return __result;
}
# 1120 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strpbrk_c2 (const char *__s, int __accept1,
        int __accept2);
extern __inline char *
__strpbrk_c2 (const char *__s, int __accept1, int __accept2)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}

extern __inline char *__strpbrk_c3 (const char *__s, int __accept1,
        int __accept2, int __accept3);
extern __inline char *
__strpbrk_c3 (const char *__s, int __accept1, int __accept2, int __accept3)
{

  while (*__s != '\0' && *__s != __accept1 && *__s != __accept2
  && *__s != __accept3)
    ++__s;
  return *__s == '\0' ? ((void *)0) : (char *) (size_t) __s;
}
# 1170 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strtok_r_1c (char *__s, char __sep, char **__nextp);
extern __inline char *
__strtok_r_1c (char *__s, char __sep, char **__nextp)
{
  char *__result;
  if (__s == ((void *)0))
    __s = *__nextp;
  while (*__s == __sep)
    ++__s;
  __result = ((void *)0);
  if (*__s != '\0')
    {
      __result = __s++;
      while (*__s != '\0')
 if (*__s++ == __sep)
   {
     __s[-1] = '\0';
     break;
   }
    }
  *__nextp = __s;
  return __result;
}
# 1202 "/usr/include/bits/string2.h" 3 4
extern char *__strsep_g (char **__stringp, const char *__delim);
# 1220 "/usr/include/bits/string2.h" 3 4
extern __inline char *__strsep_1c (char **__s, char __reject);
extern __inline char *
__strsep_1c (char **__s, char __reject)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0) && (*__s = (__extension__ (__builtin_constant_p (__reject) && !__builtin_constant_p (__retval) && (__reject) == '\0' ? (char *) __rawmemchr (__retval, __reject) : __builtin_strchr (__retval, __reject)))) != ((void *)0))
    *(*__s)++ = '\0';
  return __retval;
}

extern __inline char *__strsep_2c (char **__s, char __reject1, char __reject2);
extern __inline char *
__strsep_2c (char **__s, char __reject1, char __reject2)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}

extern __inline char *__strsep_3c (char **__s, char __reject1, char __reject2,
       char __reject3);
extern __inline char *
__strsep_3c (char **__s, char __reject1, char __reject2, char __reject3)
{
  register char *__retval = *__s;
  if (__retval != ((void *)0))
    {
      register char *__cp = __retval;
      while (1)
 {
   if (*__cp == '\0')
     {
       __cp = ((void *)0);
   break;
     }
   if (*__cp == __reject1 || *__cp == __reject2 || *__cp == __reject3)
     {
       *__cp++ = '\0';
       break;
     }
   ++__cp;
 }
      *__s = __cp;
    }
  return __retval;
}
# 1296 "/usr/include/bits/string2.h" 3 4
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4


# 463 "/usr/include/stdlib.h" 3 4


extern void *malloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

extern void *calloc (size_t __nmemb, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;

# 964 "/usr/include/stdlib.h" 3 4

# 1297 "/usr/include/bits/string2.h" 2 3 4




extern char *__strdup (const char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 1320 "/usr/include/bits/string2.h" 3 4
extern char *__strndup (const char *__string, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__));
# 634 "/usr/include/string.h" 2 3 4
# 642 "/usr/include/string.h" 3 4

# 33 "src/bnet.h" 2
# 1 "/usr/include/stdlib.h" 1 3 4
# 32 "/usr/include/stdlib.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 33 "/usr/include/stdlib.h" 2 3 4








# 1 "/usr/include/bits/waitflags.h" 1 3 4
# 42 "/usr/include/stdlib.h" 2 3 4
# 1 "/usr/include/bits/waitstatus.h" 1 3 4
# 66 "/usr/include/bits/waitstatus.h" 3 4
union wait
  {
    int w_status;
    struct
      {

 unsigned int __w_termsig:7;
 unsigned int __w_coredump:1;
 unsigned int __w_retcode:8;
 unsigned int:16;







      } __wait_terminated;
    struct
      {

 unsigned int __w_stopval:8;
 unsigned int __w_stopsig:8;
 unsigned int:16;






      } __wait_stopped;
  };
# 43 "/usr/include/stdlib.h" 2 3 4
# 67 "/usr/include/stdlib.h" 3 4
typedef union
  {
    union wait *__uptr;
    int *__iptr;
  } __WAIT_STATUS __attribute__ ((__transparent_union__));
# 95 "/usr/include/stdlib.h" 3 4


typedef struct
  {
    int quot;
    int rem;
  } div_t;



typedef struct
  {
    long int quot;
    long int rem;
  } ldiv_t;







__extension__ typedef struct
  {
    long long int quot;
    long long int rem;
  } lldiv_t;


# 139 "/usr/include/stdlib.h" 3 4
extern size_t __ctype_get_mb_cur_max (void) __attribute__ ((__nothrow__ , __leaf__)) ;




extern double atof (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern int atoi (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;

extern long int atol (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





__extension__ extern long long int atoll (const char *__nptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;





extern double strtod (const char *__restrict __nptr,
        char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern float strtof (const char *__restrict __nptr,
       char **__restrict __endptr) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern long double strtold (const char *__restrict __nptr,
       char **__restrict __endptr)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern long int strtol (const char *__restrict __nptr,
   char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

extern unsigned long int strtoul (const char *__restrict __nptr,
      char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));




__extension__
extern long long int strtoq (const char *__restrict __nptr,
        char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtouq (const char *__restrict __nptr,
           char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





__extension__
extern long long int strtoll (const char *__restrict __nptr,
         char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

__extension__
extern unsigned long long int strtoull (const char *__restrict __nptr,
     char **__restrict __endptr, int __base)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));

# 276 "/usr/include/stdlib.h" 3 4

extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) atoi (const char *__nptr)
{
  return (int) strtol (__nptr, (char **) ((void *)0), 10);
}
extern __inline long int
__attribute__ ((__nothrow__ , __leaf__)) atol (const char *__nptr)
{
  return strtol (__nptr, (char **) ((void *)0), 10);
}




__extension__ extern __inline long long int
__attribute__ ((__nothrow__ , __leaf__)) atoll (const char *__nptr)
{
  return strtoll (__nptr, (char **) ((void *)0), 10);
}

# 305 "/usr/include/stdlib.h" 3 4
extern char *l64a (long int __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern long int a64l (const char *__s)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__pure__)) __attribute__ ((__nonnull__ (1))) ;




# 1 "/usr/include/sys/types.h" 1 3 4
# 27 "/usr/include/sys/types.h" 3 4






typedef __u_char u_char;
typedef __u_short u_short;
typedef __u_int u_int;
typedef __u_long u_long;
typedef __quad_t quad_t;
typedef __u_quad_t u_quad_t;
typedef __fsid_t fsid_t;




typedef __loff_t loff_t;



typedef __ino_t ino_t;
# 60 "/usr/include/sys/types.h" 3 4
typedef __dev_t dev_t;
# 70 "/usr/include/sys/types.h" 3 4
typedef __mode_t mode_t;




typedef __nlink_t nlink_t;
# 104 "/usr/include/sys/types.h" 3 4
typedef __id_t id_t;
# 115 "/usr/include/sys/types.h" 3 4
typedef __daddr_t daddr_t;
typedef __caddr_t caddr_t;





typedef __key_t key_t;
# 146 "/usr/include/sys/types.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 147 "/usr/include/sys/types.h" 2 3 4



typedef unsigned long int ulong;
typedef unsigned short int ushort;
typedef unsigned int uint;
# 194 "/usr/include/sys/types.h" 3 4
typedef int int8_t __attribute__ ((__mode__ (__QI__)));
typedef int int16_t __attribute__ ((__mode__ (__HI__)));
typedef int int32_t __attribute__ ((__mode__ (__SI__)));
typedef int int64_t __attribute__ ((__mode__ (__DI__)));


typedef unsigned int u_int8_t __attribute__ ((__mode__ (__QI__)));
typedef unsigned int u_int16_t __attribute__ ((__mode__ (__HI__)));
typedef unsigned int u_int32_t __attribute__ ((__mode__ (__SI__)));
typedef unsigned int u_int64_t __attribute__ ((__mode__ (__DI__)));

typedef int register_t __attribute__ ((__mode__ (__word__)));
# 219 "/usr/include/sys/types.h" 3 4
# 1 "/usr/include/sys/select.h" 1 3 4
# 30 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/select.h" 1 3 4
# 22 "/usr/include/bits/select.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/select.h" 2 3 4
# 31 "/usr/include/sys/select.h" 2 3 4


# 1 "/usr/include/bits/sigset.h" 1 3 4
# 34 "/usr/include/sys/select.h" 2 3 4
# 45 "/usr/include/sys/select.h" 3 4
# 1 "/usr/include/bits/time.h" 1 3 4
# 30 "/usr/include/bits/time.h" 3 4
struct timeval
  {
    __time_t tv_sec;
    __suseconds_t tv_usec;
  };
# 46 "/usr/include/sys/select.h" 2 3 4


typedef __suseconds_t suseconds_t;





typedef long int __fd_mask;
# 64 "/usr/include/sys/select.h" 3 4
typedef struct
  {






    __fd_mask __fds_bits[1024 / (8 * (int) sizeof (__fd_mask))];


  } fd_set;






typedef __fd_mask fd_mask;
# 96 "/usr/include/sys/select.h" 3 4

# 106 "/usr/include/sys/select.h" 3 4
extern int select (int __nfds, fd_set *__restrict __readfds,
     fd_set *__restrict __writefds,
     fd_set *__restrict __exceptfds,
     struct timeval *__restrict __timeout);
# 118 "/usr/include/sys/select.h" 3 4
extern int pselect (int __nfds, fd_set *__restrict __readfds,
      fd_set *__restrict __writefds,
      fd_set *__restrict __exceptfds,
      const struct timespec *__restrict __timeout,
      const __sigset_t *__restrict __sigmask);
# 131 "/usr/include/sys/select.h" 3 4

# 220 "/usr/include/sys/types.h" 2 3 4


# 1 "/usr/include/sys/sysmacros.h" 1 3 4
# 29 "/usr/include/sys/sysmacros.h" 3 4


__extension__
extern unsigned int gnu_dev_major (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned int gnu_dev_minor (unsigned long long int __dev)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
__extension__
extern unsigned long long int gnu_dev_makedev (unsigned int __major,
            unsigned int __minor)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));


__extension__ extern __inline __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_major (unsigned long long int __dev)
{
  return ((__dev >> 8) & 0xfff) | ((unsigned int) (__dev >> 32) & ~0xfff);
}

__extension__ extern __inline __attribute__ ((__const__)) unsigned int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_minor (unsigned long long int __dev)
{
  return (__dev & 0xff) | ((unsigned int) (__dev >> 12) & ~0xff);
}

__extension__ extern __inline __attribute__ ((__const__)) unsigned long long int
__attribute__ ((__nothrow__ , __leaf__)) gnu_dev_makedev (unsigned int __major, unsigned int __minor)
{
  return ((__minor & 0xff) | ((__major & 0xfff) << 8)
   | (((unsigned long long int) (__minor & ~0xff)) << 12)
   | (((unsigned long long int) (__major & ~0xfff)) << 32));
}


# 223 "/usr/include/sys/types.h" 2 3 4





typedef __blksize_t blksize_t;






typedef __blkcnt_t blkcnt_t;



typedef __fsblkcnt_t fsblkcnt_t;



typedef __fsfilcnt_t fsfilcnt_t;
# 273 "/usr/include/sys/types.h" 3 4

# 315 "/usr/include/stdlib.h" 2 3 4






extern long int random (void) __attribute__ ((__nothrow__ , __leaf__));


extern void srandom (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));





extern char *initstate (unsigned int __seed, char *__statebuf,
   size_t __statelen) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));



extern char *setstate (char *__statebuf) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));







struct random_data
  {
    int32_t *fptr;
    int32_t *rptr;
    int32_t *state;
    int rand_type;
    int rand_deg;
    int rand_sep;
    int32_t *end_ptr;
  };

extern int random_r (struct random_data *__restrict __buf,
       int32_t *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int srandom_r (unsigned int __seed, struct random_data *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int initstate_r (unsigned int __seed, char *__restrict __statebuf,
   size_t __statelen,
   struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2, 4)));

extern int setstate_r (char *__restrict __statebuf,
         struct random_data *__restrict __buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));






extern int rand (void) __attribute__ ((__nothrow__ , __leaf__));

extern void srand (unsigned int __seed) __attribute__ ((__nothrow__ , __leaf__));




extern int rand_r (unsigned int *__seed) __attribute__ ((__nothrow__ , __leaf__));







extern double drand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern double erand48 (unsigned short int __xsubi[3]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int lrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int nrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern long int mrand48 (void) __attribute__ ((__nothrow__ , __leaf__));
extern long int jrand48 (unsigned short int __xsubi[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


extern void srand48 (long int __seedval) __attribute__ ((__nothrow__ , __leaf__));
extern unsigned short int *seed48 (unsigned short int __seed16v[3])
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
extern void lcong48 (unsigned short int __param[7]) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





struct drand48_data
  {
    unsigned short int __x[3];
    unsigned short int __old_x[3];
    unsigned short int __c;
    unsigned short int __init;
    unsigned long long int __a;
  };


extern int drand48_r (struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int erand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        double *__restrict __result) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int lrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int nrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int mrand48_r (struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
extern int jrand48_r (unsigned short int __xsubi[3],
        struct drand48_data *__restrict __buffer,
        long int *__restrict __result)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));


extern int srand48_r (long int __seedval, struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));

extern int seed48_r (unsigned short int __seed16v[3],
       struct drand48_data *__buffer) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));

extern int lcong48_r (unsigned short int __param[7],
        struct drand48_data *__buffer)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2)));
# 473 "/usr/include/stdlib.h" 3 4






extern void *realloc (void *__ptr, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__warn_unused_result__));

extern void free (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));




extern void cfree (void *__ptr) __attribute__ ((__nothrow__ , __leaf__));



# 1 "/usr/include/alloca.h" 1 3 4
# 24 "/usr/include/alloca.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 25 "/usr/include/alloca.h" 2 3 4







extern void *alloca (size_t __size) __attribute__ ((__nothrow__ , __leaf__));






# 492 "/usr/include/stdlib.h" 2 3 4





extern void *valloc (size_t __size) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;




extern int posix_memalign (void **__memptr, size_t __alignment, size_t __size)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 512 "/usr/include/stdlib.h" 3 4


extern void abort (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));



extern int atexit (void (*__func) (void)) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 529 "/usr/include/stdlib.h" 3 4





extern int on_exit (void (*__func) (int __status, void *__arg), void *__arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern void exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));













extern void _Exit (int __status) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__noreturn__));






extern char *getenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;

# 577 "/usr/include/stdlib.h" 3 4
extern int putenv (char *__string) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));





extern int setenv (const char *__name, const char *__value, int __replace)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (2)));


extern int unsetenv (const char *__name) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));






extern int clearenv (void) __attribute__ ((__nothrow__ , __leaf__));
# 605 "/usr/include/stdlib.h" 3 4
extern char *mktemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));
# 619 "/usr/include/stdlib.h" 3 4
extern int mkstemp (char *__template) __attribute__ ((__nonnull__ (1))) ;
# 641 "/usr/include/stdlib.h" 3 4
extern int mkstemps (char *__template, int __suffixlen) __attribute__ ((__nonnull__ (1))) ;
# 662 "/usr/include/stdlib.h" 3 4
extern char *mkdtemp (char *__template) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 711 "/usr/include/stdlib.h" 3 4





extern int system (const char *__command) ;

# 733 "/usr/include/stdlib.h" 3 4
extern char *realpath (const char *__restrict __name,
         char *__restrict __resolved) __attribute__ ((__nothrow__ , __leaf__)) ;






typedef int (*__compar_fn_t) (const void *, const void *);
# 751 "/usr/include/stdlib.h" 3 4



extern void *bsearch (const void *__key, const void *__base,
        size_t __nmemb, size_t __size, __compar_fn_t __compar)
     __attribute__ ((__nonnull__ (1, 2, 5))) ;



extern void qsort (void *__base, size_t __nmemb, size_t __size,
     __compar_fn_t __compar) __attribute__ ((__nonnull__ (1, 4)));
# 770 "/usr/include/stdlib.h" 3 4
extern int abs (int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern long int labs (long int __x) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;



__extension__ extern long long int llabs (long long int __x)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;







extern div_t div (int __numer, int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;
extern ldiv_t ldiv (long int __numer, long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;




__extension__ extern lldiv_t lldiv (long long int __numer,
        long long int __denom)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__)) ;

# 807 "/usr/include/stdlib.h" 3 4
extern char *ecvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *fcvt (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;




extern char *gcvt (double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern char *qecvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qfcvt (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4))) ;
extern char *qgcvt (long double __value, int __ndigit, char *__buf)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3))) ;




extern int ecvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int fcvt_r (double __value, int __ndigit, int *__restrict __decpt,
     int *__restrict __sign, char *__restrict __buf,
     size_t __len) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));

extern int qecvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));
extern int qfcvt_r (long double __value, int __ndigit,
      int *__restrict __decpt, int *__restrict __sign,
      char *__restrict __buf, size_t __len)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (3, 4, 5)));







extern int mblen (const char *__s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int mbtowc (wchar_t *__restrict __pwc,
     const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__)) ;


extern int wctomb (char *__s, wchar_t __wchar) __attribute__ ((__nothrow__ , __leaf__)) ;



extern size_t mbstowcs (wchar_t *__restrict __pwcs,
   const char *__restrict __s, size_t __n) __attribute__ ((__nothrow__ , __leaf__));

extern size_t wcstombs (char *__restrict __s,
   const wchar_t *__restrict __pwcs, size_t __n)
     __attribute__ ((__nothrow__ , __leaf__));








extern int rpmatch (const char *__response) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1))) ;
# 895 "/usr/include/stdlib.h" 3 4
extern int getsubopt (char **__restrict __optionp,
        char *const *__restrict __tokens,
        char **__restrict __valuep)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1, 2, 3))) ;
# 947 "/usr/include/stdlib.h" 3 4
extern int getloadavg (double __loadavg[], int __nelem)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__nonnull__ (1)));


# 1 "/usr/include/bits/stdlib-float.h" 1 3 4
# 24 "/usr/include/bits/stdlib-float.h" 3 4

extern __inline double
__attribute__ ((__nothrow__ , __leaf__)) atof (const char *__nptr)
{
  return strtod (__nptr, (char **) ((void *)0));
}

# 952 "/usr/include/stdlib.h" 2 3 4
# 964 "/usr/include/stdlib.h" 3 4

# 34 "src/bnet.h" 2
# 1 "/usr/include/errno.h" 1 3 4
# 31 "/usr/include/errno.h" 3 4




# 1 "/usr/include/bits/errno.h" 1 3 4
# 24 "/usr/include/bits/errno.h" 3 4
# 1 "/usr/include/linux/errno.h" 1 3 4
# 1 "/usr/include/asm/errno.h" 1 3 4
# 1 "/usr/include/asm-generic/errno.h" 1 3 4



# 1 "/usr/include/asm-generic/errno-base.h" 1 3 4
# 5 "/usr/include/asm-generic/errno.h" 2 3 4
# 1 "/usr/include/asm/errno.h" 2 3 4
# 1 "/usr/include/linux/errno.h" 2 3 4
# 25 "/usr/include/bits/errno.h" 2 3 4
# 50 "/usr/include/bits/errno.h" 3 4
extern int *__errno_location (void) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 36 "/usr/include/errno.h" 2 3 4
# 58 "/usr/include/errno.h" 3 4

# 35 "src/bnet.h" 2







# 1 "/usr/include/sys/socket.h" 1 3 4
# 25 "/usr/include/sys/socket.h" 3 4


# 1 "/usr/include/sys/uio.h" 1 3 4
# 26 "/usr/include/sys/uio.h" 3 4



# 1 "/usr/include/bits/uio.h" 1 3 4
# 43 "/usr/include/bits/uio.h" 3 4
struct iovec
  {
    void *iov_base;
    size_t iov_len;
  };
# 30 "/usr/include/sys/uio.h" 2 3 4
# 40 "/usr/include/sys/uio.h" 3 4
extern ssize_t readv (int __fd, const struct iovec *__iovec, int __count)
  ;
# 51 "/usr/include/sys/uio.h" 3 4
extern ssize_t writev (int __fd, const struct iovec *__iovec, int __count)
  ;
# 66 "/usr/include/sys/uio.h" 3 4
extern ssize_t preadv (int __fd, const struct iovec *__iovec, int __count,
         __off_t __offset) ;
# 78 "/usr/include/sys/uio.h" 3 4
extern ssize_t pwritev (int __fd, const struct iovec *__iovec, int __count,
   __off_t __offset) ;
# 121 "/usr/include/sys/uio.h" 3 4

# 28 "/usr/include/sys/socket.h" 2 3 4

# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 30 "/usr/include/sys/socket.h" 2 3 4
# 39 "/usr/include/sys/socket.h" 3 4
# 1 "/usr/include/bits/socket.h" 1 3 4
# 28 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 29 "/usr/include/bits/socket.h" 2 3 4
# 39 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/socket_type.h" 1 3 4
# 24 "/usr/include/bits/socket_type.h" 3 4
enum __socket_type
{
  SOCK_STREAM = 1,


  SOCK_DGRAM = 2,


  SOCK_RAW = 3,

  SOCK_RDM = 4,

  SOCK_SEQPACKET = 5,


  SOCK_DCCP = 6,

  SOCK_PACKET = 10,







  SOCK_CLOEXEC = 02000000,


  SOCK_NONBLOCK = 00004000


};
# 40 "/usr/include/bits/socket.h" 2 3 4
# 145 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/bits/sockaddr.h" 1 3 4
# 28 "/usr/include/bits/sockaddr.h" 3 4
typedef unsigned short int sa_family_t;
# 146 "/usr/include/bits/socket.h" 2 3 4


struct sockaddr
  {
    sa_family_t sa_family;
    char sa_data[14];
  };
# 161 "/usr/include/bits/socket.h" 3 4
struct sockaddr_storage
  {
    sa_family_t ss_family;
    unsigned long int __ss_align;
    char __ss_padding[(128 - (2 * sizeof (unsigned long int)))];
  };



enum
  {
    MSG_OOB = 0x01,

    MSG_PEEK = 0x02,

    MSG_DONTROUTE = 0x04,






    MSG_CTRUNC = 0x08,

    MSG_PROXY = 0x10,

    MSG_TRUNC = 0x20,

    MSG_DONTWAIT = 0x40,

    MSG_EOR = 0x80,

    MSG_WAITALL = 0x100,

    MSG_FIN = 0x200,

    MSG_SYN = 0x400,

    MSG_CONFIRM = 0x800,

    MSG_RST = 0x1000,

    MSG_ERRQUEUE = 0x2000,

    MSG_NOSIGNAL = 0x4000,

    MSG_MORE = 0x8000,

    MSG_WAITFORONE = 0x10000,


    MSG_CMSG_CLOEXEC = 0x40000000



  };




struct msghdr
  {
    void *msg_name;
    socklen_t msg_namelen;

    struct iovec *msg_iov;
    size_t msg_iovlen;

    void *msg_control;
    size_t msg_controllen;




    int msg_flags;
  };


struct cmsghdr
  {
    size_t cmsg_len;




    int cmsg_level;
    int cmsg_type;

    __extension__ unsigned char __cmsg_data [];

  };
# 269 "/usr/include/bits/socket.h" 3 4
extern struct cmsghdr *__cmsg_nxthdr (struct msghdr *__mhdr,
          struct cmsghdr *__cmsg) __attribute__ ((__nothrow__ , __leaf__));




extern __inline struct cmsghdr *
__attribute__ ((__nothrow__ , __leaf__)) __cmsg_nxthdr (struct msghdr *__mhdr, struct cmsghdr *__cmsg)
{
  if ((size_t) __cmsg->cmsg_len < sizeof (struct cmsghdr))

    return (struct cmsghdr *) 0;

  __cmsg = (struct cmsghdr *) ((unsigned char *) __cmsg
          + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1)));
  if ((unsigned char *) (__cmsg + 1) > ((unsigned char *) __mhdr->msg_control
     + __mhdr->msg_controllen)
      || ((unsigned char *) __cmsg + (((__cmsg->cmsg_len) + sizeof (size_t) - 1) & (size_t) ~(sizeof (size_t) - 1))
   > ((unsigned char *) __mhdr->msg_control + __mhdr->msg_controllen)))

    return (struct cmsghdr *) 0;
  return __cmsg;
}




enum
  {
    SCM_RIGHTS = 0x01





  };
# 342 "/usr/include/bits/socket.h" 3 4
# 1 "/usr/include/asm/socket.h" 1 3 4
# 1 "/usr/include/asm-generic/socket.h" 1 3 4



# 1 "/usr/include/asm/sockios.h" 1 3 4
# 1 "/usr/include/asm-generic/sockios.h" 1 3 4
# 1 "/usr/include/asm/sockios.h" 2 3 4
# 5 "/usr/include/asm-generic/socket.h" 2 3 4
# 1 "/usr/include/asm/socket.h" 2 3 4
# 343 "/usr/include/bits/socket.h" 2 3 4
# 376 "/usr/include/bits/socket.h" 3 4
struct linger
  {
    int l_onoff;
    int l_linger;
  };
# 40 "/usr/include/sys/socket.h" 2 3 4




struct osockaddr
  {
    unsigned short int sa_family;
    unsigned char sa_data[14];
  };




enum
{
  SHUT_RD = 0,

  SHUT_WR,

  SHUT_RDWR

};
# 114 "/usr/include/sys/socket.h" 3 4
extern int socket (int __domain, int __type, int __protocol) __attribute__ ((__nothrow__ , __leaf__));





extern int socketpair (int __domain, int __type, int __protocol,
         int __fds[2]) __attribute__ ((__nothrow__ , __leaf__));


extern int bind (int __fd, const struct sockaddr * __addr, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));


extern int getsockname (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));
# 138 "/usr/include/sys/socket.h" 3 4
extern int connect (int __fd, const struct sockaddr * __addr, socklen_t __len);



extern int getpeername (int __fd, struct sockaddr *__restrict __addr,
   socklen_t *__restrict __len) __attribute__ ((__nothrow__ , __leaf__));






extern ssize_t send (int __fd, const void *__buf, size_t __n, int __flags);






extern ssize_t recv (int __fd, void *__buf, size_t __n, int __flags);






extern ssize_t sendto (int __fd, const void *__buf, size_t __n,
         int __flags, const struct sockaddr * __addr,
         socklen_t __addr_len);
# 175 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvfrom (int __fd, void *__restrict __buf, size_t __n,
    int __flags, struct sockaddr *__restrict __addr,
    socklen_t *__restrict __addr_len);







extern ssize_t sendmsg (int __fd, const struct msghdr *__message,
   int __flags);
# 203 "/usr/include/sys/socket.h" 3 4
extern ssize_t recvmsg (int __fd, struct msghdr *__message, int __flags);
# 220 "/usr/include/sys/socket.h" 3 4
extern int getsockopt (int __fd, int __level, int __optname,
         void *__restrict __optval,
         socklen_t *__restrict __optlen) __attribute__ ((__nothrow__ , __leaf__));




extern int setsockopt (int __fd, int __level, int __optname,
         const void *__optval, socklen_t __optlen) __attribute__ ((__nothrow__ , __leaf__));





extern int listen (int __fd, int __n) __attribute__ ((__nothrow__ , __leaf__));
# 244 "/usr/include/sys/socket.h" 3 4
extern int accept (int __fd, struct sockaddr *__restrict __addr,
     socklen_t *__restrict __addr_len);
# 262 "/usr/include/sys/socket.h" 3 4
extern int shutdown (int __fd, int __how) __attribute__ ((__nothrow__ , __leaf__));




extern int sockatmark (int __fd) __attribute__ ((__nothrow__ , __leaf__));







extern int isfdtype (int __fd, int __fdtype) __attribute__ ((__nothrow__ , __leaf__));
# 284 "/usr/include/sys/socket.h" 3 4

# 43 "src/bnet.h" 2
# 1 "/usr/include/netinet/in.h" 1 3 4
# 23 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stdint.h" 1 3 4
# 9 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stdint.h" 3 4
# 1 "/usr/include/stdint.h" 1 3 4
# 26 "/usr/include/stdint.h" 3 4
# 1 "/usr/include/bits/wchar.h" 1 3 4
# 22 "/usr/include/bits/wchar.h" 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 23 "/usr/include/bits/wchar.h" 2 3 4
# 27 "/usr/include/stdint.h" 2 3 4
# 1 "/usr/include/bits/wordsize.h" 1 3 4
# 28 "/usr/include/stdint.h" 2 3 4
# 48 "/usr/include/stdint.h" 3 4
typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;



typedef unsigned long int uint64_t;
# 65 "/usr/include/stdint.h" 3 4
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;






typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
# 90 "/usr/include/stdint.h" 3 4
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
# 103 "/usr/include/stdint.h" 3 4
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
# 122 "/usr/include/stdint.h" 3 4
typedef unsigned long int uintptr_t;
# 134 "/usr/include/stdint.h" 3 4
typedef long int intmax_t;
typedef unsigned long int uintmax_t;
# 10 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stdint.h" 2 3 4
# 24 "/usr/include/netinet/in.h" 2 3 4







enum
  {
    IPPROTO_IP = 0,

    IPPROTO_HOPOPTS = 0,

    IPPROTO_ICMP = 1,

    IPPROTO_IGMP = 2,

    IPPROTO_IPIP = 4,

    IPPROTO_TCP = 6,

    IPPROTO_EGP = 8,

    IPPROTO_PUP = 12,

    IPPROTO_UDP = 17,

    IPPROTO_IDP = 22,

    IPPROTO_TP = 29,

    IPPROTO_DCCP = 33,

    IPPROTO_IPV6 = 41,

    IPPROTO_ROUTING = 43,

    IPPROTO_FRAGMENT = 44,

    IPPROTO_RSVP = 46,

    IPPROTO_GRE = 47,

    IPPROTO_ESP = 50,

    IPPROTO_AH = 51,

    IPPROTO_ICMPV6 = 58,

    IPPROTO_NONE = 59,

    IPPROTO_DSTOPTS = 60,

    IPPROTO_MTP = 92,

    IPPROTO_ENCAP = 98,

    IPPROTO_PIM = 103,

    IPPROTO_COMP = 108,

    IPPROTO_SCTP = 132,

    IPPROTO_UDPLITE = 136,

    IPPROTO_RAW = 255,

    IPPROTO_MAX
  };



typedef uint16_t in_port_t;


enum
  {
    IPPORT_ECHO = 7,
    IPPORT_DISCARD = 9,
    IPPORT_SYSTAT = 11,
    IPPORT_DAYTIME = 13,
    IPPORT_NETSTAT = 15,
    IPPORT_FTP = 21,
    IPPORT_TELNET = 23,
    IPPORT_SMTP = 25,
    IPPORT_TIMESERVER = 37,
    IPPORT_NAMESERVER = 42,
    IPPORT_WHOIS = 43,
    IPPORT_MTP = 57,

    IPPORT_TFTP = 69,
    IPPORT_RJE = 77,
    IPPORT_FINGER = 79,
    IPPORT_TTYLINK = 87,
    IPPORT_SUPDUP = 95,


    IPPORT_EXECSERVER = 512,
    IPPORT_LOGINSERVER = 513,
    IPPORT_CMDSERVER = 514,
    IPPORT_EFSSERVER = 520,


    IPPORT_BIFFUDP = 512,
    IPPORT_WHOSERVER = 513,
    IPPORT_ROUTESERVER = 520,


    IPPORT_RESERVED = 1024,


    IPPORT_USERRESERVED = 5000
  };



typedef uint32_t in_addr_t;
struct in_addr
  {
    in_addr_t s_addr;
  };
# 197 "/usr/include/netinet/in.h" 3 4
struct in6_addr
  {
    union
      {
 uint8_t __u6_addr8[16];

 uint16_t __u6_addr16[8];
 uint32_t __u6_addr32[4];

      } __in6_u;





  };

extern const struct in6_addr in6addr_any;
extern const struct in6_addr in6addr_loopback;
# 224 "/usr/include/netinet/in.h" 3 4
struct sockaddr_in
  {
    sa_family_t sin_family;
    in_port_t sin_port;
    struct in_addr sin_addr;


    unsigned char sin_zero[sizeof (struct sockaddr) -
      (sizeof (unsigned short int)) -
      sizeof (in_port_t) -
      sizeof (struct in_addr)];
  };


struct sockaddr_in6
  {
    sa_family_t sin6_family;
    in_port_t sin6_port;
    uint32_t sin6_flowinfo;
    struct in6_addr sin6_addr;
    uint32_t sin6_scope_id;
  };




struct ip_mreq
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;
  };

struct ip_mreq_source
  {

    struct in_addr imr_multiaddr;


    struct in_addr imr_interface;


    struct in_addr imr_sourceaddr;
  };




struct ipv6_mreq
  {

    struct in6_addr ipv6mr_multiaddr;


    unsigned int ipv6mr_interface;
  };




struct group_req
  {

    uint32_t gr_interface;


    struct sockaddr_storage gr_group;
  };

struct group_source_req
  {

    uint32_t gsr_interface;


    struct sockaddr_storage gsr_group;


    struct sockaddr_storage gsr_source;
  };



struct ip_msfilter
  {

    struct in_addr imsf_multiaddr;


    struct in_addr imsf_interface;


    uint32_t imsf_fmode;


    uint32_t imsf_numsrc;

    struct in_addr imsf_slist[1];
  };





struct group_filter
  {

    uint32_t gf_interface;


    struct sockaddr_storage gf_group;


    uint32_t gf_fmode;


    uint32_t gf_numsrc;

    struct sockaddr_storage gf_slist[1];
};
# 355 "/usr/include/netinet/in.h" 3 4
# 1 "/usr/include/bits/in.h" 1 3 4
# 100 "/usr/include/bits/in.h" 3 4
struct ip_opts
  {
    struct in_addr ip_dst;
    char ip_opts[40];
  };


struct ip_mreqn
  {
    struct in_addr imr_multiaddr;
    struct in_addr imr_address;
    int imr_ifindex;
  };


struct in_pktinfo
  {
    int ipi_ifindex;
    struct in_addr ipi_spec_dst;
    struct in_addr ipi_addr;
  };
# 356 "/usr/include/netinet/in.h" 2 3 4
# 364 "/usr/include/netinet/in.h" 3 4
extern uint32_t ntohl (uint32_t __netlong) __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t ntohs (uint16_t __netshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint32_t htonl (uint32_t __hostlong)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern uint16_t htons (uint16_t __hostshort)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));




# 1 "/usr/include/bits/byteswap.h" 1 3 4
# 376 "/usr/include/netinet/in.h" 2 3 4
# 491 "/usr/include/netinet/in.h" 3 4
extern int bindresvport (int __sockfd, struct sockaddr_in *__sock_in) __attribute__ ((__nothrow__ , __leaf__));


extern int bindresvport6 (int __sockfd, struct sockaddr_in6 *__sock_in)
     __attribute__ ((__nothrow__ , __leaf__));
# 618 "/usr/include/netinet/in.h" 3 4

# 44 "src/bnet.h" 2
# 1 "/usr/include/arpa/inet.h" 1 3 4
# 30 "/usr/include/arpa/inet.h" 3 4




extern in_addr_t inet_addr (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_lnaof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern struct in_addr inet_makeaddr (in_addr_t __net, in_addr_t __host)
     __attribute__ ((__nothrow__ , __leaf__));


extern in_addr_t inet_netof (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));



extern in_addr_t inet_network (const char *__cp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_ntoa (struct in_addr __in) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_pton (int __af, const char *__restrict __cp,
        void *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));




extern const char *inet_ntop (int __af, const void *__restrict __cp,
         char *__restrict __buf, socklen_t __len)
     __attribute__ ((__nothrow__ , __leaf__));






extern int inet_aton (const char *__cp, struct in_addr *__inp) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_neta (in_addr_t __net, char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern char *inet_net_ntop (int __af, const void *__cp, int __bits,
       char *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern int inet_net_pton (int __af, const char *__cp,
     void *__buf, size_t __len) __attribute__ ((__nothrow__ , __leaf__));




extern unsigned int inet_nsap_addr (const char *__cp,
        unsigned char *__buf, int __len) __attribute__ ((__nothrow__ , __leaf__));



extern char *inet_nsap_ntoa (int __len, const unsigned char *__cp,
        char *__buf) __attribute__ ((__nothrow__ , __leaf__));



# 45 "src/bnet.h" 2


# 1 "/usr/include/libpurple/account.h" 1
# 31 "/usr/include/libpurple/account.h"
# 1 "/usr/include/glib-2.0/glib-object.h" 1
# 25 "/usr/include/glib-2.0/glib-object.h"
# 1 "/usr/include/glib-2.0/gobject/gbinding.h" 1
# 31 "/usr/include/glib-2.0/gobject/gbinding.h"
# 1 "/usr/include/glib-2.0/gobject/gobject.h" 1
# 26 "/usr/include/glib-2.0/gobject/gobject.h"
# 1 "/usr/include/glib-2.0/gobject/gtype.h" 1
# 28 "/usr/include/glib-2.0/gobject/gtype.h"

# 384 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gsize GType;



typedef struct _GValue GValue;
typedef union _GTypeCValue GTypeCValue;
typedef struct _GTypePlugin GTypePlugin;
typedef struct _GTypeClass GTypeClass;
typedef struct _GTypeInterface GTypeInterface;
typedef struct _GTypeInstance GTypeInstance;
typedef struct _GTypeInfo GTypeInfo;
typedef struct _GTypeFundamentalInfo GTypeFundamentalInfo;
typedef struct _GInterfaceInfo GInterfaceInfo;
typedef struct _GTypeValueTable GTypeValueTable;
typedef struct _GTypeQuery GTypeQuery;
# 408 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeClass
{

  GType g_type;
};





struct _GTypeInstance
{

  GTypeClass *g_class;
};





struct _GTypeInterface
{

  GType g_type;
  GType g_instance_type;
};
# 444 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeQuery
{
  GType type;
  const gchar *type_name;
  guint class_size;
  guint instance_size;
};
# 658 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum
{
  G_TYPE_DEBUG_NONE = 0,
  G_TYPE_DEBUG_OBJECTS = 1 << 0,
  G_TYPE_DEBUG_SIGNALS = 1 << 1,
  G_TYPE_DEBUG_MASK = 0x03
} GTypeDebugFlags;



__attribute__((__deprecated__)) extern
void g_type_init (void);
__attribute__((__deprecated__)) extern
void g_type_init_with_debug_flags (GTypeDebugFlags debug_flags);
extern
const gchar * g_type_name (GType type);
extern
GQuark g_type_qname (GType type);
extern
GType g_type_from_name (const gchar *name);
extern
GType g_type_parent (GType type);
extern
guint g_type_depth (GType type);
extern
GType g_type_next_base (GType leaf_type,
            GType root_type);
extern
gboolean g_type_is_a (GType type,
            GType is_a_type);
extern
gpointer g_type_class_ref (GType type);
extern
gpointer g_type_class_peek (GType type);
extern
gpointer g_type_class_peek_static (GType type);
extern
void g_type_class_unref (gpointer g_class);
extern
gpointer g_type_class_peek_parent (gpointer g_class);
extern
gpointer g_type_interface_peek (gpointer instance_class,
            GType iface_type);
extern
gpointer g_type_interface_peek_parent (gpointer g_iface);

extern
gpointer g_type_default_interface_ref (GType g_type);
extern
gpointer g_type_default_interface_peek (GType g_type);
extern
void g_type_default_interface_unref (gpointer g_iface);


extern
GType* g_type_children (GType type,
            guint *n_children);
extern
GType* g_type_interfaces (GType type,
            guint *n_interfaces);


extern
void g_type_set_qdata (GType type,
            GQuark quark,
            gpointer data);
extern
gpointer g_type_get_qdata (GType type,
            GQuark quark);
extern
void g_type_query (GType type,
            GTypeQuery *query);
# 746 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseInitFunc) (gpointer g_class);
# 757 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GBaseFinalizeFunc) (gpointer g_class);
# 862 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassInitFunc) (gpointer g_class,
           gpointer class_data);
# 877 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GClassFinalizeFunc) (gpointer g_class,
           gpointer class_data);
# 892 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInstanceInitFunc) (GTypeInstance *instance,
           gpointer g_class);
# 903 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceInitFunc) (gpointer g_iface,
           gpointer iface_data);
# 914 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GInterfaceFinalizeFunc) (gpointer g_iface,
           gpointer iface_data);
# 934 "/usr/include/glib-2.0/gobject/gtype.h"
typedef gboolean (*GTypeClassCacheFunc) (gpointer cache_data,
           GTypeClass *g_class);
# 946 "/usr/include/glib-2.0/gobject/gtype.h"
typedef void (*GTypeInterfaceCheckFunc) (gpointer check_data,
           gpointer g_iface);
# 958 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum
{
  G_TYPE_FLAG_CLASSED = (1 << 0),
  G_TYPE_FLAG_INSTANTIATABLE = (1 << 1),
  G_TYPE_FLAG_DERIVABLE = (1 << 2),
  G_TYPE_FLAG_DEEP_DERIVABLE = (1 << 3)
} GTypeFundamentalFlags;
# 975 "/usr/include/glib-2.0/gobject/gtype.h"
typedef enum
{
  G_TYPE_FLAG_ABSTRACT = (1 << 4),
  G_TYPE_FLAG_VALUE_ABSTRACT = (1 << 5)
} GTypeFlags;
# 1010 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeInfo
{

  guint16 class_size;

  GBaseInitFunc base_init;
  GBaseFinalizeFunc base_finalize;


  GClassInitFunc class_init;
  GClassFinalizeFunc class_finalize;
  gconstpointer class_data;


  guint16 instance_size;
  guint16 n_preallocs;
  GInstanceInitFunc instance_init;


  const GTypeValueTable *value_table;
};







struct _GTypeFundamentalInfo
{
  GTypeFundamentalFlags type_flags;
};
# 1051 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GInterfaceInfo
{
  GInterfaceInitFunc interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer interface_data;
};
# 1226 "/usr/include/glib-2.0/gobject/gtype.h"
struct _GTypeValueTable
{
  void (*value_init) (GValue *value);
  void (*value_free) (GValue *value);
  void (*value_copy) (const GValue *src_value,
      GValue *dest_value);

  gpointer (*value_peek_pointer) (const GValue *value);
  const gchar *collect_format;
  gchar* (*collect_value) (GValue *value,
      guint n_collect_values,
      GTypeCValue *collect_values,
      guint collect_flags);
  const gchar *lcopy_format;
  gchar* (*lcopy_value) (const GValue *value,
      guint n_collect_values,
      GTypeCValue *collect_values,
      guint collect_flags);
};
extern
GType g_type_register_static (GType parent_type,
      const gchar *type_name,
      const GTypeInfo *info,
      GTypeFlags flags);
extern
GType g_type_register_static_simple (GType parent_type,
      const gchar *type_name,
      guint class_size,
      GClassInitFunc class_init,
      guint instance_size,
      GInstanceInitFunc instance_init,
      GTypeFlags flags);

extern
GType g_type_register_dynamic (GType parent_type,
      const gchar *type_name,
      GTypePlugin *plugin,
      GTypeFlags flags);
extern
GType g_type_register_fundamental (GType type_id,
      const gchar *type_name,
      const GTypeInfo *info,
      const GTypeFundamentalInfo *finfo,
      GTypeFlags flags);
extern
void g_type_add_interface_static (GType instance_type,
      GType interface_type,
      const GInterfaceInfo *info);
extern
void g_type_add_interface_dynamic (GType instance_type,
      GType interface_type,
      GTypePlugin *plugin);
extern
void g_type_interface_add_prerequisite (GType interface_type,
      GType prerequisite_type);
extern
GType*g_type_interface_prerequisites (GType interface_type,
      guint *n_prerequisites);
extern
void g_type_class_add_private (gpointer g_class,
                                         gsize private_size);
extern
gpointer g_type_instance_get_private (GTypeInstance *instance,
                                         GType private_type);

extern
void g_type_add_class_private (GType class_type,
      gsize private_size);
extern
gpointer g_type_class_get_private (GTypeClass *klass,
      GType private_type);

extern
void g_type_ensure (GType type);
extern
guint g_type_get_type_registration_serial (void);
# 1662 "/usr/include/glib-2.0/gobject/gtype.h"
extern
GTypePlugin* g_type_get_plugin (GType type);
extern
GTypePlugin* g_type_interface_get_plugin (GType instance_type,
       GType interface_type);
extern
GType g_type_fundamental_next (void);
extern
GType g_type_fundamental (GType type_id);
extern
GTypeInstance* g_type_create_instance (GType type);
extern
void g_type_free_instance (GTypeInstance *instance);

extern
void g_type_add_class_cache_func (gpointer cache_data,
       GTypeClassCacheFunc cache_func);
extern
void g_type_remove_class_cache_func (gpointer cache_data,
       GTypeClassCacheFunc cache_func);
extern
void g_type_class_unref_uncached (gpointer g_class);

extern
void g_type_add_interface_check (gpointer check_data,
       GTypeInterfaceCheckFunc check_func);
extern
void g_type_remove_interface_check (gpointer check_data,
       GTypeInterfaceCheckFunc check_func);

extern
GTypeValueTable* g_type_value_table_peek (GType type);



extern
gboolean g_type_check_instance (GTypeInstance *instance) __attribute__((__pure__));
extern
GTypeInstance* g_type_check_instance_cast (GTypeInstance *instance,
       GType iface_type);
extern
gboolean g_type_check_instance_is_a (GTypeInstance *instance,
       GType iface_type) __attribute__((__pure__));
extern
GTypeClass* g_type_check_class_cast (GTypeClass *g_class,
       GType is_a_type);
extern
gboolean g_type_check_class_is_a (GTypeClass *g_class,
       GType is_a_type) __attribute__((__pure__));
extern
gboolean g_type_check_is_value_type (GType type) __attribute__((__const__));
extern
gboolean g_type_check_value (GValue *value) __attribute__((__pure__));
extern
gboolean g_type_check_value_holds (GValue *value,
       GType type) __attribute__((__pure__));
extern
gboolean g_type_test_flags (GType type,
       guint flags) __attribute__((__const__));



extern
const gchar * g_type_name_from_instance (GTypeInstance *instance);
extern
const gchar * g_type_name_from_class (GTypeClass *g_class);
# 1786 "/usr/include/glib-2.0/gobject/gtype.h"
extern GTypeDebugFlags _g_type_debug_flags;


# 27 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gvalue.h" 1
# 30 "/usr/include/glib-2.0/gobject/gvalue.h"

# 94 "/usr/include/glib-2.0/gobject/gvalue.h"
typedef void (*GValueTransform) (const GValue *src_value,
     GValue *dest_value);
# 108 "/usr/include/glib-2.0/gobject/gvalue.h"
struct _GValue
{

  GType g_type;


  union {
    gint v_int;
    guint v_uint;
    glong v_long;
    gulong v_ulong;
    gint64 v_int64;
    guint64 v_uint64;
    gfloat v_float;
    gdouble v_double;
    gpointer v_pointer;
  } data[2];
};



extern
GValue* g_value_init (GValue *value,
      GType g_type);
extern
void g_value_copy (const GValue *src_value,
      GValue *dest_value);
extern
GValue* g_value_reset (GValue *value);
extern
void g_value_unset (GValue *value);
extern
void g_value_set_instance (GValue *value,
      gpointer instance);



extern
gboolean g_value_fits_pointer (const GValue *value);
extern
gpointer g_value_peek_pointer (const GValue *value);



extern
gboolean g_value_type_compatible (GType src_type,
      GType dest_type);
extern
gboolean g_value_type_transformable (GType src_type,
      GType dest_type);
extern
gboolean g_value_transform (const GValue *src_value,
      GValue *dest_value);
extern
void g_value_register_transform_func (GType src_type,
      GType dest_type,
      GValueTransform transform_func);
# 192 "/usr/include/glib-2.0/gobject/gvalue.h"

# 28 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gparam.h" 1
# 30 "/usr/include/glib-2.0/gobject/gparam.h"

# 143 "/usr/include/glib-2.0/gobject/gparam.h"
typedef enum
{
  G_PARAM_READABLE = 1 << 0,
  G_PARAM_WRITABLE = 1 << 1,
  G_PARAM_CONSTRUCT = 1 << 2,
  G_PARAM_CONSTRUCT_ONLY = 1 << 3,
  G_PARAM_LAX_VALIDATION = 1 << 4,
  G_PARAM_STATIC_NAME = 1 << 5,

  G_PARAM_PRIVATE = G_PARAM_STATIC_NAME,

  G_PARAM_STATIC_NICK = 1 << 6,
  G_PARAM_STATIC_BLURB = 1 << 7,

  G_PARAM_DEPRECATED = 1 << 31
} GParamFlags;
# 189 "/usr/include/glib-2.0/gobject/gparam.h"
typedef struct _GParamSpec GParamSpec;
typedef struct _GParamSpecClass GParamSpecClass;
typedef struct _GParameter GParameter;
typedef struct _GParamSpecPool GParamSpecPool;
# 204 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpec
{
  GTypeInstance g_type_instance;

  const gchar *name;
  GParamFlags flags;
  GType value_type;
  GType owner_type;


  gchar *_nick;
  gchar *_blurb;
  GData *qdata;
  guint ref_count;
  guint param_id;
};
# 239 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecClass
{
  GTypeClass g_type_class;

  GType value_type;

  void (*finalize) (GParamSpec *pspec);


  void (*value_set_default) (GParamSpec *pspec,
      GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
      GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
      const GValue *value1,
      const GValue *value2);

  gpointer dummy[4];
};
# 266 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParameter
{
  const gchar *name;
  GValue value;
};



extern
GParamSpec* g_param_spec_ref (GParamSpec *pspec);
extern
void g_param_spec_unref (GParamSpec *pspec);
extern
void g_param_spec_sink (GParamSpec *pspec);
extern
GParamSpec* g_param_spec_ref_sink (GParamSpec *pspec);
extern
gpointer g_param_spec_get_qdata (GParamSpec *pspec,
       GQuark quark);
extern
void g_param_spec_set_qdata (GParamSpec *pspec,
       GQuark quark,
       gpointer data);
extern
void g_param_spec_set_qdata_full (GParamSpec *pspec,
       GQuark quark,
       gpointer data,
       GDestroyNotify destroy);
extern
gpointer g_param_spec_steal_qdata (GParamSpec *pspec,
       GQuark quark);
extern
GParamSpec* g_param_spec_get_redirect_target (GParamSpec *pspec);

extern
void g_param_value_set_default (GParamSpec *pspec,
       GValue *value);
extern
gboolean g_param_value_defaults (GParamSpec *pspec,
       GValue *value);
extern
gboolean g_param_value_validate (GParamSpec *pspec,
       GValue *value);
extern
gboolean g_param_value_convert (GParamSpec *pspec,
       const GValue *src_value,
       GValue *dest_value,
       gboolean strict_validation);
extern
gint g_param_values_cmp (GParamSpec *pspec,
       const GValue *value1,
       const GValue *value2);
extern
const gchar * g_param_spec_get_name (GParamSpec *pspec);
extern
const gchar * g_param_spec_get_nick (GParamSpec *pspec);
extern
const gchar * g_param_spec_get_blurb (GParamSpec *pspec);
extern
void g_value_set_param (GValue *value,
       GParamSpec *param);
extern
GParamSpec* g_value_get_param (const GValue *value);
extern
GParamSpec* g_value_dup_param (const GValue *value);


extern
void g_value_take_param (GValue *value,
              GParamSpec *param);
__attribute__((__deprecated__("Use '" "g_value_take_param" "' instead"))) extern
void g_value_set_param_take_ownership (GValue *value,
                                                 GParamSpec *param);


typedef struct _GParamSpecTypeInfo GParamSpecTypeInfo;
# 366 "/usr/include/glib-2.0/gobject/gparam.h"
struct _GParamSpecTypeInfo
{

  guint16 instance_size;
  guint16 n_preallocs;
  void (*instance_init) (GParamSpec *pspec);


  GType value_type;
  void (*finalize) (GParamSpec *pspec);
  void (*value_set_default) (GParamSpec *pspec,
      GValue *value);
  gboolean (*value_validate) (GParamSpec *pspec,
      GValue *value);
  gint (*values_cmp) (GParamSpec *pspec,
      const GValue *value1,
      const GValue *value2);
};
extern
GType g_param_type_register_static (const gchar *name,
      const GParamSpecTypeInfo *pspec_info);


GType _g_param_type_register_static_constant (const gchar *name,
            const GParamSpecTypeInfo *pspec_info,
            GType opt_type);



extern
gpointer g_param_spec_internal (GType param_type,
       const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamFlags flags);
extern
GParamSpecPool* g_param_spec_pool_new (gboolean type_prefixing);
extern
void g_param_spec_pool_insert (GParamSpecPool *pool,
       GParamSpec *pspec,
       GType owner_type);
extern
void g_param_spec_pool_remove (GParamSpecPool *pool,
       GParamSpec *pspec);
extern
GParamSpec* g_param_spec_pool_lookup (GParamSpecPool *pool,
       const gchar *param_name,
       GType owner_type,
       gboolean walk_ancestors);
extern
GList* g_param_spec_pool_list_owned (GParamSpecPool *pool,
       GType owner_type);
extern
GParamSpec** g_param_spec_pool_list (GParamSpecPool *pool,
       GType owner_type,
       guint *n_pspecs_p);
# 441 "/usr/include/glib-2.0/gobject/gparam.h"

# 29 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gclosure.h" 1
# 29 "/usr/include/glib-2.0/gobject/gclosure.h"

# 76 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GClosure GClosure;
typedef struct _GClosureNotifyData GClosureNotifyData;
# 88 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GCallback) (void);
# 97 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureNotify) (gpointer data,
      GClosure *closure);
# 117 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef void (*GClosureMarshal) (GClosure *closure,
      GValue *return_value,
      guint n_param_values,
      const GValue *param_values,
      gpointer invocation_hint,
      gpointer marshal_data);

typedef void (* GVaClosureMarshal) (GClosure *closure,
        GValue *return_value,
        gpointer instance,
        va_list args,
        gpointer marshal_data,
        int n_params,
        GType *param_types);
# 139 "/usr/include/glib-2.0/gobject/gclosure.h"
typedef struct _GCClosure GCClosure;



struct _GClosureNotifyData
{
  gpointer data;
  GClosureNotify notify;
};
# 157 "/usr/include/glib-2.0/gobject/gclosure.h"
struct _GClosure
{

  volatile guint ref_count : 15;


  volatile guint meta_marshal_nouse : 1;
  volatile guint n_guards : 1;
  volatile guint n_fnotifiers : 2;
  volatile guint n_inotifiers : 8;
  volatile guint in_inotify : 1;
  volatile guint floating : 1;

  volatile guint derivative_flag : 1;

  volatile guint in_marshal : 1;
  volatile guint is_invalid : 1;

                  void (*marshal) (GClosure *closure,
         GValue *return_value,
         guint n_param_values,
         const GValue *param_values,
         gpointer invocation_hint,
         gpointer marshal_data);
                    gpointer data;

                  GClosureNotifyData *notifiers;
# 195 "/usr/include/glib-2.0/gobject/gclosure.h"
};


struct _GCClosure
{
  GClosure closure;
  gpointer callback;
};



extern
GClosure* g_cclosure_new (GCallback callback_func,
       gpointer user_data,
       GClosureNotify destroy_data);
extern
GClosure* g_cclosure_new_swap (GCallback callback_func,
       gpointer user_data,
       GClosureNotify destroy_data);
extern
GClosure* g_signal_type_cclosure_new (GType itype,
       guint struct_offset);



extern
GClosure* g_closure_ref (GClosure *closure);
extern
void g_closure_sink (GClosure *closure);
extern
void g_closure_unref (GClosure *closure);

extern
GClosure* g_closure_new_simple (guint sizeof_closure,
       gpointer data);
extern
void g_closure_add_finalize_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
extern
void g_closure_remove_finalize_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
extern
void g_closure_add_invalidate_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
extern
void g_closure_remove_invalidate_notifier (GClosure *closure,
       gpointer notify_data,
       GClosureNotify notify_func);
extern
void g_closure_add_marshal_guards (GClosure *closure,
       gpointer pre_marshal_data,
       GClosureNotify pre_marshal_notify,
       gpointer post_marshal_data,
       GClosureNotify post_marshal_notify);
extern
void g_closure_set_marshal (GClosure *closure,
       GClosureMarshal marshal);
extern
void g_closure_set_meta_marshal (GClosure *closure,
       gpointer marshal_data,
       GClosureMarshal meta_marshal);
extern
void g_closure_invalidate (GClosure *closure);
extern
void g_closure_invoke (GClosure *closure,
       GValue *return_value,
       guint n_param_values,
       const GValue *param_values,
       gpointer invocation_hint);
# 279 "/usr/include/glib-2.0/gobject/gclosure.h"
extern
void g_cclosure_marshal_generic (GClosure *closure,
                                 GValue *return_gvalue,
                                 guint n_param_values,
                                 const GValue *param_values,
                                 gpointer invocation_hint,
                                 gpointer marshal_data);

extern
void g_cclosure_marshal_generic_va (GClosure *closure,
        GValue *return_value,
        gpointer instance,
        va_list args_list,
        gpointer marshal_data,
        int n_params,
        GType *param_types);



# 30 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gsignal.h" 1
# 29 "/usr/include/glib-2.0/gobject/gsignal.h"
# 1 "/usr/include/glib-2.0/gobject/gmarshal.h" 1







extern
void g_cclosure_marshal_VOID__VOID (GClosure *closure,
                                    GValue *return_value,
                                    guint n_param_values,
                                    const GValue *param_values,
                                    gpointer invocation_hint,
                                    gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__VOIDv (GClosure *closure,
                                     GValue *return_value,
                                     gpointer instance,
                                     va_list args,
                                     gpointer marshal_data,
                                     int n_params,
                                     GType *param_types);


extern
void g_cclosure_marshal_VOID__BOOLEAN (GClosure *closure,
                                       GValue *return_value,
                                       guint n_param_values,
                                       const GValue *param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__BOOLEANv (GClosure *closure,
                                        GValue *return_value,
                                        gpointer instance,
                                        va_list args,
                                        gpointer marshal_data,
                                        int n_params,
                                        GType *param_types);


extern
void g_cclosure_marshal_VOID__CHAR (GClosure *closure,
                                    GValue *return_value,
                                    guint n_param_values,
                                    const GValue *param_values,
                                    gpointer invocation_hint,
                                    gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__CHARv (GClosure *closure,
                                     GValue *return_value,
                                     gpointer instance,
                                     va_list args,
                                     gpointer marshal_data,
                                     int n_params,
                                     GType *param_types);


extern
void g_cclosure_marshal_VOID__UCHAR (GClosure *closure,
                                     GValue *return_value,
                                     guint n_param_values,
                                     const GValue *param_values,
                                     gpointer invocation_hint,
                                     gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__UCHARv (GClosure *closure,
                                      GValue *return_value,
                                      gpointer instance,
                                      va_list args,
                                      gpointer marshal_data,
                                      int n_params,
                                      GType *param_types);


extern
void g_cclosure_marshal_VOID__INT (GClosure *closure,
                                   GValue *return_value,
                                   guint n_param_values,
                                   const GValue *param_values,
                                   gpointer invocation_hint,
                                   gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__INTv (GClosure *closure,
                                    GValue *return_value,
                                    gpointer instance,
                                    va_list args,
                                    gpointer marshal_data,
                                    int n_params,
                                    GType *param_types);


extern
void g_cclosure_marshal_VOID__UINT (GClosure *closure,
                                    GValue *return_value,
                                    guint n_param_values,
                                    const GValue *param_values,
                                    gpointer invocation_hint,
                                    gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__UINTv (GClosure *closure,
                                     GValue *return_value,
                                     gpointer instance,
                                     va_list args,
                                     gpointer marshal_data,
                                     int n_params,
                                     GType *param_types);


extern
void g_cclosure_marshal_VOID__LONG (GClosure *closure,
                                    GValue *return_value,
                                    guint n_param_values,
                                    const GValue *param_values,
                                    gpointer invocation_hint,
                                    gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__LONGv (GClosure *closure,
                                     GValue *return_value,
                                     gpointer instance,
                                     va_list args,
                                     gpointer marshal_data,
                                     int n_params,
                                     GType *param_types);


extern
void g_cclosure_marshal_VOID__ULONG (GClosure *closure,
                                     GValue *return_value,
                                     guint n_param_values,
                                     const GValue *param_values,
                                     gpointer invocation_hint,
                                     gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__ULONGv (GClosure *closure,
                                      GValue *return_value,
                                      gpointer instance,
                                      va_list args,
                                      gpointer marshal_data,
                                      int n_params,
                                      GType *param_types);


extern
void g_cclosure_marshal_VOID__ENUM (GClosure *closure,
                                    GValue *return_value,
                                    guint n_param_values,
                                    const GValue *param_values,
                                    gpointer invocation_hint,
                                    gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__ENUMv (GClosure *closure,
                                     GValue *return_value,
                                     gpointer instance,
                                     va_list args,
                                     gpointer marshal_data,
                                     int n_params,
                                     GType *param_types);


extern
void g_cclosure_marshal_VOID__FLAGS (GClosure *closure,
                                     GValue *return_value,
                                     guint n_param_values,
                                     const GValue *param_values,
                                     gpointer invocation_hint,
                                     gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__FLAGSv (GClosure *closure,
                                      GValue *return_value,
                                      gpointer instance,
                                      va_list args,
                                      gpointer marshal_data,
                                      int n_params,
                                      GType *param_types);


extern
void g_cclosure_marshal_VOID__FLOAT (GClosure *closure,
                                     GValue *return_value,
                                     guint n_param_values,
                                     const GValue *param_values,
                                     gpointer invocation_hint,
                                     gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__FLOATv (GClosure *closure,
                                      GValue *return_value,
                                      gpointer instance,
                                      va_list args,
                                      gpointer marshal_data,
                                      int n_params,
                                      GType *param_types);


extern
void g_cclosure_marshal_VOID__DOUBLE (GClosure *closure,
                                      GValue *return_value,
                                      guint n_param_values,
                                      const GValue *param_values,
                                      gpointer invocation_hint,
                                      gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__DOUBLEv (GClosure *closure,
                                       GValue *return_value,
                                       gpointer instance,
                                       va_list args,
                                       gpointer marshal_data,
                                       int n_params,
                                       GType *param_types);


extern
void g_cclosure_marshal_VOID__STRING (GClosure *closure,
                                      GValue *return_value,
                                      guint n_param_values,
                                      const GValue *param_values,
                                      gpointer invocation_hint,
                                      gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__STRINGv (GClosure *closure,
                                       GValue *return_value,
                                       gpointer instance,
                                       va_list args,
                                       gpointer marshal_data,
                                       int n_params,
                                       GType *param_types);


extern
void g_cclosure_marshal_VOID__PARAM (GClosure *closure,
                                     GValue *return_value,
                                     guint n_param_values,
                                     const GValue *param_values,
                                     gpointer invocation_hint,
                                     gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__PARAMv (GClosure *closure,
                                      GValue *return_value,
                                      gpointer instance,
                                      va_list args,
                                      gpointer marshal_data,
                                      int n_params,
                                      GType *param_types);


extern
void g_cclosure_marshal_VOID__BOXED (GClosure *closure,
                                     GValue *return_value,
                                     guint n_param_values,
                                     const GValue *param_values,
                                     gpointer invocation_hint,
                                     gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__BOXEDv (GClosure *closure,
                                      GValue *return_value,
                                      gpointer instance,
                                      va_list args,
                                      gpointer marshal_data,
                                      int n_params,
                                      GType *param_types);


extern
void g_cclosure_marshal_VOID__POINTER (GClosure *closure,
                                       GValue *return_value,
                                       guint n_param_values,
                                       const GValue *param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__POINTERv (GClosure *closure,
                                        GValue *return_value,
                                        gpointer instance,
                                        va_list args,
                                        gpointer marshal_data,
                                        int n_params,
                                        GType *param_types);


extern
void g_cclosure_marshal_VOID__OBJECT (GClosure *closure,
                                      GValue *return_value,
                                      guint n_param_values,
                                      const GValue *param_values,
                                      gpointer invocation_hint,
                                      gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__OBJECTv (GClosure *closure,
                                       GValue *return_value,
                                       gpointer instance,
                                       va_list args,
                                       gpointer marshal_data,
                                       int n_params,
                                       GType *param_types);


extern
void g_cclosure_marshal_VOID__VARIANT (GClosure *closure,
                                       GValue *return_value,
                                       guint n_param_values,
                                       const GValue *param_values,
                                       gpointer invocation_hint,
                                       gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__VARIANTv (GClosure *closure,
                                        GValue *return_value,
                                        gpointer instance,
                                        va_list args,
                                        gpointer marshal_data,
                                        int n_params,
                                        GType *param_types);


extern
void g_cclosure_marshal_VOID__UINT_POINTER (GClosure *closure,
                                            GValue *return_value,
                                            guint n_param_values,
                                            const GValue *param_values,
                                            gpointer invocation_hint,
                                            gpointer marshal_data);
extern
void g_cclosure_marshal_VOID__UINT_POINTERv (GClosure *closure,
                                             GValue *return_value,
                                             gpointer instance,
                                             va_list args,
                                             gpointer marshal_data,
                                             int n_params,
                                             GType *param_types);


extern
void g_cclosure_marshal_BOOLEAN__FLAGS (GClosure *closure,
                                        GValue *return_value,
                                        guint n_param_values,
                                        const GValue *param_values,
                                        gpointer invocation_hint,
                                        gpointer marshal_data);
extern
void g_cclosure_marshal_BOOLEAN__FLAGSv (GClosure *closure,
                                         GValue *return_value,
                                         gpointer instance,
                                         va_list args,
                                         gpointer marshal_data,
                                         int n_params,
                                         GType *param_types);



extern
void g_cclosure_marshal_STRING__OBJECT_POINTER (GClosure *closure,
                                                GValue *return_value,
                                                guint n_param_values,
                                                const GValue *param_values,
                                                gpointer invocation_hint,
                                                gpointer marshal_data);
extern
void g_cclosure_marshal_STRING__OBJECT_POINTERv (GClosure *closure,
                                                 GValue *return_value,
                                                 gpointer instance,
                                                 va_list args,
                                                 gpointer marshal_data,
                                                 int n_params,
                                                 GType *param_types);


extern
void g_cclosure_marshal_BOOLEAN__BOXED_BOXED (GClosure *closure,
                                              GValue *return_value,
                                              guint n_param_values,
                                              const GValue *param_values,
                                              gpointer invocation_hint,
                                              gpointer marshal_data);
extern
void g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv (GClosure *closure,
                                               GValue *return_value,
                                               gpointer instance,
                                               va_list args,
                                               gpointer marshal_data,
                                               int n_params,
                                               GType *param_types);



# 30 "/usr/include/glib-2.0/gobject/gsignal.h" 2




typedef struct _GSignalQuery GSignalQuery;
typedef struct _GSignalInvocationHint GSignalInvocationHint;
# 45 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef GClosureMarshal GSignalCMarshaller;







typedef GVaClosureMarshal GSignalCVaMarshaller;
# 72 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalEmissionHook) (GSignalInvocationHint *ihint,
      guint n_param_values,
      const GValue *param_values,
      gpointer data);
# 95 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef gboolean (*GSignalAccumulator) (GSignalInvocationHint *ihint,
      GValue *return_accu,
      const GValue *handler_return,
      gpointer data);
# 129 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum
{
  G_SIGNAL_RUN_FIRST = 1 << 0,
  G_SIGNAL_RUN_LAST = 1 << 1,
  G_SIGNAL_RUN_CLEANUP = 1 << 2,
  G_SIGNAL_NO_RECURSE = 1 << 3,
  G_SIGNAL_DETAILED = 1 << 4,
  G_SIGNAL_ACTION = 1 << 5,
  G_SIGNAL_NO_HOOKS = 1 << 6,
  G_SIGNAL_MUST_COLLECT = 1 << 7,
  G_SIGNAL_DEPRECATED = 1 << 8
} GSignalFlags;
# 157 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum
{
  G_CONNECT_AFTER = 1 << 0,
  G_CONNECT_SWAPPED = 1 << 1
} GConnectFlags;
# 175 "/usr/include/glib-2.0/gobject/gsignal.h"
typedef enum
{
  G_SIGNAL_MATCH_ID = 1 << 0,
  G_SIGNAL_MATCH_DETAIL = 1 << 1,
  G_SIGNAL_MATCH_CLOSURE = 1 << 2,
  G_SIGNAL_MATCH_FUNC = 1 << 3,
  G_SIGNAL_MATCH_DATA = 1 << 4,
  G_SIGNAL_MATCH_UNBLOCKED = 1 << 5
} GSignalMatchType;
# 226 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalInvocationHint
{
  guint signal_id;
  GQuark detail;
  GSignalFlags run_type;
};
# 252 "/usr/include/glib-2.0/gobject/gsignal.h"
struct _GSignalQuery
{
  guint signal_id;
  const gchar *signal_name;
  GType itype;
  GSignalFlags signal_flags;
  GType return_type;
  guint n_params;
  const GType *param_types;
};



extern
guint g_signal_newv (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          GClosure *class_closure,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          GType *param_types);
extern
guint g_signal_new_valist (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          GClosure *class_closure,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          va_list args);
extern
guint g_signal_new (const gchar *signal_name,
          GType itype,
          GSignalFlags signal_flags,
          guint class_offset,
          GSignalAccumulator accumulator,
          gpointer accu_data,
          GSignalCMarshaller c_marshaller,
          GType return_type,
          guint n_params,
          ...);
extern
guint g_signal_new_class_handler (const gchar *signal_name,
                                             GType itype,
                                             GSignalFlags signal_flags,
                                             GCallback class_handler,
                                             GSignalAccumulator accumulator,
                                             gpointer accu_data,
                                             GSignalCMarshaller c_marshaller,
                                             GType return_type,
                                             guint n_params,
                                             ...);
extern
void g_signal_set_va_marshaller (guint signal_id,
          GType instance_type,
          GSignalCVaMarshaller va_marshaller);

extern
void g_signal_emitv (const GValue *instance_and_params,
          guint signal_id,
          GQuark detail,
          GValue *return_value);
extern
void g_signal_emit_valist (gpointer instance,
          guint signal_id,
          GQuark detail,
          va_list var_args);
extern
void g_signal_emit (gpointer instance,
          guint signal_id,
          GQuark detail,
          ...);
extern
void g_signal_emit_by_name (gpointer instance,
          const gchar *detailed_signal,
          ...);
extern
guint g_signal_lookup (const gchar *name,
          GType itype);
extern
const gchar * g_signal_name (guint signal_id);
extern
void g_signal_query (guint signal_id,
          GSignalQuery *query);
extern
guint* g_signal_list_ids (GType itype,
          guint *n_ids);
extern
gboolean g_signal_parse_name (const gchar *detailed_signal,
          GType itype,
          guint *signal_id_p,
          GQuark *detail_p,
          gboolean force_detail_quark);
extern
GSignalInvocationHint* g_signal_get_invocation_hint (gpointer instance);



extern
void g_signal_stop_emission (gpointer instance,
          guint signal_id,
          GQuark detail);
extern
void g_signal_stop_emission_by_name (gpointer instance,
          const gchar *detailed_signal);
extern
gulong g_signal_add_emission_hook (guint signal_id,
          GQuark detail,
          GSignalEmissionHook hook_func,
          gpointer hook_data,
          GDestroyNotify data_destroy);
extern
void g_signal_remove_emission_hook (guint signal_id,
          gulong hook_id);



extern
gboolean g_signal_has_handler_pending (gpointer instance,
            guint signal_id,
            GQuark detail,
            gboolean may_be_blocked);
extern
gulong g_signal_connect_closure_by_id (gpointer instance,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gboolean after);
extern
gulong g_signal_connect_closure (gpointer instance,
            const gchar *detailed_signal,
            GClosure *closure,
            gboolean after);
extern
gulong g_signal_connect_data (gpointer instance,
            const gchar *detailed_signal,
            GCallback c_handler,
            gpointer data,
            GClosureNotify destroy_data,
            GConnectFlags connect_flags);
extern
void g_signal_handler_block (gpointer instance,
            gulong handler_id);
extern
void g_signal_handler_unblock (gpointer instance,
            gulong handler_id);
extern
void g_signal_handler_disconnect (gpointer instance,
            gulong handler_id);
extern
gboolean g_signal_handler_is_connected (gpointer instance,
            gulong handler_id);
extern
gulong g_signal_handler_find (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
extern
guint g_signal_handlers_block_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
extern
guint g_signal_handlers_unblock_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);
extern
guint g_signal_handlers_disconnect_matched (gpointer instance,
            GSignalMatchType mask,
            guint signal_id,
            GQuark detail,
            GClosure *closure,
            gpointer func,
            gpointer data);



extern
void g_signal_override_class_closure (guint signal_id,
                                               GType instance_type,
                                               GClosure *class_closure);
extern
void g_signal_override_class_handler (const gchar *signal_name,
                                               GType instance_type,
                                               GCallback class_handler);
extern
void g_signal_chain_from_overridden (const GValue *instance_and_params,
                                               GValue *return_value);
extern
void g_signal_chain_from_overridden_handler (gpointer instance,
                                               ...);
# 566 "/usr/include/glib-2.0/gobject/gsignal.h"
extern
gboolean g_signal_accumulator_true_handled (GSignalInvocationHint *ihint,
         GValue *return_accu,
         const GValue *handler_return,
         gpointer dummy);

extern
gboolean g_signal_accumulator_first_wins (GSignalInvocationHint *ihint,
                                            GValue *return_accu,
                                            const GValue *handler_return,
                                            gpointer dummy);


extern
void g_signal_handlers_destroy (gpointer instance);
void _g_signals_destroy (GType itype);


# 31 "/usr/include/glib-2.0/gobject/gobject.h" 2
# 1 "/usr/include/glib-2.0/gobject/gboxed.h" 1
# 29 "/usr/include/glib-2.0/gobject/gboxed.h"
# 1 "/usr/include/glib-2.0/gobject/glib-types.h" 1
# 28 "/usr/include/glib-2.0/gobject/glib-types.h"

# 275 "/usr/include/glib-2.0/gobject/glib-types.h"
extern
GType g_date_get_type (void) __attribute__((__const__));
extern
GType g_strv_get_type (void) __attribute__((__const__));
extern
GType g_gstring_get_type (void) __attribute__((__const__));
extern
GType g_hash_table_get_type (void) __attribute__((__const__));
extern
GType g_array_get_type (void) __attribute__((__const__));
extern
GType g_byte_array_get_type (void) __attribute__((__const__));
extern
GType g_ptr_array_get_type (void) __attribute__((__const__));
extern
GType g_bytes_get_type (void) __attribute__((__const__));
extern
GType g_variant_type_get_gtype (void) __attribute__((__const__));
extern
GType g_regex_get_type (void) __attribute__((__const__));
extern
GType g_match_info_get_type (void) __attribute__((__const__));
extern
GType g_error_get_type (void) __attribute__((__const__));
extern
GType g_date_time_get_type (void) __attribute__((__const__));
extern
GType g_time_zone_get_type (void) __attribute__((__const__));
extern
GType g_io_channel_get_type (void) __attribute__((__const__));
extern
GType g_io_condition_get_type (void) __attribute__((__const__));
extern
GType g_variant_builder_get_type (void) __attribute__((__const__));
extern
GType g_key_file_get_type (void) __attribute__((__const__));
extern
GType g_main_loop_get_type (void) __attribute__((__const__));
extern
GType g_main_context_get_type (void) __attribute__((__const__));
extern
GType g_source_get_type (void) __attribute__((__const__));
extern
GType g_pollfd_get_type (void) __attribute__((__const__));
extern
GType g_thread_get_type (void) __attribute__((__const__));
extern
GType g_checksum_get_type (void) __attribute__((__const__));
extern
GType g_markup_parse_context_get_type (void) __attribute__((__const__));

__attribute__((__deprecated__("Use '" "'G_TYPE_VARIANT'" "' instead"))) extern
GType g_variant_get_gtype (void) __attribute__((__const__));






typedef gchar** GStrv;


# 30 "/usr/include/glib-2.0/gobject/gboxed.h" 2



# 58 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef gpointer (*GBoxedCopyFunc) (gpointer boxed);
# 67 "/usr/include/glib-2.0/gobject/gboxed.h"
typedef void (*GBoxedFreeFunc) (gpointer boxed);



extern
gpointer g_boxed_copy (GType boxed_type,
                                           gconstpointer src_boxed);
extern
void g_boxed_free (GType boxed_type,
                                           gpointer boxed);
extern
void g_value_set_boxed (GValue *value,
                                           gconstpointer v_boxed);
extern
void g_value_set_static_boxed (GValue *value,
                                           gconstpointer v_boxed);
extern
void g_value_take_boxed (GValue *value,
                                           gconstpointer v_boxed);
__attribute__((__deprecated__("Use '" "g_value_take_boxed" "' instead"))) extern
void g_value_set_boxed_take_ownership (GValue *value,
                                           gconstpointer v_boxed);
extern
gpointer g_value_get_boxed (const GValue *value);
extern
gpointer g_value_dup_boxed (const GValue *value);



extern
GType g_boxed_type_register_static (const gchar *name,
                                           GBoxedCopyFunc boxed_copy,
                                           GBoxedFreeFunc boxed_free);
# 117 "/usr/include/glib-2.0/gobject/gboxed.h"
extern
GType g_closure_get_type (void) __attribute__((__const__));
extern
GType g_value_get_type (void) __attribute__((__const__));


# 32 "/usr/include/glib-2.0/gobject/gobject.h" 2


# 185 "/usr/include/glib-2.0/gobject/gobject.h"
typedef struct _GObject GObject;
typedef struct _GObjectClass GObjectClass;
typedef struct _GObject GInitiallyUnowned;
typedef struct _GObjectClass GInitiallyUnownedClass;
typedef struct _GObjectConstructParam GObjectConstructParam;
# 200 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectGetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
# 214 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GObjectSetPropertyFunc) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);






typedef void (*GObjectFinalizeFunc) (GObject *object);
# 235 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GWeakNotify) (gpointer data,
      GObject *where_the_object_was);






struct _GObject
{
  GTypeInstance g_type_instance;


  volatile guint ref_count;
  GData *qdata;
};
# 314 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectClass
{
  GTypeClass g_type_class;


  GSList *construct_properties;



  GObject* (*constructor) (GType type,
                                 guint n_construct_properties,
                                 GObjectConstructParam *construct_properties);

  void (*set_property) (GObject *object,
                                         guint property_id,
                                         const GValue *value,
                                         GParamSpec *pspec);
  void (*get_property) (GObject *object,
                                         guint property_id,
                                         GValue *value,
                                         GParamSpec *pspec);
  void (*dispose) (GObject *object);
  void (*finalize) (GObject *object);

  void (*dispatch_properties_changed) (GObject *object,
          guint n_pspecs,
          GParamSpec **pspecs);

  void (*notify) (GObject *object,
      GParamSpec *pspec);


  void (*constructed) (GObject *object);


  gsize flags;


  gpointer pdummy[6];
};
# 363 "/usr/include/glib-2.0/gobject/gobject.h"
struct _GObjectConstructParam
{
  GParamSpec *pspec;
  GValue *value;
};
# 384 "/usr/include/glib-2.0/gobject/gobject.h"
extern
GType g_initially_unowned_get_type (void);
extern
void g_object_class_install_property (GObjectClass *oclass,
            guint property_id,
            GParamSpec *pspec);
extern
GParamSpec* g_object_class_find_property (GObjectClass *oclass,
            const gchar *property_name);
extern
GParamSpec**g_object_class_list_properties (GObjectClass *oclass,
            guint *n_properties);
extern
void g_object_class_override_property (GObjectClass *oclass,
            guint property_id,
            const gchar *name);
extern
void g_object_class_install_properties (GObjectClass *oclass,
                                               guint n_pspecs,
                                               GParamSpec **pspecs);

extern
void g_object_interface_install_property (gpointer g_iface,
       GParamSpec *pspec);
extern
GParamSpec* g_object_interface_find_property (gpointer g_iface,
       const gchar *property_name);
extern
GParamSpec**g_object_interface_list_properties (gpointer g_iface,
       guint *n_properties_p);

extern
GType g_object_get_type (void) __attribute__((__const__));
extern
gpointer g_object_new (GType object_type,
            const gchar *first_property_name,
            ...);
extern
gpointer g_object_newv (GType object_type,
            guint n_parameters,
            GParameter *parameters);
extern
GObject* g_object_new_valist (GType object_type,
            const gchar *first_property_name,
            va_list var_args);
extern
void g_object_set (gpointer object,
            const gchar *first_property_name,
            ...) __attribute__((__sentinel__));
extern
void g_object_get (gpointer object,
            const gchar *first_property_name,
            ...) __attribute__((__sentinel__));
extern
gpointer g_object_connect (gpointer object,
            const gchar *signal_spec,
            ...) __attribute__((__sentinel__));
extern
void g_object_disconnect (gpointer object,
            const gchar *signal_spec,
            ...) __attribute__((__sentinel__));
extern
void g_object_set_valist (GObject *object,
            const gchar *first_property_name,
            va_list var_args);
extern
void g_object_get_valist (GObject *object,
            const gchar *first_property_name,
            va_list var_args);
extern
void g_object_set_property (GObject *object,
            const gchar *property_name,
            const GValue *value);
extern
void g_object_get_property (GObject *object,
            const gchar *property_name,
            GValue *value);
extern
void g_object_freeze_notify (GObject *object);
extern
void g_object_notify (GObject *object,
            const gchar *property_name);
extern
void g_object_notify_by_pspec (GObject *object,
            GParamSpec *pspec);
extern
void g_object_thaw_notify (GObject *object);
extern
gboolean g_object_is_floating (gpointer object);
extern
gpointer g_object_ref_sink (gpointer object);
extern
gpointer g_object_ref (gpointer object);
extern
void g_object_unref (gpointer object);
extern
void g_object_weak_ref (GObject *object,
            GWeakNotify notify,
            gpointer data);
extern
void g_object_weak_unref (GObject *object,
            GWeakNotify notify,
            gpointer data);
extern
void g_object_add_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);
extern
void g_object_remove_weak_pointer (GObject *object,
                                               gpointer *weak_pointer_location);
# 506 "/usr/include/glib-2.0/gobject/gobject.h"
typedef void (*GToggleNotify) (gpointer data,
          GObject *object,
          gboolean is_last_ref);

extern
void g_object_add_toggle_ref (GObject *object,
     GToggleNotify notify,
     gpointer data);
extern
void g_object_remove_toggle_ref (GObject *object,
     GToggleNotify notify,
     gpointer data);

extern
gpointer g_object_get_qdata (GObject *object,
            GQuark quark);
extern
void g_object_set_qdata (GObject *object,
            GQuark quark,
            gpointer data);
extern
void g_object_set_qdata_full (GObject *object,
            GQuark quark,
            gpointer data,
            GDestroyNotify destroy);
extern
gpointer g_object_steal_qdata (GObject *object,
            GQuark quark);

extern
gpointer g_object_dup_qdata (GObject *object,
                                               GQuark quark,
                                               GDuplicateFunc dup_func,
            gpointer user_data);
extern
gboolean g_object_replace_qdata (GObject *object,
                                               GQuark quark,
                                               gpointer oldval,
                                               gpointer newval,
                                               GDestroyNotify destroy,
            GDestroyNotify *old_destroy);

extern
gpointer g_object_get_data (GObject *object,
            const gchar *key);
extern
void g_object_set_data (GObject *object,
            const gchar *key,
            gpointer data);
extern
void g_object_set_data_full (GObject *object,
            const gchar *key,
            gpointer data,
            GDestroyNotify destroy);
extern
gpointer g_object_steal_data (GObject *object,
            const gchar *key);

extern
gpointer g_object_dup_data (GObject *object,
                                               const gchar *key,
                                               GDuplicateFunc dup_func,
            gpointer user_data);
extern
gboolean g_object_replace_data (GObject *object,
                                               const gchar *key,
                                               gpointer oldval,
                                               gpointer newval,
                                               GDestroyNotify destroy,
            GDestroyNotify *old_destroy);


extern
void g_object_watch_closure (GObject *object,
            GClosure *closure);
extern
GClosure* g_cclosure_new_object (GCallback callback_func,
            GObject *object);
extern
GClosure* g_cclosure_new_object_swap (GCallback callback_func,
            GObject *object);
extern
GClosure* g_closure_new_object (guint sizeof_closure,
            GObject *object);
extern
void g_value_set_object (GValue *value,
            gpointer v_object);
extern
gpointer g_value_get_object (const GValue *value);
extern
gpointer g_value_dup_object (const GValue *value);
extern
gulong g_signal_connect_object (gpointer instance,
            const gchar *detailed_signal,
            GCallback c_handler,
            gpointer gobject,
            GConnectFlags connect_flags);


extern
void g_object_force_floating (GObject *object);
extern
void g_object_run_dispose (GObject *object);


extern
void g_value_take_object (GValue *value,
            gpointer v_object);
__attribute__((__deprecated__("Use '" "g_value_take_object" "' instead"))) extern
void g_value_set_object_take_ownership (GValue *value,
                                               gpointer v_object);

__attribute__((__deprecated__)) extern
gsize g_object_compat_control (gsize what,
            gpointer data);
# 648 "/usr/include/glib-2.0/gobject/gobject.h"
extern
void g_clear_object (volatile GObject **object_ptr);


typedef struct {

    union { gpointer p; } priv;
} GWeakRef;

extern
void g_weak_ref_init (GWeakRef *weak_ref,
                                gpointer object);
extern
void g_weak_ref_clear (GWeakRef *weak_ref);
extern
gpointer g_weak_ref_get (GWeakRef *weak_ref);
extern
void g_weak_ref_set (GWeakRef *weak_ref,
                                gpointer object);


# 32 "/usr/include/glib-2.0/gobject/gbinding.h" 2


# 49 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef struct _GBinding GBinding;
# 67 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef gboolean (* GBindingTransformFunc) (GBinding *binding,
                                            const GValue *source_value,
                                            GValue *target_value,
                                            gpointer user_data);
# 95 "/usr/include/glib-2.0/gobject/gbinding.h"
typedef enum {
  G_BINDING_DEFAULT = 0,

  G_BINDING_BIDIRECTIONAL = 1 << 0,
  G_BINDING_SYNC_CREATE = 1 << 1,
  G_BINDING_INVERT_BOOLEAN = 1 << 2
} GBindingFlags;

extern
GType g_binding_flags_get_type (void) __attribute__((__const__));
extern
GType g_binding_get_type (void) __attribute__((__const__));

extern
GBindingFlags g_binding_get_flags (GBinding *binding);
extern
GObject * g_binding_get_source (GBinding *binding);
extern
GObject * g_binding_get_target (GBinding *binding);
extern
const gchar * g_binding_get_source_property (GBinding *binding);
extern
const gchar * g_binding_get_target_property (GBinding *binding);

extern
GBinding *g_object_bind_property (gpointer source,
                                                const gchar *source_property,
                                                gpointer target,
                                                const gchar *target_property,
                                                GBindingFlags flags);
extern
GBinding *g_object_bind_property_full (gpointer source,
                                                const gchar *source_property,
                                                gpointer target,
                                                const gchar *target_property,
                                                GBindingFlags flags,
                                                GBindingTransformFunc transform_to,
                                                GBindingTransformFunc transform_from,
                                                gpointer user_data,
                                                GDestroyNotify notify);
extern
GBinding *g_object_bind_property_with_closures (gpointer source,
                                                const gchar *source_property,
                                                gpointer target,
                                                const gchar *target_property,
                                                GBindingFlags flags,
                                                GClosure *transform_to,
                                                GClosure *transform_from);


# 26 "/usr/include/glib-2.0/glib-object.h" 2

# 1 "/usr/include/glib-2.0/gobject/genums.h" 1
# 28 "/usr/include/glib-2.0/gobject/genums.h"

# 140 "/usr/include/glib-2.0/gobject/genums.h"
typedef struct _GEnumClass GEnumClass;
typedef struct _GFlagsClass GFlagsClass;
typedef struct _GEnumValue GEnumValue;
typedef struct _GFlagsValue GFlagsValue;
# 157 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumClass
{
  GTypeClass g_type_class;


  gint minimum;
  gint maximum;
  guint n_values;
  GEnumValue *values;
};
# 178 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsClass
{
  GTypeClass g_type_class;


  guint mask;
  guint n_values;
  GFlagsValue *values;
};
# 196 "/usr/include/glib-2.0/gobject/genums.h"
struct _GEnumValue
{
  gint value;
  const gchar *value_name;
  const gchar *value_nick;
};
# 211 "/usr/include/glib-2.0/gobject/genums.h"
struct _GFlagsValue
{
  guint value;
  const gchar *value_name;
  const gchar *value_nick;
};



extern
GEnumValue* g_enum_get_value (GEnumClass *enum_class,
       gint value);
extern
GEnumValue* g_enum_get_value_by_name (GEnumClass *enum_class,
       const gchar *name);
extern
GEnumValue* g_enum_get_value_by_nick (GEnumClass *enum_class,
       const gchar *nick);
extern
GFlagsValue* g_flags_get_first_value (GFlagsClass *flags_class,
       guint value);
extern
GFlagsValue* g_flags_get_value_by_name (GFlagsClass *flags_class,
       const gchar *name);
extern
GFlagsValue* g_flags_get_value_by_nick (GFlagsClass *flags_class,
       const gchar *nick);
extern
void g_value_set_enum (GValue *value,
       gint v_enum);
extern
gint g_value_get_enum (const GValue *value);
extern
void g_value_set_flags (GValue *value,
       guint v_flags);
extern
guint g_value_get_flags (const GValue *value);







extern
GType g_enum_register_static (const gchar *name,
        const GEnumValue *const_static_values);
extern
GType g_flags_register_static (const gchar *name,
        const GFlagsValue *const_static_values);



extern
void g_enum_complete_type_info (GType g_enum_type,
        GTypeInfo *info,
        const GEnumValue *const_values);
extern
void g_flags_complete_type_info (GType g_flags_type,
        GTypeInfo *info,
        const GFlagsValue *const_values);


# 28 "/usr/include/glib-2.0/glib-object.h" 2


# 1 "/usr/include/glib-2.0/gobject/gparamspecs.h" 1
# 33 "/usr/include/glib-2.0/gobject/gparamspecs.h"

# 588 "/usr/include/glib-2.0/gobject/gparamspecs.h"
typedef struct _GParamSpecChar GParamSpecChar;
typedef struct _GParamSpecUChar GParamSpecUChar;
typedef struct _GParamSpecBoolean GParamSpecBoolean;
typedef struct _GParamSpecInt GParamSpecInt;
typedef struct _GParamSpecUInt GParamSpecUInt;
typedef struct _GParamSpecLong GParamSpecLong;
typedef struct _GParamSpecULong GParamSpecULong;
typedef struct _GParamSpecInt64 GParamSpecInt64;
typedef struct _GParamSpecUInt64 GParamSpecUInt64;
typedef struct _GParamSpecUnichar GParamSpecUnichar;
typedef struct _GParamSpecEnum GParamSpecEnum;
typedef struct _GParamSpecFlags GParamSpecFlags;
typedef struct _GParamSpecFloat GParamSpecFloat;
typedef struct _GParamSpecDouble GParamSpecDouble;
typedef struct _GParamSpecString GParamSpecString;
typedef struct _GParamSpecParam GParamSpecParam;
typedef struct _GParamSpecBoxed GParamSpecBoxed;
typedef struct _GParamSpecPointer GParamSpecPointer;
typedef struct _GParamSpecValueArray GParamSpecValueArray;
typedef struct _GParamSpecObject GParamSpecObject;
typedef struct _GParamSpecOverride GParamSpecOverride;
typedef struct _GParamSpecGType GParamSpecGType;
typedef struct _GParamSpecVariant GParamSpecVariant;
# 621 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecChar
{
  GParamSpec parent_instance;

  gint8 minimum;
  gint8 maximum;
  gint8 default_value;
};
# 638 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUChar
{
  GParamSpec parent_instance;

  guint8 minimum;
  guint8 maximum;
  guint8 default_value;
};







struct _GParamSpecBoolean
{
  GParamSpec parent_instance;

  gboolean default_value;
};
# 668 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt
{
  GParamSpec parent_instance;

  gint minimum;
  gint maximum;
  gint default_value;
};
# 685 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt
{
  GParamSpec parent_instance;

  guint minimum;
  guint maximum;
  guint default_value;
};
# 702 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecLong
{
  GParamSpec parent_instance;

  glong minimum;
  glong maximum;
  glong default_value;
};
# 719 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecULong
{
  GParamSpec parent_instance;

  gulong minimum;
  gulong maximum;
  gulong default_value;
};
# 736 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecInt64
{
  GParamSpec parent_instance;

  gint64 minimum;
  gint64 maximum;
  gint64 default_value;
};
# 753 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecUInt64
{
  GParamSpec parent_instance;

  guint64 minimum;
  guint64 maximum;
  guint64 default_value;
};







struct _GParamSpecUnichar
{
  GParamSpec parent_instance;

  gunichar default_value;
};
# 783 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecEnum
{
  GParamSpec parent_instance;

  GEnumClass *enum_class;
  gint default_value;
};
# 799 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFlags
{
  GParamSpec parent_instance;

  GFlagsClass *flags_class;
  guint default_value;
};
# 817 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecFloat
{
  GParamSpec parent_instance;

  gfloat minimum;
  gfloat maximum;
  gfloat default_value;
  gfloat epsilon;
};
# 837 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecDouble
{
  GParamSpec parent_instance;

  gdouble minimum;
  gdouble maximum;
  gdouble default_value;
  gdouble epsilon;
};
# 859 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecString
{
  GParamSpec parent_instance;

  gchar *default_value;
  gchar *cset_first;
  gchar *cset_nth;
  gchar substitutor;
  guint null_fold_if_empty : 1;
  guint ensure_non_null : 1;
};







struct _GParamSpecParam
{
  GParamSpec parent_instance;
};






struct _GParamSpecBoxed
{
  GParamSpec parent_instance;
};






struct _GParamSpecPointer
{
  GParamSpec parent_instance;
};
# 909 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecValueArray
{
  GParamSpec parent_instance;
  GParamSpec *element_spec;
  guint fixed_n_elements;
};






struct _GParamSpecObject
{
  GParamSpec parent_instance;
};
# 939 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecOverride
{

  GParamSpec parent_instance;
  GParamSpec *overridden;
};
# 954 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecGType
{
  GParamSpec parent_instance;
  GType is_a_type;
};
# 969 "/usr/include/glib-2.0/gobject/gparamspecs.h"
struct _GParamSpecVariant
{
  GParamSpec parent_instance;
  GVariantType *type;
  GVariant *default_value;


  gpointer padding[4];
};


extern
GParamSpec* g_param_spec_char (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint8 minimum,
       gint8 maximum,
       gint8 default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_uchar (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint8 minimum,
       guint8 maximum,
       guint8 default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_boolean (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gboolean default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_int (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint minimum,
       gint maximum,
       gint default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_uint (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint minimum,
       guint maximum,
       guint default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_long (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       glong minimum,
       glong maximum,
       glong default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_ulong (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gulong minimum,
       gulong maximum,
       gulong default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_int64 (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gint64 minimum,
       gint64 maximum,
       gint64 default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_uint64 (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       guint64 minimum,
       guint64 maximum,
       guint64 default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_unichar (const gchar *name,
              const gchar *nick,
              const gchar *blurb,
              gunichar default_value,
              GParamFlags flags);
extern
GParamSpec* g_param_spec_enum (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType enum_type,
       gint default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_flags (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType flags_type,
       guint default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_float (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gfloat minimum,
       gfloat maximum,
       gfloat default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_double (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       gdouble minimum,
       gdouble maximum,
       gdouble default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_string (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       const gchar *default_value,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_param (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType param_type,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_boxed (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType boxed_type,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_pointer (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_value_array (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GParamSpec *element_spec,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_object (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType object_type,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_override (const gchar *name,
       GParamSpec *overridden);
extern
GParamSpec* g_param_spec_gtype (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       GType is_a_type,
       GParamFlags flags);
extern
GParamSpec* g_param_spec_variant (const gchar *name,
       const gchar *nick,
       const gchar *blurb,
       const GVariantType *type,
       GVariant *default_value,
       GParamFlags flags);
# 1162 "/usr/include/glib-2.0/gobject/gparamspecs.h"
extern GType *g_param_spec_types;


# 31 "/usr/include/glib-2.0/glib-object.h" 2

# 1 "/usr/include/glib-2.0/gobject/gsourceclosure.h" 1
# 29 "/usr/include/glib-2.0/gobject/gsourceclosure.h"


extern
void g_source_set_closure (GSource *source,
      GClosure *closure);

extern
void g_source_set_dummy_callback (GSource *source);


# 33 "/usr/include/glib-2.0/glib-object.h" 2

# 1 "/usr/include/glib-2.0/gobject/gtypemodule.h" 1
# 29 "/usr/include/glib-2.0/gobject/gtypemodule.h"


typedef struct _GTypeModule GTypeModule;
typedef struct _GTypeModuleClass GTypeModuleClass;
# 48 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModule
{
  GObject parent_instance;

  guint use_count;
  GSList *type_infos;
  GSList *interface_infos;


  gchar *name;
};
# 70 "/usr/include/glib-2.0/gobject/gtypemodule.h"
struct _GTypeModuleClass
{
  GObjectClass parent_class;


  gboolean (* load) (GTypeModule *module);
  void (* unload) (GTypeModule *module);



  void (*reserved1) (void);
  void (*reserved2) (void);
  void (*reserved3) (void);
  void (*reserved4) (void);
};
# 240 "/usr/include/glib-2.0/gobject/gtypemodule.h"
extern
GType g_type_module_get_type (void) __attribute__((__const__));
extern
gboolean g_type_module_use (GTypeModule *module);
extern
void g_type_module_unuse (GTypeModule *module);
extern
void g_type_module_set_name (GTypeModule *module,
                                       const gchar *name);
extern
GType g_type_module_register_type (GTypeModule *module,
                                       GType parent_type,
                                       const gchar *type_name,
                                       const GTypeInfo *type_info,
                                       GTypeFlags flags);
extern
void g_type_module_add_interface (GTypeModule *module,
                                       GType instance_type,
                                       GType interface_type,
                                       const GInterfaceInfo *interface_info);
extern
GType g_type_module_register_enum (GTypeModule *module,
                                       const gchar *name,
                                       const GEnumValue *const_static_values);
extern
GType g_type_module_register_flags (GTypeModule *module,
                                       const gchar *name,
                                       const GFlagsValue *const_static_values);


# 35 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gtypeplugin.h" 1
# 28 "/usr/include/glib-2.0/gobject/gtypeplugin.h"

# 40 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef struct _GTypePluginClass GTypePluginClass;







typedef void (*GTypePluginUse) (GTypePlugin *plugin);






typedef void (*GTypePluginUnuse) (GTypePlugin *plugin);
# 65 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteTypeInfo) (GTypePlugin *plugin,
         GType g_type,
         GTypeInfo *info,
         GTypeValueTable *value_table);
# 79 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
typedef void (*GTypePluginCompleteInterfaceInfo) (GTypePlugin *plugin,
         GType instance_type,
         GType interface_type,
         GInterfaceInfo *info);
# 106 "/usr/include/glib-2.0/gobject/gtypeplugin.h"
struct _GTypePluginClass
{

  GTypeInterface base_iface;


  GTypePluginUse use_plugin;
  GTypePluginUnuse unuse_plugin;
  GTypePluginCompleteTypeInfo complete_type_info;
  GTypePluginCompleteInterfaceInfo complete_interface_info;
};



extern
GType g_type_plugin_get_type (void) __attribute__((__const__));
extern
void g_type_plugin_use (GTypePlugin *plugin);
extern
void g_type_plugin_unuse (GTypePlugin *plugin);
extern
void g_type_plugin_complete_type_info (GTypePlugin *plugin,
       GType g_type,
       GTypeInfo *info,
       GTypeValueTable *value_table);
extern
void g_type_plugin_complete_interface_info (GTypePlugin *plugin,
       GType instance_type,
       GType interface_type,
       GInterfaceInfo *info);


# 36 "/usr/include/glib-2.0/glib-object.h" 2

# 1 "/usr/include/glib-2.0/gobject/gvaluearray.h" 1
# 30 "/usr/include/glib-2.0/gobject/gvaluearray.h"

# 43 "/usr/include/glib-2.0/gobject/gvaluearray.h"
typedef struct _GValueArray GValueArray;







struct _GValueArray
{
  guint n_values;
  GValue *values;


  guint n_prealloced;
};


__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GType g_value_array_get_type (void) __attribute__((__const__));

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValue* g_value_array_get_nth (GValueArray *value_array,
           guint index_);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_new (guint n_prealloced);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
void g_value_array_free (GValueArray *value_array);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_copy (const GValueArray *value_array);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_prepend (GValueArray *value_array,
           const GValue *value);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_append (GValueArray *value_array,
           const GValue *value);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_insert (GValueArray *value_array,
           guint index_,
           const GValue *value);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_remove (GValueArray *value_array,
           guint index_);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_sort (GValueArray *value_array,
           GCompareFunc compare_func);

__attribute__((__deprecated__("Use '" "GArray" "' instead"))) extern
GValueArray* g_value_array_sort_with_data (GValueArray *value_array,
           GCompareDataFunc compare_func,
           gpointer user_data);



# 38 "/usr/include/glib-2.0/glib-object.h" 2
# 1 "/usr/include/glib-2.0/gobject/gvaluetypes.h" 1
# 30 "/usr/include/glib-2.0/gobject/gvaluetypes.h"

# 180 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
__attribute__((__deprecated__("Use '" "g_value_set_schar" "' instead"))) extern
void g_value_set_char (GValue *value,
                                                 gchar v_char);
__attribute__((__deprecated__("Use '" "g_value_get_schar" "' instead"))) extern
gchar g_value_get_char (const GValue *value);
extern
void g_value_set_schar (GValue *value,
       gint8 v_char);
extern
gint8 g_value_get_schar (const GValue *value);
extern
void g_value_set_uchar (GValue *value,
       guchar v_uchar);
extern
guchar g_value_get_uchar (const GValue *value);
extern
void g_value_set_boolean (GValue *value,
       gboolean v_boolean);
extern
gboolean g_value_get_boolean (const GValue *value);
extern
void g_value_set_int (GValue *value,
       gint v_int);
extern
gint g_value_get_int (const GValue *value);
extern
void g_value_set_uint (GValue *value,
       guint v_uint);
extern
guint g_value_get_uint (const GValue *value);
extern
void g_value_set_long (GValue *value,
       glong v_long);
extern
glong g_value_get_long (const GValue *value);
extern
void g_value_set_ulong (GValue *value,
       gulong v_ulong);
extern
gulong g_value_get_ulong (const GValue *value);
extern
void g_value_set_int64 (GValue *value,
       gint64 v_int64);
extern
gint64 g_value_get_int64 (const GValue *value);
extern
void g_value_set_uint64 (GValue *value,
       guint64 v_uint64);
extern
guint64 g_value_get_uint64 (const GValue *value);
extern
void g_value_set_float (GValue *value,
       gfloat v_float);
extern
gfloat g_value_get_float (const GValue *value);
extern
void g_value_set_double (GValue *value,
       gdouble v_double);
extern
gdouble g_value_get_double (const GValue *value);
extern
void g_value_set_string (GValue *value,
       const gchar *v_string);
extern
void g_value_set_static_string (GValue *value,
       const gchar *v_string);
extern
const gchar * g_value_get_string (const GValue *value);
extern
gchar* g_value_dup_string (const GValue *value);
extern
void g_value_set_pointer (GValue *value,
       gpointer v_pointer);
extern
gpointer g_value_get_pointer (const GValue *value);
extern
GType g_gtype_get_type (void);
extern
void g_value_set_gtype (GValue *value,
       GType v_gtype);
extern
GType g_value_get_gtype (const GValue *value);
extern
void g_value_set_variant (GValue *value,
       GVariant *variant);
extern
void g_value_take_variant (GValue *value,
       GVariant *variant);
extern
GVariant* g_value_get_variant (const GValue *value);
extern
GVariant* g_value_dup_variant (const GValue *value);



extern
GType g_pointer_type_register_static (const gchar *name);


extern
gchar* g_strdup_value_contents (const GValue *value);


extern
void g_value_take_string (GValue *value,
       gchar *v_string);
__attribute__((__deprecated__("Use '" "g_value_take_string" "' instead"))) extern
void g_value_set_string_take_ownership (GValue *value,
                                                 gchar *v_string);
# 297 "/usr/include/glib-2.0/gobject/gvaluetypes.h"
typedef gchar* gchararray;



# 39 "/usr/include/glib-2.0/glib-object.h" 2
# 32 "/usr/include/libpurple/account.h" 2


typedef struct _PurpleAccountUiOps PurpleAccountUiOps;

typedef struct _PurpleAccount PurpleAccount;

typedef gboolean (*PurpleFilterAccountFunc)(PurpleAccount *account);
typedef void (*PurpleAccountRequestAuthorizationCb)(void *);
typedef void (*PurpleAccountRegistrationCb)(PurpleAccount *account, gboolean succeeded, void *user_data);
typedef void (*PurpleAccountUnregistrationCb)(PurpleAccount *account, gboolean succeeded, void *user_data);
typedef void (*PurpleSetPublicAliasSuccessCallback)(PurpleAccount *account, const char *new_alias);
typedef void (*PurpleSetPublicAliasFailureCallback)(PurpleAccount *account, const char *error);
typedef void (*PurpleGetPublicAliasSuccessCallback)(PurpleAccount *account, const char *alias);
typedef void (*PurpleGetPublicAliasFailureCallback)(PurpleAccount *account, const char *error);

# 1 "/usr/include/libpurple/connection.h" 1
# 31 "/usr/include/libpurple/connection.h"
typedef struct _PurpleConnection PurpleConnection;




typedef enum
{
 PURPLE_CONNECTION_HTML = 0x0001,
 PURPLE_CONNECTION_NO_BGCOLOR = 0x0002,

 PURPLE_CONNECTION_AUTO_RESP = 0x0004,
 PURPLE_CONNECTION_FORMATTING_WBFO = 0x0008,
 PURPLE_CONNECTION_NO_NEWLINES = 0x0010,
 PURPLE_CONNECTION_NO_FONTSIZE = 0x0020,
 PURPLE_CONNECTION_NO_URLDESC = 0x0040,
 PURPLE_CONNECTION_NO_IMAGES = 0x0080,
 PURPLE_CONNECTION_ALLOW_CUSTOM_SMILEY = 0x0100,
 PURPLE_CONNECTION_SUPPORT_MOODS = 0x0200,
 PURPLE_CONNECTION_SUPPORT_MOOD_MESSAGES = 0x0400
} PurpleConnectionFlags;

typedef enum
{
 PURPLE_DISCONNECTED = 0,
 PURPLE_CONNECTED,
 PURPLE_CONNECTING

} PurpleConnectionState;






typedef enum
{




 PURPLE_CONNECTION_ERROR_NETWORK_ERROR = 0,

 PURPLE_CONNECTION_ERROR_INVALID_USERNAME = 1,




 PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED = 2,



 PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE = 3,



 PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT = 4,




 PURPLE_CONNECTION_ERROR_ENCRYPTION_ERROR = 5,



 PURPLE_CONNECTION_ERROR_NAME_IN_USE = 6,
# 106 "/usr/include/libpurple/connection.h"
 PURPLE_CONNECTION_ERROR_INVALID_SETTINGS = 7,


 PURPLE_CONNECTION_ERROR_CERT_NOT_PROVIDED = 8,

 PURPLE_CONNECTION_ERROR_CERT_UNTRUSTED = 9,

 PURPLE_CONNECTION_ERROR_CERT_EXPIRED = 10,

 PURPLE_CONNECTION_ERROR_CERT_NOT_ACTIVATED = 11,

 PURPLE_CONNECTION_ERROR_CERT_HOSTNAME_MISMATCH = 12,



 PURPLE_CONNECTION_ERROR_CERT_FINGERPRINT_MISMATCH = 13,

 PURPLE_CONNECTION_ERROR_CERT_SELF_SIGNED = 14,


 PURPLE_CONNECTION_ERROR_CERT_OTHER_ERROR = 15,
# 135 "/usr/include/libpurple/connection.h"
 PURPLE_CONNECTION_ERROR_OTHER_ERROR = 16
} PurpleConnectionError;


typedef struct
{

 PurpleConnectionError type;

 char *description;
} PurpleConnectionErrorInfo;



# 1 "/usr/include/libpurple/account.h" 1
# 150 "/usr/include/libpurple/connection.h" 2
# 1 "/usr/include/libpurple/plugin.h" 1
# 33 "/usr/include/libpurple/plugin.h"
# 1 "/usr/include/glib-2.0/gmodule.h" 1
# 32 "/usr/include/glib-2.0/gmodule.h"

# 44 "/usr/include/glib-2.0/gmodule.h"
typedef enum
{
  G_MODULE_BIND_LAZY = 1 << 0,
  G_MODULE_BIND_LOCAL = 1 << 1,
  G_MODULE_BIND_MASK = 0x03
} GModuleFlags;

typedef struct _GModule GModule;
typedef const gchar* (*GModuleCheckInit) (GModule *module);
typedef void (*GModuleUnload) (GModule *module);


extern
gboolean g_module_supported (void) __attribute__((__const__));


extern
GModule* g_module_open (const gchar *file_name,
           GModuleFlags flags);


extern
gboolean g_module_close (GModule *module);


extern
void g_module_make_resident (GModule *module);


extern
const gchar * g_module_error (void);


extern
gboolean g_module_symbol (GModule *module,
           const gchar *symbol_name,
           gpointer *symbol);


extern
const gchar * g_module_name (GModule *module);
# 97 "/usr/include/glib-2.0/gmodule.h"
extern
gchar* g_module_build_path (const gchar *directory,
           const gchar *module_name);
# 115 "/usr/include/glib-2.0/gmodule.h"

# 34 "/usr/include/libpurple/plugin.h" 2
# 1 "/usr/include/libpurple/signals.h" 1
# 30 "/usr/include/libpurple/signals.h"
# 1 "/usr/include/libpurple/value.h" 1
# 34 "/usr/include/libpurple/value.h"
typedef enum
{
 PURPLE_TYPE_UNKNOWN = 0,
 PURPLE_TYPE_SUBTYPE,
 PURPLE_TYPE_CHAR,
 PURPLE_TYPE_UCHAR,
 PURPLE_TYPE_BOOLEAN,
 PURPLE_TYPE_SHORT,
 PURPLE_TYPE_USHORT,
 PURPLE_TYPE_INT,
 PURPLE_TYPE_UINT,
 PURPLE_TYPE_LONG,
 PURPLE_TYPE_ULONG,
 PURPLE_TYPE_INT64,
 PURPLE_TYPE_UINT64,
 PURPLE_TYPE_STRING,
 PURPLE_TYPE_OBJECT,
 PURPLE_TYPE_POINTER,
 PURPLE_TYPE_ENUM,
 PURPLE_TYPE_BOXED

} PurpleType;





typedef enum
{
 PURPLE_SUBTYPE_UNKNOWN = 0,
 PURPLE_SUBTYPE_ACCOUNT,
 PURPLE_SUBTYPE_BLIST,
 PURPLE_SUBTYPE_BLIST_BUDDY,
 PURPLE_SUBTYPE_BLIST_GROUP,
 PURPLE_SUBTYPE_BLIST_CHAT,
 PURPLE_SUBTYPE_BUDDY_ICON,
 PURPLE_SUBTYPE_CONNECTION,
 PURPLE_SUBTYPE_CONVERSATION,
 PURPLE_SUBTYPE_PLUGIN,
 PURPLE_SUBTYPE_BLIST_NODE,
 PURPLE_SUBTYPE_CIPHER,
 PURPLE_SUBTYPE_STATUS,
 PURPLE_SUBTYPE_LOG,
 PURPLE_SUBTYPE_XFER,
 PURPLE_SUBTYPE_SAVEDSTATUS,
 PURPLE_SUBTYPE_XMLNODE,
 PURPLE_SUBTYPE_USERINFO,
 PURPLE_SUBTYPE_STORED_IMAGE,
 PURPLE_SUBTYPE_CERTIFICATEPOOL,
 PURPLE_SUBTYPE_CHATBUDDY
} PurpleSubType;




typedef struct
{
 PurpleType type;
 unsigned short flags;

 union
 {
  char char_data;
  unsigned char uchar_data;
  gboolean boolean_data;
  short short_data;
  unsigned short ushort_data;
  int int_data;
  unsigned int uint_data;
  long long_data;
  unsigned long ulong_data;
  gint64 int64_data;
  guint64 uint64_data;
  char *string_data;
  void *object_data;
  void *pointer_data;
  int enum_data;
  void *boxed_data;

 } data;

 union
 {
  unsigned int subtype;
  char *specific_type;

 } u;

} PurpleValue;
# 147 "/usr/include/libpurple/value.h"
PurpleValue *purple_value_new(PurpleType type, ...);
# 169 "/usr/include/libpurple/value.h"
PurpleValue *purple_value_new_outgoing(PurpleType type, ...);






void purple_value_destroy(PurpleValue *value);
# 185 "/usr/include/libpurple/value.h"
PurpleValue *purple_value_dup(const PurpleValue *value);
# 194 "/usr/include/libpurple/value.h"
PurpleType purple_value_get_type(const PurpleValue *value);
# 206 "/usr/include/libpurple/value.h"
unsigned int purple_value_get_subtype(const PurpleValue *value);
# 217 "/usr/include/libpurple/value.h"
const char *purple_value_get_specific_type(const PurpleValue *value);
# 226 "/usr/include/libpurple/value.h"
gboolean purple_value_is_outgoing(const PurpleValue *value);







void purple_value_set_char(PurpleValue *value, char data);







void purple_value_set_uchar(PurpleValue *value, unsigned char data);







void purple_value_set_boolean(PurpleValue *value, gboolean data);







void purple_value_set_short(PurpleValue *value, short data);







void purple_value_set_ushort(PurpleValue *value, unsigned short data);







void purple_value_set_int(PurpleValue *value, int data);







void purple_value_set_uint(PurpleValue *value, unsigned int data);







void purple_value_set_long(PurpleValue *value, long data);







void purple_value_set_ulong(PurpleValue *value, unsigned long data);







void purple_value_set_int64(PurpleValue *value, gint64 data);







void purple_value_set_uint64(PurpleValue *value, guint64 data);







void purple_value_set_string(PurpleValue *value, const char *data);







void purple_value_set_object(PurpleValue *value, void *data);







void purple_value_set_pointer(PurpleValue *value, void *data);







void purple_value_set_enum(PurpleValue *value, int data);







void purple_value_set_boxed(PurpleValue *value, void *data);
# 363 "/usr/include/libpurple/value.h"
char purple_value_get_char(const PurpleValue *value);
# 372 "/usr/include/libpurple/value.h"
unsigned char purple_value_get_uchar(const PurpleValue *value);
# 381 "/usr/include/libpurple/value.h"
gboolean purple_value_get_boolean(const PurpleValue *value);
# 390 "/usr/include/libpurple/value.h"
short purple_value_get_short(const PurpleValue *value);
# 399 "/usr/include/libpurple/value.h"
unsigned short purple_value_get_ushort(const PurpleValue *value);
# 408 "/usr/include/libpurple/value.h"
int purple_value_get_int(const PurpleValue *value);
# 417 "/usr/include/libpurple/value.h"
unsigned int purple_value_get_uint(const PurpleValue *value);
# 426 "/usr/include/libpurple/value.h"
long purple_value_get_long(const PurpleValue *value);
# 435 "/usr/include/libpurple/value.h"
unsigned long purple_value_get_ulong(const PurpleValue *value);
# 444 "/usr/include/libpurple/value.h"
gint64 purple_value_get_int64(const PurpleValue *value);
# 453 "/usr/include/libpurple/value.h"
guint64 purple_value_get_uint64(const PurpleValue *value);
# 462 "/usr/include/libpurple/value.h"
const char *purple_value_get_string(const PurpleValue *value);
# 471 "/usr/include/libpurple/value.h"
void *purple_value_get_object(const PurpleValue *value);
# 480 "/usr/include/libpurple/value.h"
void *purple_value_get_pointer(const PurpleValue *value);
# 489 "/usr/include/libpurple/value.h"
int purple_value_get_enum(const PurpleValue *value);
# 498 "/usr/include/libpurple/value.h"
void *purple_value_get_boxed(const PurpleValue *value);
# 31 "/usr/include/libpurple/signals.h" 2



typedef void (*PurpleCallback)(void);
typedef void (*PurpleSignalMarshalFunc)(PurpleCallback cb, va_list args,
           void *data, void **return_val);
# 82 "/usr/include/libpurple/signals.h"
gulong purple_signal_register(void *instance, const char *signal,
       PurpleSignalMarshalFunc marshal,
       PurpleValue *ret_value, int num_values, ...);







void purple_signal_unregister(void *instance, const char *signal);






void purple_signals_unregister_by_instance(void *instance);
# 110 "/usr/include/libpurple/signals.h"
void purple_signal_get_values(void *instance, const char *signal,
       PurpleValue **ret_value,
       int *num_values, PurpleValue ***values);
# 134 "/usr/include/libpurple/signals.h"
gulong purple_signal_connect_priority(void *instance, const char *signal,
 void *handle, PurpleCallback func, void *data, int priority);
# 154 "/usr/include/libpurple/signals.h"
gulong purple_signal_connect(void *instance, const char *signal,
 void *handle, PurpleCallback func, void *data);
# 180 "/usr/include/libpurple/signals.h"
gulong purple_signal_connect_priority_vargs(void *instance, const char *signal,
 void *handle, PurpleCallback func, void *data, int priority);
# 203 "/usr/include/libpurple/signals.h"
gulong purple_signal_connect_vargs(void *instance, const char *signal,
 void *handle, PurpleCallback func, void *data);
# 216 "/usr/include/libpurple/signals.h"
void purple_signal_disconnect(void *instance, const char *signal,
       void *handle, PurpleCallback func);






void purple_signals_disconnect_by_handle(void *handle);
# 235 "/usr/include/libpurple/signals.h"
void purple_signal_emit(void *instance, const char *signal, ...);
# 247 "/usr/include/libpurple/signals.h"
void purple_signal_emit_vargs(void *instance, const char *signal, va_list args);
# 260 "/usr/include/libpurple/signals.h"
void *purple_signal_emit_return_1(void *instance, const char *signal, ...);
# 274 "/usr/include/libpurple/signals.h"
void *purple_signal_emit_vargs_return_1(void *instance, const char *signal,
           va_list args);




void purple_signals_init(void);




void purple_signals_uninit(void);
# 294 "/usr/include/libpurple/signals.h"
void purple_marshal_VOID(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__INT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__INT_INT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_INT_INT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_INT_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_UINT_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_POINTER_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_POINTER_POINTER_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_VOID__POINTER_POINTER_POINTER_UINT_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);

void purple_marshal_INT__INT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_INT__INT_INT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_INT__POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_INT__POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_INT__POINTER_POINTER_POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);

void purple_marshal_BOOLEAN__POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_BOOLEAN(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_UINT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);

void purple_marshal_BOOLEAN__INT_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);

void purple_marshal_POINTER__POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_POINTER__POINTER_INT(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_POINTER__POINTER_INT64(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_POINTER__POINTER_INT_BOOLEAN(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_POINTER__POINTER_INT64_BOOLEAN(
  PurpleCallback cb, va_list args, void *data, void **return_val);
void purple_marshal_POINTER__POINTER_POINTER(
  PurpleCallback cb, va_list args, void *data, void **return_val);
# 35 "/usr/include/libpurple/plugin.h" 2



typedef struct _PurplePlugin PurplePlugin;

typedef struct _PurplePluginInfo PurplePluginInfo;

typedef struct _PurplePluginUiInfo PurplePluginUiInfo;

typedef struct _PurplePluginLoaderInfo PurplePluginLoaderInfo;


typedef struct _PurplePluginAction PurplePluginAction;

typedef int PurplePluginPriority;

# 1 "/usr/include/libpurple/pluginpref.h" 1
# 30 "/usr/include/libpurple/pluginpref.h"
typedef struct _PurplePluginPrefFrame PurplePluginPrefFrame;
typedef struct _PurplePluginPref PurplePluginPref;




typedef enum
{
 PURPLE_STRING_FORMAT_TYPE_NONE = 0,
 PURPLE_STRING_FORMAT_TYPE_MULTILINE = 1 << 0,
 PURPLE_STRING_FORMAT_TYPE_HTML = 1 << 1
} PurpleStringFormatType;

typedef enum {
 PURPLE_PLUGIN_PREF_NONE,
 PURPLE_PLUGIN_PREF_CHOICE,
 PURPLE_PLUGIN_PREF_INFO,
 PURPLE_PLUGIN_PREF_STRING_FORMAT
} PurplePluginPrefType;


# 1 "/usr/include/libpurple/prefs.h" 1
# 35 "/usr/include/libpurple/prefs.h"
typedef enum _PurplePrefType
{
 PURPLE_PREF_NONE,
 PURPLE_PREF_BOOLEAN,
 PURPLE_PREF_INT,
 PURPLE_PREF_STRING,
 PURPLE_PREF_STRING_LIST,
 PURPLE_PREF_PATH,
 PURPLE_PREF_PATH_LIST

} PurplePrefType;
# 62 "/usr/include/libpurple/prefs.h"
typedef void (*PurplePrefCallback) (const char *name, PurplePrefType type,
  gconstpointer val, gpointer data);
# 81 "/usr/include/libpurple/prefs.h"
void *purple_prefs_get_handle(void);




void purple_prefs_init(void);




void purple_prefs_uninit(void);






void purple_prefs_add_none(const char *name);







void purple_prefs_add_bool(const char *name, gboolean value);







void purple_prefs_add_int(const char *name, int value);







void purple_prefs_add_string(const char *name, const char *value);
# 133 "/usr/include/libpurple/prefs.h"
void purple_prefs_add_string_list(const char *name, GList *value);







void purple_prefs_add_path(const char *name, const char *value);
# 152 "/usr/include/libpurple/prefs.h"
void purple_prefs_add_path_list(const char *name, GList *value);







void purple_prefs_remove(const char *name);







void purple_prefs_rename(const char *oldname, const char *newname);







void purple_prefs_rename_boolean_toggle(const char *oldname, const char *newname);




void purple_prefs_destroy(void);
# 198 "/usr/include/libpurple/prefs.h"
void purple_prefs_set_generic(const char *name, gpointer value);







void purple_prefs_set_bool(const char *name, gboolean value);







void purple_prefs_set_int(const char *name, int value);







void purple_prefs_set_string(const char *name, const char *value);







void purple_prefs_set_string_list(const char *name, GList *value);







void purple_prefs_set_path(const char *name, const char *value);







void purple_prefs_set_path_list(const char *name, GList *value);
# 255 "/usr/include/libpurple/prefs.h"
gboolean purple_prefs_exists(const char *name);







PurplePrefType purple_prefs_get_type(const char *name);







gboolean purple_prefs_get_bool(const char *name);







int purple_prefs_get_int(const char *name);







const char *purple_prefs_get_string(const char *name);







GList *purple_prefs_get_string_list(const char *name);







const char *purple_prefs_get_path(const char *name);







GList *purple_prefs_get_path_list(const char *name);
# 323 "/usr/include/libpurple/prefs.h"
GList *purple_prefs_get_children_names(const char *name);
# 337 "/usr/include/libpurple/prefs.h"
guint purple_prefs_connect_callback(void *handle, const char *name, PurplePrefCallback cb,
  gpointer data);




void purple_prefs_disconnect_callback(guint callback_id);




void purple_prefs_disconnect_by_handle(void *handle);




void purple_prefs_trigger_callback(const char *name);




gboolean purple_prefs_load(void);




void purple_prefs_update_old(void);
# 52 "/usr/include/libpurple/pluginpref.h" 2
# 67 "/usr/include/libpurple/pluginpref.h"
PurplePluginPrefFrame *purple_plugin_pref_frame_new(void);






void purple_plugin_pref_frame_destroy(PurplePluginPrefFrame *frame);







void purple_plugin_pref_frame_add(PurplePluginPrefFrame *frame, PurplePluginPref *pref);







GList *purple_plugin_pref_frame_get_prefs(PurplePluginPrefFrame *frame);






PurplePluginPref *purple_plugin_pref_new(void);







PurplePluginPref *purple_plugin_pref_new_with_name(const char *name);







PurplePluginPref *purple_plugin_pref_new_with_label(const char *label);
# 122 "/usr/include/libpurple/pluginpref.h"
PurplePluginPref *purple_plugin_pref_new_with_name_and_label(const char *name, const char *label);






void purple_plugin_pref_destroy(PurplePluginPref *pref);







void purple_plugin_pref_set_name(PurplePluginPref *pref, const char *name);







const char *purple_plugin_pref_get_name(PurplePluginPref *pref);







void purple_plugin_pref_set_label(PurplePluginPref *pref, const char *label);







const char *purple_plugin_pref_get_label(PurplePluginPref *pref);
# 170 "/usr/include/libpurple/pluginpref.h"
void purple_plugin_pref_set_bounds(PurplePluginPref *pref, int min, int max);
# 179 "/usr/include/libpurple/pluginpref.h"
void purple_plugin_pref_get_bounds(PurplePluginPref *pref, int *min, int *max);







void purple_plugin_pref_set_type(PurplePluginPref *pref, PurplePluginPrefType type);







PurplePluginPrefType purple_plugin_pref_get_type(PurplePluginPref *pref);
# 204 "/usr/include/libpurple/pluginpref.h"
void purple_plugin_pref_add_choice(PurplePluginPref *pref, const char *label, gpointer choice);







GList *purple_plugin_pref_get_choices(PurplePluginPref *pref);







void purple_plugin_pref_set_max_length(PurplePluginPref *pref, unsigned int max_length);







unsigned int purple_plugin_pref_get_max_length(PurplePluginPref *pref);







void purple_plugin_pref_set_masked(PurplePluginPref *pref, gboolean mask);







gboolean purple_plugin_pref_get_masked(PurplePluginPref *pref);
# 253 "/usr/include/libpurple/pluginpref.h"
void purple_plugin_pref_set_format_type(PurplePluginPref *pref, PurpleStringFormatType format);







PurpleStringFormatType purple_plugin_pref_get_format_type(PurplePluginPref *pref);
# 52 "/usr/include/libpurple/plugin.h" 2




typedef enum
{
 PURPLE_PLUGIN_UNKNOWN = -1,
 PURPLE_PLUGIN_STANDARD = 0,
 PURPLE_PLUGIN_LOADER,
 PURPLE_PLUGIN_PROTOCOL

} PurplePluginType;
# 78 "/usr/include/libpurple/plugin.h"
struct _PurplePluginInfo
{
 unsigned int magic;
 unsigned int major_version;
 unsigned int minor_version;
 PurplePluginType type;
 char *ui_requirement;
 unsigned long flags;
 GList *dependencies;
 PurplePluginPriority priority;

 char *id;
 char *name;
 char *version;
 char *summary;
 char *description;
 char *author;
 char *homepage;





 gboolean (*load)(PurplePlugin *plugin);
 gboolean (*unload)(PurplePlugin *plugin);
 void (*destroy)(PurplePlugin *plugin);

 void *ui_info;
 void *extra_info;
 PurplePluginUiInfo *prefs_info;
# 122 "/usr/include/libpurple/plugin.h"
 GList *(*actions)(PurplePlugin *plugin, gpointer context);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};




struct _PurplePluginLoaderInfo
{
 GList *exts;

 gboolean (*probe)(PurplePlugin *plugin);
 gboolean (*load)(PurplePlugin *plugin);
 gboolean (*unload)(PurplePlugin *plugin);
 void (*destroy)(PurplePlugin *plugin);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};




struct _PurplePlugin
{
 gboolean native_plugin;
 gboolean loaded;
 void *handle;
 char *path;
 PurplePluginInfo *info;
 char *error;
 void *ipc_data;
 void *extra;
 gboolean unloadable;
 GList *dependent_plugins;

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};




struct _PurplePluginUiInfo {
 PurplePluginPrefFrame *(*get_plugin_pref_frame)(PurplePlugin *plugin);

 int page_num;
 PurplePluginPrefFrame *frame;

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};
# 195 "/usr/include/libpurple/plugin.h"
struct _PurplePluginAction {
 char *label;
 void (*callback)(PurplePluginAction *);


 PurplePlugin *plugin;



 gpointer context;

 gpointer user_data;
};
# 259 "/usr/include/libpurple/plugin.h"
PurplePlugin *purple_plugin_new(gboolean native, const char *path);
# 272 "/usr/include/libpurple/plugin.h"
PurplePlugin *purple_plugin_probe(const char *filename);
# 287 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_register(PurplePlugin *plugin);
# 299 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_load(PurplePlugin *plugin);
# 311 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_unload(PurplePlugin *plugin);
# 323 "/usr/include/libpurple/plugin.h"
void purple_plugin_disable(PurplePlugin *plugin);
# 335 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_reload(PurplePlugin *plugin);






void purple_plugin_destroy(PurplePlugin *plugin);
# 351 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_is_loaded(const PurplePlugin *plugin);
# 365 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_is_unloadable(const PurplePlugin *plugin);
# 374 "/usr/include/libpurple/plugin.h"
const gchar *purple_plugin_get_id(const PurplePlugin *plugin);
# 383 "/usr/include/libpurple/plugin.h"
const gchar *purple_plugin_get_name(const PurplePlugin *plugin);
# 392 "/usr/include/libpurple/plugin.h"
const gchar *purple_plugin_get_version(const PurplePlugin *plugin);
# 401 "/usr/include/libpurple/plugin.h"
const gchar *purple_plugin_get_summary(const PurplePlugin *plugin);
# 410 "/usr/include/libpurple/plugin.h"
const gchar *purple_plugin_get_description(const PurplePlugin *plugin);
# 419 "/usr/include/libpurple/plugin.h"
const gchar *purple_plugin_get_author(const PurplePlugin *plugin);
# 428 "/usr/include/libpurple/plugin.h"
const gchar *purple_plugin_get_homepage(const PurplePlugin *plugin);
# 451 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_ipc_register(PurplePlugin *plugin, const char *command,
          PurpleCallback func,
          PurpleSignalMarshalFunc marshal,
          PurpleValue *ret_value, int num_params, ...);







void purple_plugin_ipc_unregister(PurplePlugin *plugin, const char *command);






void purple_plugin_ipc_unregister_all(PurplePlugin *plugin);
# 482 "/usr/include/libpurple/plugin.h"
gboolean purple_plugin_ipc_get_params(PurplePlugin *plugin, const char *command,
         PurpleValue **ret_value, int *num_params,
         PurpleValue ***params);
# 497 "/usr/include/libpurple/plugin.h"
void *purple_plugin_ipc_call(PurplePlugin *plugin, const char *command,
         gboolean *ok, ...);
# 512 "/usr/include/libpurple/plugin.h"
void purple_plugins_add_search_path(const char *path);
# 521 "/usr/include/libpurple/plugin.h"
GList *purple_plugins_get_search_paths(void);




void purple_plugins_unload_all(void);




void purple_plugins_unload(PurplePluginType type);




void purple_plugins_destroy_all(void);






void purple_plugins_save_loaded(const char *key);







void purple_plugins_load_saved(const char *key);
# 560 "/usr/include/libpurple/plugin.h"
void purple_plugins_probe(const char *ext);






gboolean purple_plugins_enabled(void);
# 577 "/usr/include/libpurple/plugin.h"
void purple_plugins_register_probe_notify_cb(void (*func)(void *), void *data);
# 587 "/usr/include/libpurple/plugin.h"
void purple_plugins_unregister_probe_notify_cb(void (*func)(void *));
# 598 "/usr/include/libpurple/plugin.h"
void purple_plugins_register_load_notify_cb(void (*func)(PurplePlugin *, void *),
            void *data);
# 609 "/usr/include/libpurple/plugin.h"
void purple_plugins_unregister_load_notify_cb(void (*func)(PurplePlugin *, void *));
# 620 "/usr/include/libpurple/plugin.h"
void purple_plugins_register_unload_notify_cb(void (*func)(PurplePlugin *, void *),
           void *data);
# 631 "/usr/include/libpurple/plugin.h"
void purple_plugins_unregister_unload_notify_cb(void (*func)(PurplePlugin *,
                 void *));
# 642 "/usr/include/libpurple/plugin.h"
PurplePlugin *purple_plugins_find_with_name(const char *name);
# 651 "/usr/include/libpurple/plugin.h"
PurplePlugin *purple_plugins_find_with_filename(const char *filename);
# 660 "/usr/include/libpurple/plugin.h"
PurplePlugin *purple_plugins_find_with_basename(const char *basename);
# 669 "/usr/include/libpurple/plugin.h"
PurplePlugin *purple_plugins_find_with_id(const char *id);






GList *purple_plugins_get_loaded(void);
# 686 "/usr/include/libpurple/plugin.h"
GList *purple_plugins_get_protocols(void);






GList *purple_plugins_get_all(void);
# 707 "/usr/include/libpurple/plugin.h"
void *purple_plugins_get_handle(void);




void purple_plugins_init(void);




void purple_plugins_uninit(void);
# 727 "/usr/include/libpurple/plugin.h"
PurplePluginAction *purple_plugin_action_new(const char* label, void (*callback)(PurplePluginAction *));






void purple_plugin_action_free(PurplePluginAction *action);
# 151 "/usr/include/libpurple/connection.h" 2
# 1 "/usr/include/libpurple/status.h" 1
# 85 "/usr/include/libpurple/status.h"
typedef struct _PurpleStatusType PurpleStatusType;
typedef struct _PurpleStatusAttr PurpleStatusAttr;
typedef struct _PurplePresence PurplePresence;
typedef struct _PurpleStatus PurpleStatus;

typedef struct _PurpleMood {
 const char *mood;
 const char *description;
 gpointer *padding;
} PurpleMood;






typedef enum
{
 PURPLE_PRESENCE_CONTEXT_UNSET = 0,
 PURPLE_PRESENCE_CONTEXT_ACCOUNT,
 PURPLE_PRESENCE_CONTEXT_CONV,
 PURPLE_PRESENCE_CONTEXT_BUDDY

} PurplePresenceContext;
# 117 "/usr/include/libpurple/status.h"
typedef enum
{
 PURPLE_STATUS_UNSET = 0,
 PURPLE_STATUS_OFFLINE,
 PURPLE_STATUS_AVAILABLE,
 PURPLE_STATUS_UNAVAILABLE,
 PURPLE_STATUS_INVISIBLE,
 PURPLE_STATUS_AWAY,
 PURPLE_STATUS_EXTENDED_AWAY,
 PURPLE_STATUS_MOBILE,
 PURPLE_STATUS_TUNE,
 PURPLE_STATUS_MOOD,
 PURPLE_STATUS_NUM_PRIMITIVES
} PurpleStatusPrimitive;


# 1 "/usr/include/libpurple/blist.h" 1
# 35 "/usr/include/libpurple/blist.h"
typedef struct _PurpleBuddyList PurpleBuddyList;

typedef struct _PurpleBlistUiOps PurpleBlistUiOps;

typedef struct _PurpleBlistNode PurpleBlistNode;


typedef struct _PurpleChat PurpleChat;

typedef struct _PurpleGroup PurpleGroup;

typedef struct _PurpleContact PurpleContact;

typedef struct _PurpleBuddy PurpleBuddy;




typedef enum
{
 PURPLE_BLIST_GROUP_NODE,
 PURPLE_BLIST_CONTACT_NODE,
 PURPLE_BLIST_BUDDY_NODE,
 PURPLE_BLIST_CHAT_NODE,
 PURPLE_BLIST_OTHER_NODE

} PurpleBlistNodeType;
# 72 "/usr/include/libpurple/blist.h"
typedef enum
{
 PURPLE_BLIST_NODE_FLAG_NO_SAVE = 1 << 0

} PurpleBlistNodeFlags;
# 110 "/usr/include/libpurple/blist.h"
# 1 "/usr/include/libpurple/buddyicon.h" 1
# 34 "/usr/include/libpurple/buddyicon.h"
typedef struct _PurpleBuddyIcon PurpleBuddyIcon;


# 1 "/usr/include/libpurple/blist.h" 1
# 38 "/usr/include/libpurple/buddyicon.h" 2
# 1 "/usr/include/libpurple/imgstore.h" 1
# 37 "/usr/include/libpurple/imgstore.h"
typedef struct _PurpleStoredImage PurpleStoredImage;
# 66 "/usr/include/libpurple/imgstore.h"
PurpleStoredImage *
purple_imgstore_add(gpointer data, size_t size, const char *filename);
# 87 "/usr/include/libpurple/imgstore.h"
PurpleStoredImage *
purple_imgstore_new_from_file(const char *path);
# 112 "/usr/include/libpurple/imgstore.h"
int purple_imgstore_add_with_id(gpointer data, size_t size, const char *filename);
# 122 "/usr/include/libpurple/imgstore.h"
PurpleStoredImage *purple_imgstore_find_by_id(int id);
# 132 "/usr/include/libpurple/imgstore.h"
gconstpointer purple_imgstore_get_data(PurpleStoredImage *img);
# 142 "/usr/include/libpurple/imgstore.h"
size_t purple_imgstore_get_size(PurpleStoredImage *img);
# 152 "/usr/include/libpurple/imgstore.h"
const char *purple_imgstore_get_filename(const PurpleStoredImage *img);
# 163 "/usr/include/libpurple/imgstore.h"
const char *purple_imgstore_get_extension(PurpleStoredImage *img);
# 172 "/usr/include/libpurple/imgstore.h"
PurpleStoredImage *
purple_imgstore_ref(PurpleStoredImage *img);
# 184 "/usr/include/libpurple/imgstore.h"
PurpleStoredImage *
purple_imgstore_unref(PurpleStoredImage *img);
# 196 "/usr/include/libpurple/imgstore.h"
void purple_imgstore_ref_by_id(int id);
# 207 "/usr/include/libpurple/imgstore.h"
void purple_imgstore_unref_by_id(int id);






void *purple_imgstore_get_handle(void);




void purple_imgstore_init(void);




void purple_imgstore_uninit(void);
# 39 "/usr/include/libpurple/buddyicon.h" 2
# 1 "/usr/include/libpurple/prpl.h" 1
# 33 "/usr/include/libpurple/prpl.h"
typedef struct _PurplePluginProtocolInfo PurplePluginProtocolInfo;

typedef struct _PurpleAttentionType PurpleAttentionType;





typedef enum {
 PURPLE_ICON_SCALE_DISPLAY = 0x01,
 PURPLE_ICON_SCALE_SEND = 0x02
} PurpleIconScaleRules;







typedef struct _PurpleBuddyIconSpec PurpleBuddyIconSpec;






typedef struct _PurpleThumbnailSpec PurpleThumbnailSpec;
# 72 "/usr/include/libpurple/prpl.h"
# 1 "/usr/include/libpurple/conversation.h" 1
# 36 "/usr/include/libpurple/conversation.h"
typedef struct _PurpleConversationUiOps PurpleConversationUiOps;

typedef struct _PurpleConversation PurpleConversation;

typedef struct _PurpleConvIm PurpleConvIm;

typedef struct _PurpleConvChat PurpleConvChat;

typedef struct _PurpleConvChatBuddy PurpleConvChatBuddy;

typedef struct _PurpleConvMessage PurpleConvMessage;




typedef enum
{
 PURPLE_CONV_TYPE_UNKNOWN = 0,
 PURPLE_CONV_TYPE_IM,
 PURPLE_CONV_TYPE_CHAT,
 PURPLE_CONV_TYPE_MISC,
 PURPLE_CONV_TYPE_ANY

} PurpleConversationType;




typedef enum
{
 PURPLE_CONV_UPDATE_ADD = 0,

 PURPLE_CONV_UPDATE_REMOVE,

 PURPLE_CONV_UPDATE_ACCOUNT,
 PURPLE_CONV_UPDATE_TYPING,
 PURPLE_CONV_UPDATE_UNSEEN,
 PURPLE_CONV_UPDATE_LOGGING,

 PURPLE_CONV_UPDATE_TOPIC,




 PURPLE_CONV_ACCOUNT_ONLINE,
 PURPLE_CONV_ACCOUNT_OFFLINE,
 PURPLE_CONV_UPDATE_AWAY,
 PURPLE_CONV_UPDATE_ICON,
 PURPLE_CONV_UPDATE_TITLE,
 PURPLE_CONV_UPDATE_CHATLEFT,

 PURPLE_CONV_UPDATE_FEATURES

} PurpleConvUpdateType;




typedef enum
{
 PURPLE_NOT_TYPING = 0,
 PURPLE_TYPING,
 PURPLE_TYPED

} PurpleTypingState;




typedef enum
{
 PURPLE_MESSAGE_SEND = 0x0001,
 PURPLE_MESSAGE_RECV = 0x0002,
 PURPLE_MESSAGE_SYSTEM = 0x0004,
 PURPLE_MESSAGE_AUTO_RESP = 0x0008,
 PURPLE_MESSAGE_ACTIVE_ONLY = 0x0010,






 PURPLE_MESSAGE_NICK = 0x0020,
 PURPLE_MESSAGE_NO_LOG = 0x0040,
 PURPLE_MESSAGE_WHISPER = 0x0080,
 PURPLE_MESSAGE_ERROR = 0x0200,
 PURPLE_MESSAGE_DELAYED = 0x0400,
 PURPLE_MESSAGE_RAW = 0x0800,

 PURPLE_MESSAGE_IMAGES = 0x1000,
 PURPLE_MESSAGE_NOTIFY = 0x2000,
 PURPLE_MESSAGE_NO_LINKIFY = 0x4000,

 PURPLE_MESSAGE_INVISIBLE = 0x8000
} PurpleMessageFlags;




typedef enum
{
 PURPLE_CBFLAGS_NONE = 0x0000,
 PURPLE_CBFLAGS_VOICE = 0x0001,
 PURPLE_CBFLAGS_HALFOP = 0x0002,
 PURPLE_CBFLAGS_OP = 0x0004,
 PURPLE_CBFLAGS_FOUNDER = 0x0008,
 PURPLE_CBFLAGS_TYPING = 0x0010,
 PURPLE_CBFLAGS_AWAY = 0x0020

} PurpleConvChatBuddyFlags;


# 1 "/usr/include/libpurple/buddyicon.h" 1
# 149 "/usr/include/libpurple/conversation.h" 2
# 1 "/usr/include/libpurple/log.h" 1
# 30 "/usr/include/libpurple/log.h"
# 1 "/usr/include/stdio.h" 1 3 4
# 29 "/usr/include/stdio.h" 3 4




# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 34 "/usr/include/stdio.h" 2 3 4
# 44 "/usr/include/stdio.h" 3 4
struct _IO_FILE;



typedef struct _IO_FILE FILE;





# 64 "/usr/include/stdio.h" 3 4
typedef struct _IO_FILE __FILE;
# 74 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/libio.h" 1 3 4
# 32 "/usr/include/libio.h" 3 4
# 1 "/usr/include/_G_config.h" 1 3 4
# 15 "/usr/include/_G_config.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 16 "/usr/include/_G_config.h" 2 3 4




# 1 "/usr/include/wchar.h" 1 3 4
# 82 "/usr/include/wchar.h" 3 4
typedef struct
{
  int __count;
  union
  {

    unsigned int __wch;



    char __wchb[4];
  } __value;
} __mbstate_t;
# 21 "/usr/include/_G_config.h" 2 3 4
typedef struct
{
  __off_t __pos;
  __mbstate_t __state;
} _G_fpos_t;
typedef struct
{
  __off64_t __pos;
  __mbstate_t __state;
} _G_fpos64_t;
# 33 "/usr/include/libio.h" 2 3 4
# 145 "/usr/include/libio.h" 3 4
struct _IO_jump_t; struct _IO_FILE;
# 155 "/usr/include/libio.h" 3 4
typedef void _IO_lock_t;





struct _IO_marker {
  struct _IO_marker *_next;
  struct _IO_FILE *_sbuf;



  int _pos;
# 178 "/usr/include/libio.h" 3 4
};


enum __codecvt_result
{
  __codecvt_ok,
  __codecvt_partial,
  __codecvt_error,
  __codecvt_noconv
};
# 246 "/usr/include/libio.h" 3 4
struct _IO_FILE {
  int _flags;




  char* _IO_read_ptr;
  char* _IO_read_end;
  char* _IO_read_base;
  char* _IO_write_base;
  char* _IO_write_ptr;
  char* _IO_write_end;
  char* _IO_buf_base;
  char* _IO_buf_end;

  char *_IO_save_base;
  char *_IO_backup_base;
  char *_IO_save_end;

  struct _IO_marker *_markers;

  struct _IO_FILE *_chain;

  int _fileno;



  int _flags2;

  __off_t _old_offset;



  unsigned short _cur_column;
  signed char _vtable_offset;
  char _shortbuf[1];



  _IO_lock_t *_lock;
# 294 "/usr/include/libio.h" 3 4
  __off64_t _offset;
# 303 "/usr/include/libio.h" 3 4
  void *__pad1;
  void *__pad2;
  void *__pad3;
  void *__pad4;
  size_t __pad5;

  int _mode;

  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];

};


typedef struct _IO_FILE _IO_FILE;


struct _IO_FILE_plus;

extern struct _IO_FILE_plus _IO_2_1_stdin_;
extern struct _IO_FILE_plus _IO_2_1_stdout_;
extern struct _IO_FILE_plus _IO_2_1_stderr_;
# 339 "/usr/include/libio.h" 3 4
typedef __ssize_t __io_read_fn (void *__cookie, char *__buf, size_t __nbytes);







typedef __ssize_t __io_write_fn (void *__cookie, const char *__buf,
     size_t __n);







typedef int __io_seek_fn (void *__cookie, __off64_t *__pos, int __w);


typedef int __io_close_fn (void *__cookie);
# 391 "/usr/include/libio.h" 3 4
extern int __underflow (_IO_FILE *);
extern int __uflow (_IO_FILE *);
extern int __overflow (_IO_FILE *, int);
# 435 "/usr/include/libio.h" 3 4
extern int _IO_getc (_IO_FILE *__fp);
extern int _IO_putc (int __c, _IO_FILE *__fp);
extern int _IO_feof (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ferror (_IO_FILE *__fp) __attribute__ ((__nothrow__ , __leaf__));

extern int _IO_peekc_locked (_IO_FILE *__fp);





extern void _IO_flockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern void _IO_funlockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
extern int _IO_ftrylockfile (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 465 "/usr/include/libio.h" 3 4
extern int _IO_vfscanf (_IO_FILE * __restrict, const char * __restrict,
   __gnuc_va_list, int *__restrict);
extern int _IO_vfprintf (_IO_FILE *__restrict, const char *__restrict,
    __gnuc_va_list);
extern __ssize_t _IO_padn (_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn (_IO_FILE *, void *, size_t);

extern __off64_t _IO_seekoff (_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos (_IO_FILE *, __off64_t, int);

extern void _IO_free_backup_area (_IO_FILE *) __attribute__ ((__nothrow__ , __leaf__));
# 75 "/usr/include/stdio.h" 2 3 4
# 108 "/usr/include/stdio.h" 3 4


typedef _G_fpos_t fpos_t;




# 164 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio_lim.h" 1 3 4
# 165 "/usr/include/stdio.h" 2 3 4



extern struct _IO_FILE *stdin;
extern struct _IO_FILE *stdout;
extern struct _IO_FILE *stderr;







extern int remove (const char *__filename) __attribute__ ((__nothrow__ , __leaf__));

extern int rename (const char *__old, const char *__new) __attribute__ ((__nothrow__ , __leaf__));




extern int renameat (int __oldfd, const char *__old, int __newfd,
       const char *__new) __attribute__ ((__nothrow__ , __leaf__));








extern FILE *tmpfile (void) ;
# 209 "/usr/include/stdio.h" 3 4
extern char *tmpnam (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;





extern char *tmpnam_r (char *__s) __attribute__ ((__nothrow__ , __leaf__)) ;
# 227 "/usr/include/stdio.h" 3 4
extern char *tempnam (const char *__dir, const char *__pfx)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__malloc__)) ;








extern int fclose (FILE *__stream);




extern int fflush (FILE *__stream);

# 252 "/usr/include/stdio.h" 3 4
extern int fflush_unlocked (FILE *__stream);
# 266 "/usr/include/stdio.h" 3 4






extern FILE *fopen (const char *__restrict __filename,
      const char *__restrict __modes) ;




extern FILE *freopen (const char *__restrict __filename,
        const char *__restrict __modes,
        FILE *__restrict __stream) ;
# 295 "/usr/include/stdio.h" 3 4

# 306 "/usr/include/stdio.h" 3 4
extern FILE *fdopen (int __fd, const char *__modes) __attribute__ ((__nothrow__ , __leaf__)) ;
# 319 "/usr/include/stdio.h" 3 4
extern FILE *fmemopen (void *__s, size_t __len, const char *__modes)
  __attribute__ ((__nothrow__ , __leaf__)) ;




extern FILE *open_memstream (char **__bufloc, size_t *__sizeloc) __attribute__ ((__nothrow__ , __leaf__)) ;






extern void setbuf (FILE *__restrict __stream, char *__restrict __buf) __attribute__ ((__nothrow__ , __leaf__));



extern int setvbuf (FILE *__restrict __stream, char *__restrict __buf,
      int __modes, size_t __n) __attribute__ ((__nothrow__ , __leaf__));





extern void setbuffer (FILE *__restrict __stream, char *__restrict __buf,
         size_t __size) __attribute__ ((__nothrow__ , __leaf__));


extern void setlinebuf (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));








extern int fprintf (FILE *__restrict __stream,
      const char *__restrict __format, ...);




extern int printf (const char *__restrict __format, ...);

extern int sprintf (char *__restrict __s,
      const char *__restrict __format, ...) __attribute__ ((__nothrow__));





extern int vfprintf (FILE *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg);




extern int vprintf (const char *__restrict __format, __gnuc_va_list __arg);

extern int vsprintf (char *__restrict __s, const char *__restrict __format,
       __gnuc_va_list __arg) __attribute__ ((__nothrow__));





extern int snprintf (char *__restrict __s, size_t __maxlen,
       const char *__restrict __format, ...)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 4)));

extern int vsnprintf (char *__restrict __s, size_t __maxlen,
        const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__)) __attribute__ ((__format__ (__printf__, 3, 0)));

# 412 "/usr/include/stdio.h" 3 4
extern int vdprintf (int __fd, const char *__restrict __fmt,
       __gnuc_va_list __arg)
     __attribute__ ((__format__ (__printf__, 2, 0)));
extern int dprintf (int __fd, const char *__restrict __fmt, ...)
     __attribute__ ((__format__ (__printf__, 2, 3)));








extern int fscanf (FILE *__restrict __stream,
     const char *__restrict __format, ...) ;




extern int scanf (const char *__restrict __format, ...) ;

extern int sscanf (const char *__restrict __s,
     const char *__restrict __format, ...) __attribute__ ((__nothrow__ , __leaf__));
# 443 "/usr/include/stdio.h" 3 4
extern int fscanf (FILE *__restrict __stream, const char *__restrict __format, ...) __asm__ ("" "__isoc99_fscanf")

                               ;
extern int scanf (const char *__restrict __format, ...) __asm__ ("" "__isoc99_scanf")
                              ;
extern int sscanf (const char *__restrict __s, const char *__restrict __format, ...) __asm__ ("" "__isoc99_sscanf") __attribute__ ((__nothrow__ , __leaf__))

                      ;
# 463 "/usr/include/stdio.h" 3 4








extern int vfscanf (FILE *__restrict __s, const char *__restrict __format,
      __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 2, 0))) ;





extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__format__ (__scanf__, 1, 0))) ;


extern int vsscanf (const char *__restrict __s,
      const char *__restrict __format, __gnuc_va_list __arg)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__format__ (__scanf__, 2, 0)));
# 494 "/usr/include/stdio.h" 3 4
extern int vfscanf (FILE *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vfscanf")



     __attribute__ ((__format__ (__scanf__, 2, 0))) ;
extern int vscanf (const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vscanf")

     __attribute__ ((__format__ (__scanf__, 1, 0))) ;
extern int vsscanf (const char *__restrict __s, const char *__restrict __format, __gnuc_va_list __arg) __asm__ ("" "__isoc99_vsscanf") __attribute__ ((__nothrow__ , __leaf__))



     __attribute__ ((__format__ (__scanf__, 2, 0)));
# 522 "/usr/include/stdio.h" 3 4









extern int fgetc (FILE *__stream);
extern int getc (FILE *__stream);





extern int getchar (void);

# 550 "/usr/include/stdio.h" 3 4
extern int getc_unlocked (FILE *__stream);
extern int getchar_unlocked (void);
# 561 "/usr/include/stdio.h" 3 4
extern int fgetc_unlocked (FILE *__stream);











extern int fputc (int __c, FILE *__stream);
extern int putc (int __c, FILE *__stream);





extern int putchar (int __c);

# 594 "/usr/include/stdio.h" 3 4
extern int fputc_unlocked (int __c, FILE *__stream);







extern int putc_unlocked (int __c, FILE *__stream);
extern int putchar_unlocked (int __c);






extern int getw (FILE *__stream);


extern int putw (int __w, FILE *__stream);








extern char *fgets (char *__restrict __s, int __n, FILE *__restrict __stream)
     ;
# 638 "/usr/include/stdio.h" 3 4
extern char *gets (char *__s) __attribute__ ((__deprecated__));


# 665 "/usr/include/stdio.h" 3 4
extern __ssize_t __getdelim (char **__restrict __lineptr,
          size_t *__restrict __n, int __delimiter,
          FILE *__restrict __stream) ;
extern __ssize_t getdelim (char **__restrict __lineptr,
        size_t *__restrict __n, int __delimiter,
        FILE *__restrict __stream) ;







extern __ssize_t getline (char **__restrict __lineptr,
       size_t *__restrict __n,
       FILE *__restrict __stream) ;








extern int fputs (const char *__restrict __s, FILE *__restrict __stream);





extern int puts (const char *__s);






extern int ungetc (int __c, FILE *__stream);






extern size_t fread (void *__restrict __ptr, size_t __size,
       size_t __n, FILE *__restrict __stream) ;




extern size_t fwrite (const void *__restrict __ptr, size_t __size,
        size_t __n, FILE *__restrict __s);

# 737 "/usr/include/stdio.h" 3 4
extern size_t fread_unlocked (void *__restrict __ptr, size_t __size,
         size_t __n, FILE *__restrict __stream) ;
extern size_t fwrite_unlocked (const void *__restrict __ptr, size_t __size,
          size_t __n, FILE *__restrict __stream);








extern int fseek (FILE *__stream, long int __off, int __whence);




extern long int ftell (FILE *__stream) ;




extern void rewind (FILE *__stream);

# 773 "/usr/include/stdio.h" 3 4
extern int fseeko (FILE *__stream, __off_t __off, int __whence);




extern __off_t ftello (FILE *__stream) ;
# 792 "/usr/include/stdio.h" 3 4






extern int fgetpos (FILE *__restrict __stream, fpos_t *__restrict __pos);




extern int fsetpos (FILE *__stream, const fpos_t *__pos);
# 815 "/usr/include/stdio.h" 3 4

# 824 "/usr/include/stdio.h" 3 4


extern void clearerr (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));

extern int feof (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;

extern int ferror (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern void clearerr_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
extern int feof_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
extern int ferror_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;








extern void perror (const char *__s);






# 1 "/usr/include/bits/sys_errlist.h" 1 3 4
# 26 "/usr/include/bits/sys_errlist.h" 3 4
extern int sys_nerr;
extern const char *const sys_errlist[];
# 854 "/usr/include/stdio.h" 2 3 4




extern int fileno (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;




extern int fileno_unlocked (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;
# 873 "/usr/include/stdio.h" 3 4
extern FILE *popen (const char *__command, const char *__modes) ;





extern int pclose (FILE *__stream);





extern char *ctermid (char *__s) __attribute__ ((__nothrow__ , __leaf__));
# 913 "/usr/include/stdio.h" 3 4
extern void flockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));



extern int ftrylockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__)) ;


extern void funlockfile (FILE *__stream) __attribute__ ((__nothrow__ , __leaf__));
# 934 "/usr/include/stdio.h" 3 4
# 1 "/usr/include/bits/stdio.h" 1 3 4
# 35 "/usr/include/bits/stdio.h" 3 4
extern __inline int
vprintf (const char *__restrict __fmt, __gnuc_va_list __arg)
{
  return vfprintf (stdout, __fmt, __arg);
}



extern __inline int
getchar (void)
{
  return _IO_getc (stdin);
}




extern __inline int
fgetc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}





extern __inline int
getc_unlocked (FILE *__fp)
{
  return (__builtin_expect (((__fp)->_IO_read_ptr >= (__fp)->_IO_read_end), 0) ? __uflow (__fp) : *(unsigned char *) (__fp)->_IO_read_ptr++);
}


extern __inline int
getchar_unlocked (void)
{
  return (__builtin_expect (((stdin)->_IO_read_ptr >= (stdin)->_IO_read_end), 0) ? __uflow (stdin) : *(unsigned char *) (stdin)->_IO_read_ptr++);
}




extern __inline int
putchar (int __c)
{
  return _IO_putc (__c, stdout);
}




extern __inline int
fputc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}





extern __inline int
putc_unlocked (int __c, FILE *__stream)
{
  return (__builtin_expect (((__stream)->_IO_write_ptr >= (__stream)->_IO_write_end), 0) ? __overflow (__stream, (unsigned char) (__c)) : (unsigned char) (*(__stream)->_IO_write_ptr++ = (__c)));
}


extern __inline int
putchar_unlocked (int __c)
{
  return (__builtin_expect (((stdout)->_IO_write_ptr >= (stdout)->_IO_write_end), 0) ? __overflow (stdout, (unsigned char) (__c)) : (unsigned char) (*(stdout)->_IO_write_ptr++ = (__c)));
}
# 124 "/usr/include/bits/stdio.h" 3 4
extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) feof_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x10) != 0);
}


extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) ferror_unlocked (FILE *__stream)
{
  return (((__stream)->_flags & 0x20) != 0);
}
# 935 "/usr/include/stdio.h" 2 3 4
# 943 "/usr/include/stdio.h" 3 4

# 31 "/usr/include/libpurple/log.h" 2






typedef struct _PurpleLog PurpleLog;
typedef struct _PurpleLogLogger PurpleLogLogger;
typedef struct _PurpleLogCommonLoggerData PurpleLogCommonLoggerData;
typedef struct _PurpleLogSet PurpleLogSet;

typedef enum {
 PURPLE_LOG_IM,
 PURPLE_LOG_CHAT,
 PURPLE_LOG_SYSTEM
} PurpleLogType;

typedef enum {
 PURPLE_LOG_READ_NO_NEWLINE = 1
} PurpleLogReadFlags;


# 1 "/usr/include/libpurple/conversation.h" 1
# 54 "/usr/include/libpurple/log.h" 2

typedef void (*PurpleLogSetCallback) (GHashTable *sets, PurpleLogSet *set);







struct _PurpleLogLogger {
 char *name;
 char *id;



 void (*create)(PurpleLog *log);


 gsize (*write)(PurpleLog *log,
       PurpleMessageFlags type,
       const char *from,
       time_t time,
       const char *message);


 void (*finalize)(PurpleLog *log);


 GList *(*list)(PurpleLogType type, const char *name, PurpleAccount *account);



 char *(*read)(PurpleLog *log, PurpleLogReadFlags *flags);



 int (*size)(PurpleLog *log);



 int (*total_size)(PurpleLogType type, const char *name, PurpleAccount *account);


 GList *(*list_syslog)(PurpleAccount *account);
# 107 "/usr/include/libpurple/log.h"
 void (*get_log_sets)(PurpleLogSetCallback cb, GHashTable *sets);


 gboolean (*remove)(PurpleLog *log);


 gboolean (*is_deletable)(PurpleLog *log);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};




struct _PurpleLog {
 PurpleLogType type;
 char *name;
 PurpleAccount *account;

 PurpleConversation *conv;
 time_t time;


 PurpleLogLogger *logger;

 void *logger_data;
 struct tm *tm;
# 145 "/usr/include/libpurple/log.h"
};





struct _PurpleLogCommonLoggerData {
 char *path;
 FILE *file;
 void *extra_data;
};







struct _PurpleLogSet {
 PurpleLogType type;
 char *name;
 PurpleAccount *account;






 gboolean buddy;

 char *normalized_name;






};
# 206 "/usr/include/libpurple/log.h"
PurpleLog *purple_log_new(PurpleLogType type, const char *name, PurpleAccount *account,
                      PurpleConversation *conv, time_t time, const struct tm *tm);






void purple_log_free(PurpleLog *log);
# 226 "/usr/include/libpurple/log.h"
void purple_log_write(PurpleLog *log,
      PurpleMessageFlags type,
      const char *from,
      time_t time,
      const char *message);
# 240 "/usr/include/libpurple/log.h"
char *purple_log_read(PurpleLog *log, PurpleLogReadFlags *flags);
# 250 "/usr/include/libpurple/log.h"
GList *purple_log_get_logs(PurpleLogType type, const char *name, PurpleAccount *account);
# 268 "/usr/include/libpurple/log.h"
GHashTable *purple_log_get_log_sets(void);







GList *purple_log_get_system_logs(PurpleAccount *account);







int purple_log_get_size(PurpleLog *log);
# 294 "/usr/include/libpurple/log.h"
int purple_log_get_total_size(PurpleLogType type, const char *name, PurpleAccount *account);
# 307 "/usr/include/libpurple/log.h"
int purple_log_get_activity_score(PurpleLogType type, const char *name, PurpleAccount *account);
# 319 "/usr/include/libpurple/log.h"
gboolean purple_log_is_deletable(PurpleLog *log);







gboolean purple_log_delete(PurpleLog *log);
# 339 "/usr/include/libpurple/log.h"
char *purple_log_get_log_dir(PurpleLogType type, const char *name, PurpleAccount *account);
# 348 "/usr/include/libpurple/log.h"
gint purple_log_compare(gconstpointer y, gconstpointer z);
# 357 "/usr/include/libpurple/log.h"
gint purple_log_set_compare(gconstpointer y, gconstpointer z);






void purple_log_set_free(PurpleLogSet *set);
# 389 "/usr/include/libpurple/log.h"
void purple_log_common_writer(PurpleLog *log, const char *ext);
# 408 "/usr/include/libpurple/log.h"
GList *purple_log_common_lister(PurpleLogType type, const char *name,
         PurpleAccount *account, const char *ext,
         PurpleLogLogger *logger);
# 431 "/usr/include/libpurple/log.h"
int purple_log_common_total_sizer(PurpleLogType type, const char *name,
        PurpleAccount *account, const char *ext);
# 447 "/usr/include/libpurple/log.h"
int purple_log_common_sizer(PurpleLog *log);
# 462 "/usr/include/libpurple/log.h"
gboolean purple_log_common_deleter(PurpleLog *log);
# 477 "/usr/include/libpurple/log.h"
gboolean purple_log_common_is_deletable(PurpleLog *log);
# 506 "/usr/include/libpurple/log.h"
PurpleLogLogger *purple_log_logger_new(const char *id, const char *name, int functions, ...);






void purple_log_logger_free(PurpleLogLogger *logger);






void purple_log_logger_add (PurpleLogLogger *logger);







void purple_log_logger_remove (PurpleLogLogger *logger);







void purple_log_logger_set (PurpleLogLogger *logger);







PurpleLogLogger *purple_log_logger_get (void);







GList *purple_log_logger_get_options(void);
# 562 "/usr/include/libpurple/log.h"
void purple_log_init(void);






void *purple_log_get_handle(void);




void purple_log_uninit(void);
# 150 "/usr/include/libpurple/conversation.h" 2
# 1 "/usr/include/libpurple/server.h" 1
# 31 "/usr/include/libpurple/server.h"
# 1 "/usr/include/libpurple/prpl.h" 1
# 32 "/usr/include/libpurple/server.h" 2
# 53 "/usr/include/libpurple/server.h"
unsigned int serv_send_typing(PurpleConnection *gc, const char *name, PurpleTypingState state);

void serv_move_buddy(PurpleBuddy *, PurpleGroup *, PurpleGroup *);
int serv_send_im(PurpleConnection *, const char *, const char *, PurpleMessageFlags flags);





PurpleAttentionType *purple_get_attention_type_from_code(PurpleAccount *account, guint type_code);
# 77 "/usr/include/libpurple/server.h"
void serv_send_attention(PurpleConnection *gc, const char *who, guint type_code);
# 88 "/usr/include/libpurple/server.h"
void serv_got_attention(PurpleConnection *gc, const char *who, guint type_code);

void serv_get_info(PurpleConnection *, const char *);
void serv_set_info(PurpleConnection *, const char *);

void serv_add_permit(PurpleConnection *, const char *);
void serv_add_deny(PurpleConnection *, const char *);
void serv_rem_permit(PurpleConnection *, const char *);
void serv_rem_deny(PurpleConnection *, const char *);
void serv_set_permit_deny(PurpleConnection *);
void serv_chat_invite(PurpleConnection *, int, const char *, const char *);
void serv_chat_leave(PurpleConnection *, int);
void serv_chat_whisper(PurpleConnection *, int, const char *, const char *);
int serv_chat_send(PurpleConnection *, int, const char *, PurpleMessageFlags flags);
void serv_alias_buddy(PurpleBuddy *);
void serv_got_alias(PurpleConnection *gc, const char *who, const char *alias);
# 114 "/usr/include/libpurple/server.h"
void purple_serv_got_private_alias(PurpleConnection *gc, const char *who, const char *alias);
# 133 "/usr/include/libpurple/server.h"
void serv_got_typing(PurpleConnection *gc, const char *name, int timeout,
      PurpleTypingState state);




void serv_got_typing_stopped(PurpleConnection *gc, const char *name);

void serv_got_im(PurpleConnection *gc, const char *who, const char *msg,
     PurpleMessageFlags flags, time_t mtime);





void serv_join_chat(PurpleConnection *, GHashTable *data);





void serv_reject_chat(PurpleConnection *, GHashTable *data);
# 167 "/usr/include/libpurple/server.h"
void serv_got_chat_invite(PurpleConnection *gc, const char *name,
        const char *who, const char *message,
        GHashTable *data);
# 179 "/usr/include/libpurple/server.h"
PurpleConversation *serv_got_joined_chat(PurpleConnection *gc,
            int id, const char *name);
# 190 "/usr/include/libpurple/server.h"
void purple_serv_got_join_chat_failed(PurpleConnection *gc, GHashTable *data);







void serv_got_chat_left(PurpleConnection *g, int id);
# 210 "/usr/include/libpurple/server.h"
void serv_got_chat_in(PurpleConnection *g, int id, const char *who,
       PurpleMessageFlags flags, const char *message, time_t mtime);
void serv_send_file(PurpleConnection *gc, const char *who, const char *file);
# 151 "/usr/include/libpurple/conversation.h" 2







struct _PurpleConversationUiOps
{



 void (*create_conversation)(PurpleConversation *conv);


 void (*destroy_conversation)(PurpleConversation *conv);




 void (*write_chat)(PurpleConversation *conv, const char *who,
                    const char *message, PurpleMessageFlags flags,
                    time_t mtime);




 void (*write_im)(PurpleConversation *conv, const char *who,
                  const char *message, PurpleMessageFlags flags,
                  time_t mtime);
# 189 "/usr/include/libpurple/conversation.h"
 void (*write_conv)(PurpleConversation *conv,
                    const char *name,
                    const char *alias,
                    const char *message,
                    PurpleMessageFlags flags,
                    time_t mtime);







 void (*chat_add_users)(PurpleConversation *conv,
                        GList *cbuddies,
                        gboolean new_arrivals);





 void (*chat_rename_user)(PurpleConversation *conv, const char *old_name,
                          const char *new_name, const char *new_alias);




 void (*chat_remove_users)(PurpleConversation *conv, GList *users);



 void (*chat_update_user)(PurpleConversation *conv, const char *user);




 void (*present)(PurpleConversation *conv);





 gboolean (*has_focus)(PurpleConversation *conv);


 gboolean (*custom_smiley_add)(PurpleConversation *conv, const char *smile, gboolean remote);
 void (*custom_smiley_write)(PurpleConversation *conv, const char *smile,
                             const guchar *data, gsize size);
 void (*custom_smiley_close)(PurpleConversation *conv, const char *smile);






 void (*send_confirm)(PurpleConversation *conv, const char *message);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};




struct _PurpleConvIm
{
 PurpleConversation *conv;

 PurpleTypingState typing_state;
 guint typing_timeout;
 time_t type_again;
 guint send_typed_timeout;

 PurpleBuddyIcon *icon;
};




struct _PurpleConvChat
{
 PurpleConversation *conv;

 GList *in_room;


 GList *ignored;
 char *who;
 char *topic;
 int id;
 char *nick;

 gboolean left;
 GHashTable *users;


};




struct _PurpleConvChatBuddy
{
 char *name;
 char *alias;


 char *alias_key;




 gboolean buddy;


 PurpleConvChatBuddyFlags flags;


 GHashTable *attributes;


 gpointer ui_data;
};






struct _PurpleConvMessage
{
 char *who;
 char *what;
 PurpleMessageFlags flags;
 time_t when;
 PurpleConversation *conv;
 char *alias;
};






struct _PurpleConversation
{
 PurpleConversationType type;

 PurpleAccount *account;


 char *name;
 char *title;

 gboolean logging;

 GList *logs;

 union
 {
  PurpleConvIm *im;
  PurpleConvChat *chat;
  void *misc;

 } u;

 PurpleConversationUiOps *ui_ops;
 void *ui_data;

 GHashTable *data;

 PurpleConnectionFlags features;
 GList *message_history;
};
# 386 "/usr/include/libpurple/conversation.h"
PurpleConversation *purple_conversation_new(PurpleConversationType type,
          PurpleAccount *account,
          const char *name);
# 399 "/usr/include/libpurple/conversation.h"
void purple_conversation_destroy(PurpleConversation *conv);







void purple_conversation_present(PurpleConversation *conv);
# 417 "/usr/include/libpurple/conversation.h"
PurpleConversationType purple_conversation_get_type(const PurpleConversation *conv);







void purple_conversation_set_ui_ops(PurpleConversation *conv,
          PurpleConversationUiOps *ops);






void purple_conversations_set_ui_ops(PurpleConversationUiOps *ops);
# 442 "/usr/include/libpurple/conversation.h"
PurpleConversationUiOps *purple_conversation_get_ui_ops(
  const PurpleConversation *conv);
# 454 "/usr/include/libpurple/conversation.h"
void purple_conversation_set_account(PurpleConversation *conv,
                                   PurpleAccount *account);
# 467 "/usr/include/libpurple/conversation.h"
PurpleAccount *purple_conversation_get_account(const PurpleConversation *conv);
# 478 "/usr/include/libpurple/conversation.h"
PurpleConnection *purple_conversation_get_gc(const PurpleConversation *conv);







void purple_conversation_set_title(PurpleConversation *conv, const char *title);
# 495 "/usr/include/libpurple/conversation.h"
const char *purple_conversation_get_title(const PurpleConversation *conv);
# 505 "/usr/include/libpurple/conversation.h"
void purple_conversation_autoset_title(PurpleConversation *conv);







void purple_conversation_set_name(PurpleConversation *conv, const char *name);
# 523 "/usr/include/libpurple/conversation.h"
const char *purple_conversation_get_name(const PurpleConversation *conv);
# 533 "/usr/include/libpurple/conversation.h"
const char *purple_conv_chat_cb_get_attribute(PurpleConvChatBuddy *cb, const char *key);
# 542 "/usr/include/libpurple/conversation.h"
GList *purple_conv_chat_cb_get_attribute_keys(PurpleConvChatBuddy *cb);
# 552 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_cb_set_attribute(PurpleConvChat *chat, PurpleConvChatBuddy *cb, const char *key, const char *value);
# 562 "/usr/include/libpurple/conversation.h"
void
purple_conv_chat_cb_set_attributes(PurpleConvChat *chat, PurpleConvChatBuddy *cb, GList *keys, GList *values);







void purple_conversation_set_logging(PurpleConversation *conv, gboolean log);
# 580 "/usr/include/libpurple/conversation.h"
gboolean purple_conversation_is_logging(const PurpleConversation *conv);
# 591 "/usr/include/libpurple/conversation.h"
void purple_conversation_close_logs(PurpleConversation *conv);
# 602 "/usr/include/libpurple/conversation.h"
PurpleConvIm *purple_conversation_get_im_data(const PurpleConversation *conv);
# 615 "/usr/include/libpurple/conversation.h"
PurpleConvChat *purple_conversation_get_chat_data(const PurpleConversation *conv);
# 626 "/usr/include/libpurple/conversation.h"
void purple_conversation_set_data(PurpleConversation *conv, const char *key,
        gpointer data);
# 637 "/usr/include/libpurple/conversation.h"
gpointer purple_conversation_get_data(PurpleConversation *conv, const char *key);
# 646 "/usr/include/libpurple/conversation.h"
GList *purple_get_conversations(void);






GList *purple_get_ims(void);






GList *purple_get_chats(void);
# 671 "/usr/include/libpurple/conversation.h"
PurpleConversation *purple_find_conversation_with_account(
  PurpleConversationType type, const char *name,
  const PurpleAccount *account);
# 695 "/usr/include/libpurple/conversation.h"
void purple_conversation_write(PurpleConversation *conv, const char *who,
  const char *message, PurpleMessageFlags flags,
  time_t mtime);






void purple_conversation_set_features(PurpleConversation *conv,
  PurpleConnectionFlags features);






PurpleConnectionFlags purple_conversation_get_features(PurpleConversation *conv);
# 722 "/usr/include/libpurple/conversation.h"
gboolean purple_conversation_has_focus(PurpleConversation *conv);







void purple_conversation_update(PurpleConversation *conv, PurpleConvUpdateType type);






void purple_conversation_foreach(void (*func)(PurpleConversation *conv));
# 750 "/usr/include/libpurple/conversation.h"
GList *purple_conversation_get_message_history(PurpleConversation *conv);
# 759 "/usr/include/libpurple/conversation.h"
void purple_conversation_clear_message_history(PurpleConversation *conv);
# 770 "/usr/include/libpurple/conversation.h"
const char *purple_conversation_message_get_sender(PurpleConvMessage *msg);
# 781 "/usr/include/libpurple/conversation.h"
const char *purple_conversation_message_get_message(PurpleConvMessage *msg);
# 792 "/usr/include/libpurple/conversation.h"
PurpleMessageFlags purple_conversation_message_get_flags(PurpleConvMessage *msg);
# 803 "/usr/include/libpurple/conversation.h"
time_t purple_conversation_message_get_timestamp(PurpleConvMessage *msg);
# 820 "/usr/include/libpurple/conversation.h"
PurpleConversation *purple_conv_im_get_conversation(const PurpleConvIm *im);
# 833 "/usr/include/libpurple/conversation.h"
void purple_conv_im_set_icon(PurpleConvIm *im, PurpleBuddyIcon *icon);
# 842 "/usr/include/libpurple/conversation.h"
PurpleBuddyIcon *purple_conv_im_get_icon(const PurpleConvIm *im);







void purple_conv_im_set_typing_state(PurpleConvIm *im, PurpleTypingState state);
# 859 "/usr/include/libpurple/conversation.h"
PurpleTypingState purple_conv_im_get_typing_state(const PurpleConvIm *im);







void purple_conv_im_start_typing_timeout(PurpleConvIm *im, int timeout);






void purple_conv_im_stop_typing_timeout(PurpleConvIm *im);
# 883 "/usr/include/libpurple/conversation.h"
guint purple_conv_im_get_typing_timeout(const PurpleConvIm *im);
# 896 "/usr/include/libpurple/conversation.h"
void purple_conv_im_set_type_again(PurpleConvIm *im, unsigned int val);
# 906 "/usr/include/libpurple/conversation.h"
time_t purple_conv_im_get_type_again(const PurpleConvIm *im);






void purple_conv_im_start_send_typed_timeout(PurpleConvIm *im);






void purple_conv_im_stop_send_typed_timeout(PurpleConvIm *im);
# 929 "/usr/include/libpurple/conversation.h"
guint purple_conv_im_get_send_typed_timeout(const PurpleConvIm *im);






void purple_conv_im_update_typing(PurpleConvIm *im);
# 947 "/usr/include/libpurple/conversation.h"
void purple_conv_im_write(PurpleConvIm *im, const char *who,
      const char *message, PurpleMessageFlags flags,
      time_t mtime);
# 964 "/usr/include/libpurple/conversation.h"
gboolean purple_conv_present_error(const char *who, PurpleAccount *account, const char *what);







void purple_conv_im_send(PurpleConvIm *im, const char *message);
# 986 "/usr/include/libpurple/conversation.h"
void purple_conv_send_confirm(PurpleConversation *conv, const char *message);
# 995 "/usr/include/libpurple/conversation.h"
void purple_conv_im_send_with_flags(PurpleConvIm *im, const char *message, PurpleMessageFlags flags);
# 1016 "/usr/include/libpurple/conversation.h"
gboolean purple_conv_custom_smiley_add(PurpleConversation *conv, const char *smile,
                                      const char *cksum_type, const char *chksum,
           gboolean remote);
# 1030 "/usr/include/libpurple/conversation.h"
void purple_conv_custom_smiley_write(PurpleConversation *conv,
                                   const char *smile,
                                   const guchar *data,
                                   gsize size);
# 1044 "/usr/include/libpurple/conversation.h"
void purple_conv_custom_smiley_close(PurpleConversation *conv, const char *smile);
# 1061 "/usr/include/libpurple/conversation.h"
PurpleConversation *purple_conv_chat_get_conversation(const PurpleConvChat *chat);
# 1077 "/usr/include/libpurple/conversation.h"
GList *purple_conv_chat_set_users(PurpleConvChat *chat, GList *users);
# 1087 "/usr/include/libpurple/conversation.h"
GList *purple_conv_chat_get_users(const PurpleConvChat *chat);







void purple_conv_chat_ignore(PurpleConvChat *chat, const char *name);







void purple_conv_chat_unignore(PurpleConvChat *chat, const char *name);
# 1113 "/usr/include/libpurple/conversation.h"
GList *purple_conv_chat_set_ignored(PurpleConvChat *chat, GList *ignored);
# 1122 "/usr/include/libpurple/conversation.h"
GList *purple_conv_chat_get_ignored(const PurpleConvChat *chat);
# 1138 "/usr/include/libpurple/conversation.h"
const char *purple_conv_chat_get_ignored_user(const PurpleConvChat *chat,
           const char *user);
# 1149 "/usr/include/libpurple/conversation.h"
gboolean purple_conv_chat_is_user_ignored(const PurpleConvChat *chat,
          const char *user);
# 1159 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_set_topic(PurpleConvChat *chat, const char *who,
         const char *topic);
# 1169 "/usr/include/libpurple/conversation.h"
const char *purple_conv_chat_get_topic(const PurpleConvChat *chat);







void purple_conv_chat_set_id(PurpleConvChat *chat, int id);
# 1186 "/usr/include/libpurple/conversation.h"
int purple_conv_chat_get_id(const PurpleConvChat *chat);
# 1197 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_write(PurpleConvChat *chat, const char *who,
        const char *message, PurpleMessageFlags flags,
        time_t mtime);







void purple_conv_chat_send(PurpleConvChat *chat, const char *message);
# 1216 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_send_with_flags(PurpleConvChat *chat, const char *message, PurpleMessageFlags flags);
# 1227 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_add_user(PurpleConvChat *chat, const char *user,
        const char *extra_msg, PurpleConvChatBuddyFlags flags,
        gboolean new_arrival);
# 1248 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_add_users(PurpleConvChat *chat, GList *users, GList *extra_msgs,
         GList *flags, gboolean new_arrivals);
# 1258 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_rename_user(PurpleConvChat *chat, const char *old_user,
        const char *new_user);
# 1270 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_remove_user(PurpleConvChat *chat, const char *user,
        const char *reason);
# 1280 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_remove_users(PurpleConvChat *chat, GList *users,
         const char *reason);
# 1291 "/usr/include/libpurple/conversation.h"
gboolean purple_conv_chat_find_user(PurpleConvChat *chat, const char *user);
# 1300 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_user_set_flags(PurpleConvChat *chat, const char *user,
           PurpleConvChatBuddyFlags flags);
# 1311 "/usr/include/libpurple/conversation.h"
PurpleConvChatBuddyFlags purple_conv_chat_user_get_flags(PurpleConvChat *chat,
              const char *user);






void purple_conv_chat_clear_users(PurpleConvChat *chat);







void purple_conv_chat_set_nick(PurpleConvChat *chat, const char *nick);







const char *purple_conv_chat_get_nick(PurpleConvChat *chat);
# 1345 "/usr/include/libpurple/conversation.h"
PurpleConversation *purple_find_chat(const PurpleConnection *gc, int id);







void purple_conv_chat_left(PurpleConvChat *chat);
# 1368 "/usr/include/libpurple/conversation.h"
void purple_conv_chat_invite_user(PurpleConvChat *chat, const char *user,
  const char *message, gboolean confirm);
# 1380 "/usr/include/libpurple/conversation.h"
gboolean purple_conv_chat_has_left(PurpleConvChat *chat);
# 1391 "/usr/include/libpurple/conversation.h"
PurpleConvChatBuddy *purple_conv_chat_cb_new(const char *name, const char *alias,
          PurpleConvChatBuddyFlags flags);







PurpleConvChatBuddy *purple_conv_chat_cb_find(PurpleConvChat *chat, const char *name);
# 1409 "/usr/include/libpurple/conversation.h"
const char *purple_conv_chat_cb_get_name(PurpleConvChatBuddy *cb);






void purple_conv_chat_cb_destroy(PurpleConvChatBuddy *cb);
# 1429 "/usr/include/libpurple/conversation.h"
GList * purple_conversation_get_extended_menu(PurpleConversation *conv);
# 1444 "/usr/include/libpurple/conversation.h"
gboolean purple_conversation_do_command(PurpleConversation *conv, const gchar *cmdline, const gchar *markup, gchar **error);
# 1458 "/usr/include/libpurple/conversation.h"
void *purple_conversations_get_handle(void);




void purple_conversations_init(void);




void purple_conversations_uninit(void);
# 73 "/usr/include/libpurple/prpl.h" 2
# 1 "/usr/include/libpurple/ft.h" 1
# 33 "/usr/include/libpurple/ft.h"
typedef struct _PurpleXfer PurpleXfer;
# 43 "/usr/include/libpurple/ft.h"
typedef enum
{
 PURPLE_XFER_UNKNOWN = 0,
 PURPLE_XFER_SEND,
 PURPLE_XFER_RECEIVE

} PurpleXferType;




typedef enum
{
 PURPLE_XFER_STATUS_UNKNOWN = 0,
 PURPLE_XFER_STATUS_NOT_STARTED,
 PURPLE_XFER_STATUS_ACCEPTED,
 PURPLE_XFER_STATUS_STARTED,
 PURPLE_XFER_STATUS_DONE,
 PURPLE_XFER_STATUS_CANCEL_LOCAL,
 PURPLE_XFER_STATUS_CANCEL_REMOTE
} PurpleXferStatusType;







typedef struct
{
 void (*new_xfer)(PurpleXfer *xfer);
 void (*destroy)(PurpleXfer *xfer);
 void (*add_xfer)(PurpleXfer *xfer);
 void (*update_progress)(PurpleXfer *xfer, double percent);
 void (*cancel_local)(PurpleXfer *xfer);
 void (*cancel_remote)(PurpleXfer *xfer);
# 92 "/usr/include/libpurple/ft.h"
 gssize (*ui_write)(PurpleXfer *xfer, const guchar *buffer, gssize size);
# 107 "/usr/include/libpurple/ft.h"
 gssize (*ui_read)(PurpleXfer *xfer, guchar **buffer, gssize size);
# 121 "/usr/include/libpurple/ft.h"
 void (*data_not_sent)(PurpleXfer *xfer, const guchar *buffer, gsize size);






 void (*add_thumbnail)(PurpleXfer *xfer, const gchar *formats);
} PurpleXferUiOps;




struct _PurpleXfer
{
 guint ref;
 PurpleXferType type;

 PurpleAccount *account;

 char *who;


 char *message;
 char *filename;
 char *local_filename;
 size_t size;

 FILE *dest_fp;

 char *remote_ip;
 int local_port;
 int remote_port;

 int fd;
 int watcher;

 size_t bytes_sent;
 size_t bytes_remaining;
 time_t start_time;
 time_t end_time;

 size_t current_buffer_size;


 PurpleXferStatusType status;





 struct
 {
  void (*init)(PurpleXfer *xfer);
  void (*request_denied)(PurpleXfer *xfer);
  void (*start)(PurpleXfer *xfer);
  void (*end)(PurpleXfer *xfer);
  void (*cancel_send)(PurpleXfer *xfer);
  void (*cancel_recv)(PurpleXfer *xfer);
  gssize (*read)(guchar **buffer, PurpleXfer *xfer);
  gssize (*write)(const guchar *buffer, size_t size, PurpleXfer *xfer);
  void (*ack)(PurpleXfer *xfer, const guchar *buffer, size_t size);
 } ops;

 PurpleXferUiOps *ui_ops;
 void *ui_data;

 void *data;
};
# 213 "/usr/include/libpurple/ft.h"
PurpleXfer *purple_xfer_new(PurpleAccount *account,
        PurpleXferType type, const char *who);






GList *purple_xfers_get_all(void);







void purple_xfer_ref(PurpleXfer *xfer);
# 240 "/usr/include/libpurple/ft.h"
void purple_xfer_unref(PurpleXfer *xfer);
# 251 "/usr/include/libpurple/ft.h"
void purple_xfer_request(PurpleXfer *xfer);







void purple_xfer_request_accepted(PurpleXfer *xfer, const char *filename);






void purple_xfer_request_denied(PurpleXfer *xfer);
# 275 "/usr/include/libpurple/ft.h"
PurpleXferType purple_xfer_get_type(const PurpleXfer *xfer);
# 284 "/usr/include/libpurple/ft.h"
PurpleAccount *purple_xfer_get_account(const PurpleXfer *xfer);
# 295 "/usr/include/libpurple/ft.h"
const char *purple_xfer_get_remote_user(const PurpleXfer *xfer);
# 304 "/usr/include/libpurple/ft.h"
PurpleXferStatusType purple_xfer_get_status(const PurpleXfer *xfer);
# 314 "/usr/include/libpurple/ft.h"
gboolean purple_xfer_is_canceled(const PurpleXfer *xfer);
# 323 "/usr/include/libpurple/ft.h"
gboolean purple_xfer_is_completed(const PurpleXfer *xfer);
# 332 "/usr/include/libpurple/ft.h"
const char *purple_xfer_get_filename(const PurpleXfer *xfer);
# 341 "/usr/include/libpurple/ft.h"
const char *purple_xfer_get_local_filename(const PurpleXfer *xfer);
# 350 "/usr/include/libpurple/ft.h"
size_t purple_xfer_get_bytes_sent(const PurpleXfer *xfer);
# 359 "/usr/include/libpurple/ft.h"
size_t purple_xfer_get_bytes_remaining(const PurpleXfer *xfer);
# 368 "/usr/include/libpurple/ft.h"
size_t purple_xfer_get_size(const PurpleXfer *xfer);
# 379 "/usr/include/libpurple/ft.h"
double purple_xfer_get_progress(const PurpleXfer *xfer);
# 388 "/usr/include/libpurple/ft.h"
unsigned int purple_xfer_get_local_port(const PurpleXfer *xfer);
# 397 "/usr/include/libpurple/ft.h"
const char *purple_xfer_get_remote_ip(const PurpleXfer *xfer);
# 406 "/usr/include/libpurple/ft.h"
unsigned int purple_xfer_get_remote_port(const PurpleXfer *xfer);
# 416 "/usr/include/libpurple/ft.h"
time_t purple_xfer_get_start_time(const PurpleXfer *xfer);
# 426 "/usr/include/libpurple/ft.h"
time_t purple_xfer_get_end_time(const PurpleXfer *xfer);







void purple_xfer_set_completed(PurpleXfer *xfer, gboolean completed);







void purple_xfer_set_message(PurpleXfer *xfer, const char *message);







void purple_xfer_set_filename(PurpleXfer *xfer, const char *filename);







void purple_xfer_set_local_filename(PurpleXfer *xfer, const char *filename);







void purple_xfer_set_size(PurpleXfer *xfer, size_t size);
# 481 "/usr/include/libpurple/ft.h"
void purple_xfer_set_bytes_sent(PurpleXfer *xfer, size_t bytes_sent);
# 490 "/usr/include/libpurple/ft.h"
PurpleXferUiOps *purple_xfer_get_ui_ops(const PurpleXfer *xfer);







void purple_xfer_set_read_fnc(PurpleXfer *xfer,
  gssize (*fnc)(guchar **, PurpleXfer *));







void purple_xfer_set_write_fnc(PurpleXfer *xfer,
  gssize (*fnc)(const guchar *, size_t, PurpleXfer *));







void purple_xfer_set_ack_fnc(PurpleXfer *xfer,
  void (*fnc)(PurpleXfer *, const guchar *, size_t));







void purple_xfer_set_request_denied_fnc(PurpleXfer *xfer, void (*fnc)(PurpleXfer *));
# 537 "/usr/include/libpurple/ft.h"
void purple_xfer_set_init_fnc(PurpleXfer *xfer, void (*fnc)(PurpleXfer *));







void purple_xfer_set_start_fnc(PurpleXfer *xfer, void (*fnc)(PurpleXfer *));







void purple_xfer_set_end_fnc(PurpleXfer *xfer, void (*fnc)(PurpleXfer *));







void purple_xfer_set_cancel_send_fnc(PurpleXfer *xfer, void (*fnc)(PurpleXfer *));







void purple_xfer_set_cancel_recv_fnc(PurpleXfer *xfer, void (*fnc)(PurpleXfer *));
# 579 "/usr/include/libpurple/ft.h"
gssize purple_xfer_read(PurpleXfer *xfer, guchar **buffer);
# 590 "/usr/include/libpurple/ft.h"
gssize purple_xfer_write(PurpleXfer *xfer, const guchar *buffer, gsize size);
# 610 "/usr/include/libpurple/ft.h"
void purple_xfer_start(PurpleXfer *xfer, int fd, const char *ip,
      unsigned int port);






void purple_xfer_end(PurpleXfer *xfer);







void purple_xfer_add(PurpleXfer *xfer);






void purple_xfer_cancel_local(PurpleXfer *xfer);






void purple_xfer_cancel_remote(PurpleXfer *xfer);
# 654 "/usr/include/libpurple/ft.h"
void purple_xfer_error(PurpleXferType type, PurpleAccount *account, const char *who, const char *msg);






void purple_xfer_update_progress(PurpleXfer *xfer);
# 672 "/usr/include/libpurple/ft.h"
void purple_xfer_conversation_write(PurpleXfer *xfer, char *message, gboolean is_error);
# 683 "/usr/include/libpurple/ft.h"
void purple_xfer_ui_ready(PurpleXfer *xfer);
# 694 "/usr/include/libpurple/ft.h"
void purple_xfer_prpl_ready(PurpleXfer *xfer);
# 705 "/usr/include/libpurple/ft.h"
gconstpointer purple_xfer_get_thumbnail(const PurpleXfer *xfer, gsize *len);
# 714 "/usr/include/libpurple/ft.h"
const gchar *purple_xfer_get_thumbnail_mimetype(const PurpleXfer *xfer);
# 726 "/usr/include/libpurple/ft.h"
void purple_xfer_set_thumbnail(PurpleXfer *xfer, gconstpointer thumbnail,
 gsize size, const gchar *mimetype);
# 738 "/usr/include/libpurple/ft.h"
void purple_xfer_prepare_thumbnail(PurpleXfer *xfer, const gchar *formats);
# 753 "/usr/include/libpurple/ft.h"
void *purple_xfers_get_handle(void);




void purple_xfers_init(void);




void purple_xfers_uninit(void);






void purple_xfers_set_ui_ops(PurpleXferUiOps *ops);






PurpleXferUiOps *purple_xfers_get_ui_ops(void);
# 74 "/usr/include/libpurple/prpl.h" 2

# 1 "/usr/include/libpurple/media.h" 1
# 30 "/usr/include/libpurple/media.h"
# 1 "/usr/include/libpurple/media/candidate.h" 1
# 30 "/usr/include/libpurple/media/candidate.h"
# 1 "/usr/include/libpurple/media/enum-types.h" 1
# 32 "/usr/include/libpurple/media/enum-types.h"

# 42 "/usr/include/libpurple/media/enum-types.h"
typedef enum {
 PURPLE_MEDIA_CANDIDATE_TYPE_HOST,
 PURPLE_MEDIA_CANDIDATE_TYPE_SRFLX,
 PURPLE_MEDIA_CANDIDATE_TYPE_PRFLX,
 PURPLE_MEDIA_CANDIDATE_TYPE_RELAY,
 PURPLE_MEDIA_CANDIDATE_TYPE_MULTICAST
} PurpleMediaCandidateType;


typedef enum {
 PURPLE_MEDIA_CAPS_NONE = 0,
 PURPLE_MEDIA_CAPS_AUDIO = 1,
 PURPLE_MEDIA_CAPS_AUDIO_SINGLE_DIRECTION = 1 << 1,
 PURPLE_MEDIA_CAPS_VIDEO = 1 << 2,
 PURPLE_MEDIA_CAPS_VIDEO_SINGLE_DIRECTION = 1 << 3,
 PURPLE_MEDIA_CAPS_AUDIO_VIDEO = 1 << 4,
 PURPLE_MEDIA_CAPS_MODIFY_SESSION = 1 << 5,
 PURPLE_MEDIA_CAPS_CHANGE_DIRECTION = 1 << 6
} PurpleMediaCaps;


typedef enum {
 PURPLE_MEDIA_COMPONENT_NONE = 0,
 PURPLE_MEDIA_COMPONENT_RTP = 1,
 PURPLE_MEDIA_COMPONENT_RTCP = 2
} PurpleMediaComponentType;


typedef enum {
 PURPLE_MEDIA_INFO_HANGUP = 0,
 PURPLE_MEDIA_INFO_ACCEPT,
 PURPLE_MEDIA_INFO_REJECT,
 PURPLE_MEDIA_INFO_MUTE,
 PURPLE_MEDIA_INFO_UNMUTE,
 PURPLE_MEDIA_INFO_PAUSE,
 PURPLE_MEDIA_INFO_UNPAUSE,
 PURPLE_MEDIA_INFO_HOLD,
 PURPLE_MEDIA_INFO_UNHOLD
} PurpleMediaInfoType;


typedef enum {
 PURPLE_MEDIA_NETWORK_PROTOCOL_UDP,
 PURPLE_MEDIA_NETWORK_PROTOCOL_TCP
} PurpleMediaNetworkProtocol;


typedef enum {
 PURPLE_MEDIA_NONE = 0,
 PURPLE_MEDIA_RECV_AUDIO = 1 << 0,
 PURPLE_MEDIA_SEND_AUDIO = 1 << 1,
 PURPLE_MEDIA_RECV_VIDEO = 1 << 2,
 PURPLE_MEDIA_SEND_VIDEO = 1 << 3,
 PURPLE_MEDIA_AUDIO = PURPLE_MEDIA_RECV_AUDIO | PURPLE_MEDIA_SEND_AUDIO,
 PURPLE_MEDIA_VIDEO = PURPLE_MEDIA_RECV_VIDEO | PURPLE_MEDIA_SEND_VIDEO
} PurpleMediaSessionType;


typedef enum {
 PURPLE_MEDIA_STATE_NEW = 0,
 PURPLE_MEDIA_STATE_CONNECTED,
 PURPLE_MEDIA_STATE_END
} PurpleMediaState;
# 113 "/usr/include/libpurple/media/enum-types.h"
GType purple_media_candidate_type_get_type(void);
# 122 "/usr/include/libpurple/media/enum-types.h"
GType purple_media_caps_get_type(void);
# 131 "/usr/include/libpurple/media/enum-types.h"
GType purple_media_info_type_get_type(void);
# 140 "/usr/include/libpurple/media/enum-types.h"
GType purple_media_network_protocol_get_type(void);
# 149 "/usr/include/libpurple/media/enum-types.h"
GType purple_media_session_type_get_type(void);
# 158 "/usr/include/libpurple/media/enum-types.h"
GType purple_media_state_changed_get_type(void);


# 31 "/usr/include/libpurple/media/candidate.h" 2




# 44 "/usr/include/libpurple/media/candidate.h"
typedef struct _PurpleMediaCandidate PurpleMediaCandidate;
# 53 "/usr/include/libpurple/media/candidate.h"
GType purple_media_candidate_get_type(void);
# 69 "/usr/include/libpurple/media/candidate.h"
PurpleMediaCandidate *purple_media_candidate_new(
  const gchar *foundation, guint component_id,
  PurpleMediaCandidateType type,
  PurpleMediaNetworkProtocol proto,
  const gchar *ip, guint port);
# 84 "/usr/include/libpurple/media/candidate.h"
PurpleMediaCandidate *purple_media_candidate_copy(
  PurpleMediaCandidate *candidate);
# 96 "/usr/include/libpurple/media/candidate.h"
GList *purple_media_candidate_list_copy(GList *candidates);
# 105 "/usr/include/libpurple/media/candidate.h"
void purple_media_candidate_list_free(GList *candidates);
# 116 "/usr/include/libpurple/media/candidate.h"
gchar *purple_media_candidate_get_foundation(PurpleMediaCandidate *candidate);
# 127 "/usr/include/libpurple/media/candidate.h"
guint purple_media_candidate_get_component_id(PurpleMediaCandidate *candidate);
# 138 "/usr/include/libpurple/media/candidate.h"
gchar *purple_media_candidate_get_ip(PurpleMediaCandidate *candidate);
# 149 "/usr/include/libpurple/media/candidate.h"
guint16 purple_media_candidate_get_port(PurpleMediaCandidate *candidate);
# 162 "/usr/include/libpurple/media/candidate.h"
gchar *purple_media_candidate_get_base_ip(PurpleMediaCandidate *candidate);
# 175 "/usr/include/libpurple/media/candidate.h"
guint16 purple_media_candidate_get_base_port(PurpleMediaCandidate *candidate);
# 186 "/usr/include/libpurple/media/candidate.h"
PurpleMediaNetworkProtocol purple_media_candidate_get_protocol(
  PurpleMediaCandidate *candidate);
# 198 "/usr/include/libpurple/media/candidate.h"
guint32 purple_media_candidate_get_priority(PurpleMediaCandidate *candidate);
# 209 "/usr/include/libpurple/media/candidate.h"
PurpleMediaCandidateType purple_media_candidate_get_candidate_type(
  PurpleMediaCandidate *candidate);
# 223 "/usr/include/libpurple/media/candidate.h"
gchar *purple_media_candidate_get_username(PurpleMediaCandidate *candidate);
# 236 "/usr/include/libpurple/media/candidate.h"
gchar *purple_media_candidate_get_password(PurpleMediaCandidate *candidate);
# 247 "/usr/include/libpurple/media/candidate.h"
guint purple_media_candidate_get_ttl(PurpleMediaCandidate *candidate);


# 31 "/usr/include/libpurple/media.h" 2
# 1 "/usr/include/libpurple/media/codec.h" 1
# 33 "/usr/include/libpurple/media/codec.h"
typedef struct _PurpleMediaCodec PurpleMediaCodec;

# 1 "/usr/include/libpurple/media/../util.h" 1
# 38 "/usr/include/libpurple/media/../util.h"
typedef struct _PurpleUtilFetchUrlData PurpleUtilFetchUrlData;

typedef struct _PurpleMenuAction PurpleMenuAction;

typedef struct _PurpleKeyValuePair PurpleKeyValuePair;

# 1 "/usr/include/libpurple/media/../account.h" 1
# 45 "/usr/include/libpurple/media/../util.h" 2
# 1 "/usr/include/libpurple/media/../signals.h" 1
# 46 "/usr/include/libpurple/media/../util.h" 2
# 1 "/usr/include/libpurple/media/../xmlnode.h" 1
# 38 "/usr/include/libpurple/media/../xmlnode.h"
typedef enum _XMLNodeType
{
 XMLNODE_TYPE_TAG,
 XMLNODE_TYPE_ATTRIB,
 XMLNODE_TYPE_DATA
} XMLNodeType;




typedef struct _xmlnode xmlnode;
struct _xmlnode
{
 char *name;
 char *xmlns;
 XMLNodeType type;
 char *data;
 size_t data_sz;
 xmlnode *parent;
 xmlnode *child;
 xmlnode *lastchild;
 xmlnode *next;
 char *prefix;
 GHashTable *namespace_map;
};
# 71 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_new(const char *name);
# 81 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_new_child(xmlnode *parent, const char *name);







void xmlnode_insert_child(xmlnode *parent, xmlnode *child);
# 99 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_get_child(const xmlnode *parent, const char *name);
# 110 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_get_child_with_namespace(const xmlnode *parent, const char *name, const char *xmlns);
# 119 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_get_next_twin(xmlnode *node);
# 129 "/usr/include/libpurple/media/../xmlnode.h"
void xmlnode_insert_data(xmlnode *node, const char *data, gssize size);
# 139 "/usr/include/libpurple/media/../xmlnode.h"
char *xmlnode_get_data(const xmlnode *node);
# 149 "/usr/include/libpurple/media/../xmlnode.h"
char *xmlnode_get_data_unescaped(const xmlnode *node);
# 158 "/usr/include/libpurple/media/../xmlnode.h"
void xmlnode_set_attrib(xmlnode *node, const char *attr, const char *value);
# 171 "/usr/include/libpurple/media/../xmlnode.h"
void xmlnode_set_attrib_with_prefix(xmlnode *node, const char *attr, const char *prefix, const char *value);
# 183 "/usr/include/libpurple/media/../xmlnode.h"
void xmlnode_set_attrib_with_namespace(xmlnode *node, const char *attr, const char *xmlns, const char *value);
# 197 "/usr/include/libpurple/media/../xmlnode.h"
void xmlnode_set_attrib_full(xmlnode *node, const char *attr, const char *xmlns,
 const char *prefix, const char *value);
# 208 "/usr/include/libpurple/media/../xmlnode.h"
const char *xmlnode_get_attrib(const xmlnode *node, const char *attr);
# 219 "/usr/include/libpurple/media/../xmlnode.h"
const char *xmlnode_get_attrib_with_namespace(const xmlnode *node, const char *attr, const char *xmlns);







void xmlnode_remove_attrib(xmlnode *node, const char *attr);
# 236 "/usr/include/libpurple/media/../xmlnode.h"
void xmlnode_remove_attrib_with_namespace(xmlnode *node, const char *attr, const char *xmlns);







void xmlnode_set_namespace(xmlnode *node, const char *xmlns);







const char *xmlnode_get_namespace(xmlnode *node);







void xmlnode_set_prefix(xmlnode *node, const char *prefix);







const char *xmlnode_get_prefix(const xmlnode *node);
# 279 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_get_parent(const xmlnode *child);
# 290 "/usr/include/libpurple/media/../xmlnode.h"
char *xmlnode_to_str(const xmlnode *node, int *len);
# 302 "/usr/include/libpurple/media/../xmlnode.h"
char *xmlnode_to_formatted_str(const xmlnode *node, int *len);
# 315 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_from_str(const char *str, gssize size);
# 324 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_copy(const xmlnode *src);






void xmlnode_free(xmlnode *node);
# 349 "/usr/include/libpurple/media/../xmlnode.h"
xmlnode *xmlnode_from_file(const char *dir, const char *filename,
      const char *description, const char *process);
# 47 "/usr/include/libpurple/media/../util.h" 2
# 1 "/usr/include/libpurple/media/../notify.h" 1
# 34 "/usr/include/libpurple/media/../notify.h"
typedef struct _PurpleNotifyUserInfoEntry PurpleNotifyUserInfoEntry;
typedef struct _PurpleNotifyUserInfo PurpleNotifyUserInfo;

# 1 "/usr/include/libpurple/media/../connection.h" 1
# 38 "/usr/include/libpurple/media/../notify.h" 2




typedef void (*PurpleNotifyCloseCallback) (gpointer user_data);





typedef enum
{
 PURPLE_NOTIFY_MESSAGE = 0,
 PURPLE_NOTIFY_EMAIL,
 PURPLE_NOTIFY_EMAILS,
 PURPLE_NOTIFY_FORMATTED,
 PURPLE_NOTIFY_SEARCHRESULTS,
 PURPLE_NOTIFY_USERINFO,
 PURPLE_NOTIFY_URI

} PurpleNotifyType;





typedef enum
{
 PURPLE_NOTIFY_MSG_ERROR = 0,
 PURPLE_NOTIFY_MSG_WARNING,
 PURPLE_NOTIFY_MSG_INFO

} PurpleNotifyMsgType;





typedef enum
{
 PURPLE_NOTIFY_BUTTON_LABELED = 0,
 PURPLE_NOTIFY_BUTTON_CONTINUE = 1,
 PURPLE_NOTIFY_BUTTON_ADD,
 PURPLE_NOTIFY_BUTTON_INFO,
 PURPLE_NOTIFY_BUTTON_IM,
 PURPLE_NOTIFY_BUTTON_JOIN,
 PURPLE_NOTIFY_BUTTON_INVITE
} PurpleNotifySearchButtonType;





typedef struct
{
 GList *columns;
 GList *rows;
 GList *buttons;

} PurpleNotifySearchResults;




typedef enum
{
 PURPLE_NOTIFY_USER_INFO_ENTRY_PAIR = 0,
 PURPLE_NOTIFY_USER_INFO_ENTRY_SECTION_BREAK,
 PURPLE_NOTIFY_USER_INFO_ENTRY_SECTION_HEADER
} PurpleNotifyUserInfoEntryType;




typedef struct
{
 char *title;

} PurpleNotifySearchColumn;
# 126 "/usr/include/libpurple/media/../notify.h"
typedef void (*PurpleNotifySearchResultsCallback)(PurpleConnection *c, GList *row,
            gpointer user_data);





typedef struct
{
 PurpleNotifySearchButtonType type;
 PurpleNotifySearchResultsCallback callback;
 char *label;
} PurpleNotifySearchButton;





typedef struct
{
 void *(*notify_message)(PurpleNotifyMsgType type, const char *title,
                         const char *primary, const char *secondary);

 void *(*notify_email)(PurpleConnection *gc,
                       const char *subject, const char *from,
                       const char *to, const char *url);

 void *(*notify_emails)(PurpleConnection *gc,
                        size_t count, gboolean detailed,
                        const char **subjects, const char **froms,
                        const char **tos, const char **urls);

 void *(*notify_formatted)(const char *title, const char *primary,
                           const char *secondary, const char *text);

 void *(*notify_searchresults)(PurpleConnection *gc, const char *title,
                               const char *primary, const char *secondary,
                               PurpleNotifySearchResults *results, gpointer user_data);

 void (*notify_searchresults_new_rows)(PurpleConnection *gc,
                                       PurpleNotifySearchResults *results,
                                       void *data);

 void *(*notify_userinfo)(PurpleConnection *gc, const char *who,
                          PurpleNotifyUserInfo *user_info);

 void *(*notify_uri)(const char *uri);

 void (*close_notify)(PurpleNotifyType type, void *ui_handle);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
} PurpleNotifyUiOps;
# 211 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_searchresults(PurpleConnection *gc, const char *title,
        const char *primary, const char *secondary,
        PurpleNotifySearchResults *results, PurpleNotifyCloseCallback cb,
        gpointer user_data);






void purple_notify_searchresults_free(PurpleNotifySearchResults *results);
# 230 "/usr/include/libpurple/media/../notify.h"
void purple_notify_searchresults_new_rows(PurpleConnection *gc,
          PurpleNotifySearchResults *results,
          void *data);
# 243 "/usr/include/libpurple/media/../notify.h"
void purple_notify_searchresults_button_add(PurpleNotifySearchResults *results,
            PurpleNotifySearchButtonType type,
            PurpleNotifySearchResultsCallback cb);
# 256 "/usr/include/libpurple/media/../notify.h"
void purple_notify_searchresults_button_add_labeled(PurpleNotifySearchResults *results,
                                                  const char *label,
                                                  PurpleNotifySearchResultsCallback cb);







PurpleNotifySearchResults *purple_notify_searchresults_new(void);
# 275 "/usr/include/libpurple/media/../notify.h"
PurpleNotifySearchColumn *purple_notify_searchresults_column_new(const char *title);







void purple_notify_searchresults_column_add(PurpleNotifySearchResults *results,
            PurpleNotifySearchColumn *column);







void purple_notify_searchresults_row_add(PurpleNotifySearchResults *results,
            GList *row);
# 313 "/usr/include/libpurple/media/../notify.h"
guint purple_notify_searchresults_get_rows_count(PurpleNotifySearchResults *results);
# 334 "/usr/include/libpurple/media/../notify.h"
guint purple_notify_searchresults_get_columns_count(PurpleNotifySearchResults *results);
# 356 "/usr/include/libpurple/media/../notify.h"
GList *purple_notify_searchresults_row_get(PurpleNotifySearchResults *results,
           unsigned int row_id);
# 377 "/usr/include/libpurple/media/../notify.h"
char *purple_notify_searchresults_column_get_title(PurpleNotifySearchResults *results,
             unsigned int column_id);
# 402 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_message(void *handle, PurpleNotifyMsgType type,
        const char *title, const char *primary,
        const char *secondary, PurpleNotifyCloseCallback cb,
        gpointer user_data);
# 421 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_email(void *handle, const char *subject,
      const char *from, const char *to,
      const char *url, PurpleNotifyCloseCallback cb,
      gpointer user_data);
# 445 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_emails(void *handle, size_t count, gboolean detailed,
       const char **subjects, const char **froms,
       const char **tos, const char **urls,
       PurpleNotifyCloseCallback cb, gpointer user_data);
# 467 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_formatted(void *handle, const char *title,
       const char *primary, const char *secondary,
       const char *text, PurpleNotifyCloseCallback cb, gpointer user_data);
# 486 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_userinfo(PurpleConnection *gc, const char *who,
         PurpleNotifyUserInfo *user_info, PurpleNotifyCloseCallback cb,
         gpointer user_data);







PurpleNotifyUserInfo *purple_notify_user_info_new(void);






void purple_notify_user_info_destroy(PurpleNotifyUserInfo *user_info);
# 522 "/usr/include/libpurple/media/../notify.h"
GList *purple_notify_user_info_get_entries(PurpleNotifyUserInfo *user_info);
# 531 "/usr/include/libpurple/media/../notify.h"
char *purple_notify_user_info_get_text_with_newline(PurpleNotifyUserInfo *user_info, const char *newline);
# 556 "/usr/include/libpurple/media/../notify.h"
void purple_notify_user_info_add_pair(PurpleNotifyUserInfo *user_info, const char *label, const char *value);





void purple_notify_user_info_add_pair_plaintext(PurpleNotifyUserInfo *user_info, const char *label, const char *value);
# 577 "/usr/include/libpurple/media/../notify.h"
void purple_notify_user_info_prepend_pair(PurpleNotifyUserInfo *user_info, const char *label, const char *value);
# 592 "/usr/include/libpurple/media/../notify.h"
void purple_notify_user_info_remove_entry(PurpleNotifyUserInfo *user_info, PurpleNotifyUserInfoEntry *user_info_entry);
# 614 "/usr/include/libpurple/media/../notify.h"
PurpleNotifyUserInfoEntry *purple_notify_user_info_entry_new(const char *label, const char *value);






void purple_notify_user_info_add_section_break(PurpleNotifyUserInfo *user_info);







void purple_notify_user_info_prepend_section_break(PurpleNotifyUserInfo *user_info);
# 638 "/usr/include/libpurple/media/../notify.h"
void purple_notify_user_info_add_section_header(PurpleNotifyUserInfo *user_info, const char *label);
# 648 "/usr/include/libpurple/media/../notify.h"
void purple_notify_user_info_prepend_section_header(PurpleNotifyUserInfo *user_info, const char *label);





void purple_notify_user_info_remove_last_item(PurpleNotifyUserInfo *user_info);
# 663 "/usr/include/libpurple/media/../notify.h"
const gchar *purple_notify_user_info_entry_get_label(PurpleNotifyUserInfoEntry *user_info_entry);







void purple_notify_user_info_entry_set_label(PurpleNotifyUserInfoEntry *user_info_entry, const char *label);
# 680 "/usr/include/libpurple/media/../notify.h"
const gchar *purple_notify_user_info_entry_get_value(PurpleNotifyUserInfoEntry *user_info_entry);







void purple_notify_user_info_entry_set_value(PurpleNotifyUserInfoEntry *user_info_entry, const char *value);
# 698 "/usr/include/libpurple/media/../notify.h"
PurpleNotifyUserInfoEntryType purple_notify_user_info_entry_get_type(PurpleNotifyUserInfoEntry *user_info_entry);







void purple_notify_user_info_entry_set_type(PurpleNotifyUserInfoEntry *user_info_entry,
            PurpleNotifyUserInfoEntryType type);
# 719 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_uri(void *handle, const char *uri);
# 730 "/usr/include/libpurple/media/../notify.h"
void purple_notify_close(PurpleNotifyType type, void *ui_handle);






void purple_notify_close_with_handle(void *handle);
# 773 "/usr/include/libpurple/media/../notify.h"
void purple_notify_set_ui_ops(PurpleNotifyUiOps *ops);







PurpleNotifyUiOps *purple_notify_get_ui_ops(void);
# 795 "/usr/include/libpurple/media/../notify.h"
void *purple_notify_get_handle(void);




void purple_notify_init(void);




void purple_notify_uninit(void);
# 48 "/usr/include/libpurple/media/../util.h" 2






struct _PurpleMenuAction
{
 char *label;
 PurpleCallback callback;
 gpointer data;
 GList *children;
};

typedef char *(*PurpleInfoFieldFormatCallback)(const char *field, size_t len);







struct _PurpleKeyValuePair
{
 gchar *key;
 void *value;

};
# 88 "/usr/include/libpurple/media/../util.h"
PurpleMenuAction *purple_menu_action_new(const char *label, PurpleCallback callback,
                                     gpointer data, GList *children);






void purple_menu_action_free(PurpleMenuAction *act);
# 106 "/usr/include/libpurple/media/../util.h"
void purple_util_set_current_song(const char *title, const char *artist,
  const char *album);
# 120 "/usr/include/libpurple/media/../util.h"
char * purple_util_format_song_info(const char *title, const char *artist,
  const char *album, gpointer unused);
# 133 "/usr/include/libpurple/media/../util.h"
void purple_util_init(void);






void purple_util_uninit(void);
# 160 "/usr/include/libpurple/media/../util.h"
gchar *purple_base16_encode(const guchar *data, gsize len);
# 177 "/usr/include/libpurple/media/../util.h"
guchar *purple_base16_decode(const char *str, gsize *ret_len);
# 191 "/usr/include/libpurple/media/../util.h"
gchar *purple_base16_encode_chunked(const guchar *data, gsize len);
# 212 "/usr/include/libpurple/media/../util.h"
gchar *purple_base64_encode(const guchar *data, gsize len);
# 229 "/usr/include/libpurple/media/../util.h"
guchar *purple_base64_decode(const char *str, gsize *ret_len);
# 250 "/usr/include/libpurple/media/../util.h"
guchar *purple_quotedp_decode(const char *str, gsize *ret_len);
# 278 "/usr/include/libpurple/media/../util.h"
char *purple_mime_decode_field(const char *str);
# 314 "/usr/include/libpurple/media/../util.h"
const char *purple_utf8_strftime(const char *format, const struct tm *tm);
# 324 "/usr/include/libpurple/media/../util.h"
const char *purple_get_tzoff_str(const struct tm *tm, gboolean iso);
# 336 "/usr/include/libpurple/media/../util.h"
const char *purple_date_format_short(const struct tm *tm);
# 348 "/usr/include/libpurple/media/../util.h"
const char *purple_date_format_long(const struct tm *tm);
# 360 "/usr/include/libpurple/media/../util.h"
const char *purple_date_format_full(const struct tm *tm);
# 372 "/usr/include/libpurple/media/../util.h"
const char *purple_time_format(const struct tm *tm);
# 386 "/usr/include/libpurple/media/../util.h"
time_t purple_time_build(int year, int month, int day, int hour,
        int min, int sec);
# 413 "/usr/include/libpurple/media/../util.h"
time_t purple_str_to_time(const char *timestamp, gboolean utc,
                        struct tm *tm, long *tz_off, const char **rest);
# 435 "/usr/include/libpurple/media/../util.h"
gchar *purple_markup_escape_text(const gchar *text, gssize length);
# 452 "/usr/include/libpurple/media/../util.h"
gboolean purple_markup_find_tag(const char *needle, const char *haystack,
         const char **start, const char **end,
         GData **attributes);
# 479 "/usr/include/libpurple/media/../util.h"
gboolean purple_markup_extract_info_field(const char *str, int len, PurpleNotifyUserInfo *user_info,
                                        const char *start_token, int skip,
                                        const char *end_token, char check_value,
                                        const char *no_value_token,
                                        const char *display_name, gboolean is_link,
                                        const char *link_prefix,
     PurpleInfoFieldFormatCallback format_cb);
# 494 "/usr/include/libpurple/media/../util.h"
void purple_markup_html_to_xhtml(const char *html, char **dest_xhtml,
          char **dest_plain);
# 505 "/usr/include/libpurple/media/../util.h"
char *purple_markup_strip_html(const char *str);
# 516 "/usr/include/libpurple/media/../util.h"
char *purple_markup_linkify(const char *str);
# 536 "/usr/include/libpurple/media/../util.h"
char *purple_unescape_text(const char *text);
# 549 "/usr/include/libpurple/media/../util.h"
char *purple_unescape_html(const char *html);
# 572 "/usr/include/libpurple/media/../util.h"
char *purple_markup_slice(const char *str, guint x, guint y);
# 583 "/usr/include/libpurple/media/../util.h"
char *purple_markup_get_tag_name(const char *tag);
# 601 "/usr/include/libpurple/media/../util.h"
const char * purple_markup_unescape_entity(const char *text, int *length);
# 619 "/usr/include/libpurple/media/../util.h"
char * purple_markup_get_css_property(const gchar *style, const gchar *opt);
# 630 "/usr/include/libpurple/media/../util.h"
gboolean purple_markup_is_rtl(const char *html);
# 647 "/usr/include/libpurple/media/../util.h"
const gchar *purple_home_dir(void);
# 657 "/usr/include/libpurple/media/../util.h"
const char *purple_user_dir(void);





void purple_util_set_user_dir(const char *dir);
# 675 "/usr/include/libpurple/media/../util.h"
int purple_build_dir(const char *path, int mode);
# 692 "/usr/include/libpurple/media/../util.h"
gboolean purple_util_write_data_to_file(const char *filename, const char *data,
           gssize size);
# 712 "/usr/include/libpurple/media/../util.h"
gboolean
purple_util_write_data_to_file_absolute(const char *filename_full, const char *data, gssize size);
# 729 "/usr/include/libpurple/media/../util.h"
xmlnode *purple_util_read_xml_from_file(const char *filename,
           const char *description);
# 748 "/usr/include/libpurple/media/../util.h"
FILE *purple_mkstemp(char **path, gboolean binary);
# 758 "/usr/include/libpurple/media/../util.h"
const char *
purple_util_get_image_extension(gconstpointer data, size_t len);




char *purple_util_get_image_checksum(gconstpointer image_data, size_t image_len);
# 773 "/usr/include/libpurple/media/../util.h"
char *purple_util_get_image_filename(gconstpointer image_data, size_t image_len);
# 790 "/usr/include/libpurple/media/../util.h"
gboolean purple_program_is_valid(const char *program);






gboolean purple_running_gnome(void);






gboolean purple_running_kde(void);






gboolean purple_running_osx(void);
# 820 "/usr/include/libpurple/media/../util.h"
char *purple_fd_get_ip(int fd);
# 831 "/usr/include/libpurple/media/../util.h"
int purple_socket_get_family(int fd);
# 843 "/usr/include/libpurple/media/../util.h"
gboolean purple_socket_speaks_ipv4(int fd);
# 866 "/usr/include/libpurple/media/../util.h"
gboolean purple_strequal(const gchar *left, const gchar *right);
# 885 "/usr/include/libpurple/media/../util.h"
const char *purple_normalize(const PurpleAccount *account, const char *str);
# 899 "/usr/include/libpurple/media/../util.h"
const char *purple_normalize_nocase(const PurpleAccount *account, const char *str);
# 910 "/usr/include/libpurple/media/../util.h"
gboolean purple_str_has_prefix(const char *s, const char *p);
# 921 "/usr/include/libpurple/media/../util.h"
gboolean purple_str_has_suffix(const char *s, const char *x);
# 931 "/usr/include/libpurple/media/../util.h"
gchar *purple_strdup_withhtml(const gchar *src);
# 940 "/usr/include/libpurple/media/../util.h"
char *purple_str_add_cr(const char *str);
# 953 "/usr/include/libpurple/media/../util.h"
void purple_str_strip_char(char *str, char thechar);
# 965 "/usr/include/libpurple/media/../util.h"
void purple_util_chrreplace(char *string, char delimiter,
        char replacement);
# 980 "/usr/include/libpurple/media/../util.h"
gchar *purple_strreplace(const char *string, const char *delimiter,
        const char *replacement);
# 994 "/usr/include/libpurple/media/../util.h"
char *purple_utf8_ncr_encode(const char *in);
# 1007 "/usr/include/libpurple/media/../util.h"
char *purple_utf8_ncr_decode(const char *in);
# 1022 "/usr/include/libpurple/media/../util.h"
gchar *purple_strcasereplace(const char *string, const char *delimiter,
         const char *replacement);
# 1034 "/usr/include/libpurple/media/../util.h"
const char *purple_strcasestr(const char *haystack, const char *needle);
# 1044 "/usr/include/libpurple/media/../util.h"
char *purple_str_size_to_units(size_t size);
# 1054 "/usr/include/libpurple/media/../util.h"
char *purple_str_seconds_to_string(guint sec);
# 1069 "/usr/include/libpurple/media/../util.h"
char *purple_str_binary_to_ascii(const unsigned char *binary, guint len);
# 1078 "/usr/include/libpurple/media/../util.h"
void purple_got_protocol_handler_uri(const char *uri);
# 1092 "/usr/include/libpurple/media/../util.h"
gboolean purple_url_parse(const char *url, char **ret_host, int *ret_port,
      char **ret_path, char **ret_user, char **ret_passwd);
# 1110 "/usr/include/libpurple/media/../util.h"
typedef void (*PurpleUtilFetchUrlCallback)(PurpleUtilFetchUrlData *url_data, gpointer user_data, const gchar *url_text, gsize len, const gchar *error_message);
# 1159 "/usr/include/libpurple/media/../util.h"
PurpleUtilFetchUrlData *purple_util_fetch_url_request(const gchar *url,
  gboolean full, const gchar *user_agent, gboolean http11,
  const gchar *request, gboolean include_headers,
  PurpleUtilFetchUrlCallback callback, gpointer data);
# 1181 "/usr/include/libpurple/media/../util.h"
PurpleUtilFetchUrlData *purple_util_fetch_url_request_len(const gchar *url,
  gboolean full, const gchar *user_agent, gboolean http11,
  const gchar *request, gboolean include_headers, gssize max_len,
  PurpleUtilFetchUrlCallback callback, gpointer data);
# 1204 "/usr/include/libpurple/media/../util.h"
PurpleUtilFetchUrlData *purple_util_fetch_url_request_len_with_account(
  PurpleAccount *account, const gchar *url,
  gboolean full, const gchar *user_agent, gboolean http11,
  const gchar *request, gboolean include_headers, gssize max_len,
  PurpleUtilFetchUrlCallback callback, gpointer data);







void purple_util_fetch_url_cancel(PurpleUtilFetchUrlData *url_data);
# 1227 "/usr/include/libpurple/media/../util.h"
const char *purple_url_decode(const char *str);
# 1238 "/usr/include/libpurple/media/../util.h"
const char *purple_url_encode(const char *str);
# 1247 "/usr/include/libpurple/media/../util.h"
gboolean purple_email_is_valid(const char *address);
# 1259 "/usr/include/libpurple/media/../util.h"
gboolean purple_ip_address_is_valid(const char *ip);
# 1269 "/usr/include/libpurple/media/../util.h"
gboolean purple_ipv4_address_is_valid(const char *ip);
# 1279 "/usr/include/libpurple/media/../util.h"
gboolean purple_ipv6_address_is_valid(const char *ip);
# 1290 "/usr/include/libpurple/media/../util.h"
GList *purple_uri_list_extract_uris(const gchar *uri_list);
# 1304 "/usr/include/libpurple/media/../util.h"
GList *purple_uri_list_extract_filenames(const gchar *uri_list);
# 1322 "/usr/include/libpurple/media/../util.h"
gchar *purple_utf8_try_convert(const char *str);
# 1333 "/usr/include/libpurple/media/../util.h"
gchar *purple_utf8_salvage(const char *str);
# 1347 "/usr/include/libpurple/media/../util.h"
gchar *purple_utf8_strip_unprintables(const gchar *str);
# 1359 "/usr/include/libpurple/media/../util.h"
const gchar *purple_gai_strerror(gint errnum);
# 1374 "/usr/include/libpurple/media/../util.h"
int purple_utf8_strcasecmp(const char *a, const char *b);
# 1386 "/usr/include/libpurple/media/../util.h"
gboolean purple_utf8_has_word(const char *haystack, const char *needle);
# 1396 "/usr/include/libpurple/media/../util.h"
void purple_print_utf8_to_console(FILE *filestream, char *message);
# 1407 "/usr/include/libpurple/media/../util.h"
gboolean purple_message_meify(char *message, gssize len);
# 1417 "/usr/include/libpurple/media/../util.h"
char *purple_text_strip_mnemonic(const char *in);
# 1441 "/usr/include/libpurple/media/../util.h"
const char *purple_unescape_filename(const char *str);
# 1450 "/usr/include/libpurple/media/../util.h"
const char *purple_escape_filename(const char *str);
# 1460 "/usr/include/libpurple/media/../util.h"
const char *_purple_oscar_convert(const char *act, const char *protocol);






void purple_restore_default_signal_handlers(void);







const gchar *purple_get_host_name(void);







gchar *purple_uuid_random(void);
# 36 "/usr/include/libpurple/media/codec.h" 2




# 56 "/usr/include/libpurple/media/codec.h"
GType purple_media_codec_get_type(void);
# 70 "/usr/include/libpurple/media/codec.h"
PurpleMediaCodec *purple_media_codec_new(int id, const char *encoding_name,
  PurpleMediaSessionType media_type, guint clock_rate);
# 82 "/usr/include/libpurple/media/codec.h"
guint purple_media_codec_get_id(PurpleMediaCodec *codec);
# 93 "/usr/include/libpurple/media/codec.h"
gchar *purple_media_codec_get_encoding_name(PurpleMediaCodec *codec);
# 104 "/usr/include/libpurple/media/codec.h"
guint purple_media_codec_get_clock_rate(PurpleMediaCodec *codec);
# 115 "/usr/include/libpurple/media/codec.h"
guint purple_media_codec_get_channels(PurpleMediaCodec *codec);
# 129 "/usr/include/libpurple/media/codec.h"
GList *purple_media_codec_get_optional_parameters(PurpleMediaCodec *codec);
# 140 "/usr/include/libpurple/media/codec.h"
void purple_media_codec_add_optional_parameter(PurpleMediaCodec *codec,
  const gchar *name, const gchar *value);
# 151 "/usr/include/libpurple/media/codec.h"
void purple_media_codec_remove_optional_parameter(PurpleMediaCodec *codec,
  PurpleKeyValuePair *param);
# 165 "/usr/include/libpurple/media/codec.h"
PurpleKeyValuePair *purple_media_codec_get_optional_parameter(
  PurpleMediaCodec *codec, const gchar *name,
  const gchar *value);
# 178 "/usr/include/libpurple/media/codec.h"
PurpleMediaCodec *purple_media_codec_copy(PurpleMediaCodec *codec);
# 189 "/usr/include/libpurple/media/codec.h"
GList *purple_media_codec_list_copy(GList *codecs);
# 198 "/usr/include/libpurple/media/codec.h"
void purple_media_codec_list_free(GList *codecs);
# 209 "/usr/include/libpurple/media/codec.h"
gchar *purple_media_codec_to_string(const PurpleMediaCodec *codec);


# 32 "/usr/include/libpurple/media.h" 2
# 1 "/usr/include/libpurple/media/enum-types.h" 1
# 33 "/usr/include/libpurple/media.h" 2





# 47 "/usr/include/libpurple/media.h"
typedef struct _PurpleMedia PurpleMedia;


# 1 "/usr/include/libpurple/util.h" 1
# 51 "/usr/include/libpurple/media.h" 2
# 63 "/usr/include/libpurple/media.h"
GType purple_media_get_type(void);
# 74 "/usr/include/libpurple/media.h"
GList *purple_media_get_session_ids(PurpleMedia *media);
# 85 "/usr/include/libpurple/media.h"
PurpleAccount *purple_media_get_account(PurpleMedia *media);
# 96 "/usr/include/libpurple/media.h"
gpointer purple_media_get_prpl_data(PurpleMedia *media);
# 106 "/usr/include/libpurple/media.h"
void purple_media_set_prpl_data(PurpleMedia *media, gpointer prpl_data);
# 117 "/usr/include/libpurple/media.h"
void purple_media_error(PurpleMedia *media, const gchar *error, ...);
# 128 "/usr/include/libpurple/media.h"
void purple_media_end(PurpleMedia *media, const gchar *session_id,
  const gchar *participant);
# 142 "/usr/include/libpurple/media.h"
void purple_media_stream_info(PurpleMedia *media, PurpleMediaInfoType type,
  const gchar *session_id, const gchar *participant,
  gboolean local);
# 164 "/usr/include/libpurple/media.h"
void purple_media_set_params(PurpleMedia *media,
  guint num_params, GParameter *params);
# 178 "/usr/include/libpurple/media.h"
const gchar **purple_media_get_available_params(PurpleMedia *media);
# 190 "/usr/include/libpurple/media.h"
gboolean purple_media_param_is_supported(PurpleMedia *media, const gchar *param);
# 211 "/usr/include/libpurple/media.h"
gboolean purple_media_add_stream(PurpleMedia *media, const gchar *sess_id,
  const gchar *who, PurpleMediaSessionType type,
  gboolean initiator, const gchar *transmitter,
  guint num_params, GParameter *params);
# 226 "/usr/include/libpurple/media.h"
PurpleMediaSessionType purple_media_get_session_type(PurpleMedia *media, const gchar *sess_id);
# 237 "/usr/include/libpurple/media.h"
struct _PurpleMediaManager *purple_media_get_manager(PurpleMedia *media);
# 249 "/usr/include/libpurple/media.h"
GList *purple_media_get_codecs(PurpleMedia *media, const gchar *sess_id);
# 261 "/usr/include/libpurple/media.h"
void purple_media_add_remote_candidates(PurpleMedia *media,
     const gchar *sess_id,
     const gchar *participant,
     GList *remote_candidates);
# 275 "/usr/include/libpurple/media.h"
GList *purple_media_get_local_candidates(PurpleMedia *media,
      const gchar *sess_id,
      const gchar *participant);
# 291 "/usr/include/libpurple/media.h"
GList *purple_media_get_active_local_candidates(PurpleMedia *media,
  const gchar *sess_id, const gchar *participant);
# 306 "/usr/include/libpurple/media.h"
GList *purple_media_get_active_remote_candidates(PurpleMedia *media,
  const gchar *sess_id, const gchar *participant);
# 321 "/usr/include/libpurple/media.h"
gboolean purple_media_set_remote_codecs(PurpleMedia *media, const gchar *sess_id,
     const gchar *participant, GList *codecs);
# 335 "/usr/include/libpurple/media.h"
gboolean purple_media_candidates_prepared(PurpleMedia *media,
  const gchar *session_id, const gchar *participant);
# 349 "/usr/include/libpurple/media.h"
gboolean purple_media_set_send_codec(PurpleMedia *media, const gchar *sess_id, PurpleMediaCodec *codec);
# 361 "/usr/include/libpurple/media.h"
gboolean purple_media_codecs_ready(PurpleMedia *media, const gchar *sess_id);
# 374 "/usr/include/libpurple/media.h"
gboolean purple_media_is_initiator(PurpleMedia *media,
  const gchar *sess_id, const gchar *participant);
# 388 "/usr/include/libpurple/media.h"
gboolean purple_media_accepted(PurpleMedia *media, const gchar *sess_id,
  const gchar *participant);
# 400 "/usr/include/libpurple/media.h"
void purple_media_set_input_volume(PurpleMedia *media, const gchar *session_id, double level);
# 412 "/usr/include/libpurple/media.h"
void purple_media_set_output_volume(PurpleMedia *media, const gchar *session_id,
  const gchar *participant, double level);
# 427 "/usr/include/libpurple/media.h"
gulong purple_media_set_output_window(PurpleMedia *media,
  const gchar *session_id, const gchar *participant,
  gulong window_id);
# 438 "/usr/include/libpurple/media.h"
void purple_media_remove_output_windows(PurpleMedia *media);






# 76 "/usr/include/libpurple/prpl.h" 2
# 1 "/usr/include/libpurple/notify.h" 1
# 77 "/usr/include/libpurple/prpl.h" 2
# 1 "/usr/include/libpurple/proxy.h" 1
# 30 "/usr/include/libpurple/proxy.h"
# 1 "/usr/include/libpurple/eventloop.h" 1
# 38 "/usr/include/libpurple/eventloop.h"
typedef enum
{
 PURPLE_INPUT_READ = 1 << 0,
 PURPLE_INPUT_WRITE = 1 << 1

} PurpleInputCondition;






typedef void (*PurpleInputFunction)(gpointer, gint, PurpleInputCondition);


typedef struct _PurpleEventLoopUiOps PurpleEventLoopUiOps;






struct _PurpleEventLoopUiOps
{
# 85 "/usr/include/libpurple/eventloop.h"
 guint (*timeout_add)(guint interval, GSourceFunc function, gpointer data);
# 95 "/usr/include/libpurple/eventloop.h"
 gboolean (*timeout_remove)(guint handle);
# 112 "/usr/include/libpurple/eventloop.h"
 guint (*input_add)(int fd, PurpleInputCondition cond,
                    PurpleInputFunction func, gpointer user_data);







 gboolean (*input_remove)(guint handle);
# 134 "/usr/include/libpurple/eventloop.h"
 int (*input_get_error)(int fd, int *error);
# 150 "/usr/include/libpurple/eventloop.h"
 guint (*timeout_add_seconds)(guint interval, GSourceFunc function,
                              gpointer data);

 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};
# 178 "/usr/include/libpurple/eventloop.h"
guint purple_timeout_add(guint interval, GSourceFunc function, gpointer data);
# 198 "/usr/include/libpurple/eventloop.h"
guint purple_timeout_add_seconds(guint interval, GSourceFunc function, gpointer data);
# 207 "/usr/include/libpurple/eventloop.h"
gboolean purple_timeout_remove(guint handle);
# 220 "/usr/include/libpurple/eventloop.h"
guint purple_input_add(int fd, PurpleInputCondition cond,
                       PurpleInputFunction func, gpointer user_data);







gboolean purple_input_remove(guint handle);
# 245 "/usr/include/libpurple/eventloop.h"
int
purple_input_get_error(int fd, int *error);
# 261 "/usr/include/libpurple/eventloop.h"
void purple_eventloop_set_ui_ops(PurpleEventLoopUiOps *ops);






PurpleEventLoopUiOps *purple_eventloop_get_ui_ops(void);
# 31 "/usr/include/libpurple/proxy.h" 2




typedef enum
{
 PURPLE_PROXY_USE_GLOBAL = -1,
 PURPLE_PROXY_NONE = 0,
 PURPLE_PROXY_HTTP,
 PURPLE_PROXY_SOCKS4,
 PURPLE_PROXY_SOCKS5,
 PURPLE_PROXY_USE_ENVVAR,
 PURPLE_PROXY_TOR

} PurpleProxyType;




typedef struct
{
 PurpleProxyType type;

 char *host;
 int port;
 char *username;
 char *password;

} PurpleProxyInfo;

typedef struct _PurpleProxyConnectData PurpleProxyConnectData;

typedef void (*PurpleProxyConnectFunction)(gpointer data, gint source, const gchar *error_message);
# 82 "/usr/include/libpurple/proxy.h"
PurpleProxyInfo *purple_proxy_info_new(void);






void purple_proxy_info_destroy(PurpleProxyInfo *info);







void purple_proxy_info_set_type(PurpleProxyInfo *info, PurpleProxyType type);







void purple_proxy_info_set_host(PurpleProxyInfo *info, const char *host);







void purple_proxy_info_set_port(PurpleProxyInfo *info, int port);







void purple_proxy_info_set_username(PurpleProxyInfo *info, const char *username);







void purple_proxy_info_set_password(PurpleProxyInfo *info, const char *password);
# 138 "/usr/include/libpurple/proxy.h"
PurpleProxyType purple_proxy_info_get_type(const PurpleProxyInfo *info);
# 147 "/usr/include/libpurple/proxy.h"
const char *purple_proxy_info_get_host(const PurpleProxyInfo *info);
# 156 "/usr/include/libpurple/proxy.h"
int purple_proxy_info_get_port(const PurpleProxyInfo *info);
# 165 "/usr/include/libpurple/proxy.h"
const char *purple_proxy_info_get_username(const PurpleProxyInfo *info);
# 174 "/usr/include/libpurple/proxy.h"
const char *purple_proxy_info_get_password(const PurpleProxyInfo *info);
# 188 "/usr/include/libpurple/proxy.h"
PurpleProxyInfo *purple_global_proxy_get_info(void);







void purple_global_proxy_set_info(PurpleProxyInfo *info);
# 210 "/usr/include/libpurple/proxy.h"
void *purple_proxy_get_handle(void);




void purple_proxy_init(void);




void purple_proxy_uninit(void);
# 229 "/usr/include/libpurple/proxy.h"
PurpleProxyInfo *purple_proxy_get_setup(PurpleAccount *account);
# 255 "/usr/include/libpurple/proxy.h"
PurpleProxyConnectData *purple_proxy_connect(void *handle,
   PurpleAccount *account,
   const char *host, int port,
   PurpleProxyConnectFunction connect_cb, gpointer data);
# 284 "/usr/include/libpurple/proxy.h"
PurpleProxyConnectData *purple_proxy_connect_udp(void *handle,
   PurpleAccount *account,
   const char *host, int port,
   PurpleProxyConnectFunction connect_cb, gpointer data);
# 314 "/usr/include/libpurple/proxy.h"
PurpleProxyConnectData *purple_proxy_connect_socks5_account(void *handle,
   PurpleAccount *account, PurpleProxyInfo *gpi,
   const char *host, int port,
   PurpleProxyConnectFunction connect_cb, gpointer data);
# 342 "/usr/include/libpurple/proxy.h"
PurpleProxyConnectData *purple_proxy_connect_socks5(void *handle,
   PurpleProxyInfo *gpi,
   const char *host, int port,
   PurpleProxyConnectFunction connect_cb, gpointer data);
# 357 "/usr/include/libpurple/proxy.h"
void purple_proxy_connect_cancel(PurpleProxyConnectData *connect_data);






void purple_proxy_connect_cancel_with_handle(void *handle);
# 78 "/usr/include/libpurple/prpl.h" 2

# 1 "/usr/include/libpurple/roomlist.h" 1
# 30 "/usr/include/libpurple/roomlist.h"
typedef struct _PurpleRoomlist PurpleRoomlist;
typedef struct _PurpleRoomlistRoom PurpleRoomlistRoom;
typedef struct _PurpleRoomlistField PurpleRoomlistField;

typedef struct _PurpleRoomlistUiOps PurpleRoomlistUiOps;






typedef enum
{
 PURPLE_ROOMLIST_ROOMTYPE_CATEGORY = 0x01,
 PURPLE_ROOMLIST_ROOMTYPE_ROOM = 0x02

} PurpleRoomlistRoomType;




typedef enum
{
 PURPLE_ROOMLIST_FIELD_BOOL,
 PURPLE_ROOMLIST_FIELD_INT,
 PURPLE_ROOMLIST_FIELD_STRING

} PurpleRoomlistFieldType;
# 69 "/usr/include/libpurple/roomlist.h"
struct _PurpleRoomlist {
 PurpleAccount *account;
 GList *fields;
 GList *rooms;
 gboolean in_progress;
 gpointer ui_data;
 gpointer proto_data;
 guint ref;
};




struct _PurpleRoomlistRoom {
 PurpleRoomlistRoomType type;
 gchar *name;
 GList *fields;
 PurpleRoomlistRoom *parent;
 gboolean expanded_once;
};




struct _PurpleRoomlistField {
 PurpleRoomlistFieldType type;
 gchar *label;
 gchar *name;
 gboolean hidden;
};




struct _PurpleRoomlistUiOps {
 void (*show_with_account)(PurpleAccount *account);
 void (*create)(PurpleRoomlist *list);
 void (*set_fields)(PurpleRoomlist *list, GList *fields);
 void (*add_room)(PurpleRoomlist *list, PurpleRoomlistRoom *room);
 void (*in_progress)(PurpleRoomlist *list, gboolean flag);
 void (*destroy)(PurpleRoomlist *list);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};
# 136 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_show_with_account(PurpleAccount *account);
# 146 "/usr/include/libpurple/roomlist.h"
PurpleRoomlist *purple_roomlist_new(PurpleAccount *account);






void purple_roomlist_ref(PurpleRoomlist *list);
# 163 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_unref(PurpleRoomlist *list);
# 174 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_set_fields(PurpleRoomlist *list, GList *fields);
# 185 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_set_in_progress(PurpleRoomlist *list, gboolean in_progress);
# 196 "/usr/include/libpurple/roomlist.h"
gboolean purple_roomlist_get_in_progress(PurpleRoomlist *list);
# 205 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_room_add(PurpleRoomlist *list, PurpleRoomlistRoom *room);
# 216 "/usr/include/libpurple/roomlist.h"
PurpleRoomlist *purple_roomlist_get_list(PurpleConnection *gc);
# 226 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_cancel_get_list(PurpleRoomlist *list);
# 239 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_expand_category(PurpleRoomlist *list, PurpleRoomlistRoom *category);
# 248 "/usr/include/libpurple/roomlist.h"
GList * purple_roomlist_get_fields(PurpleRoomlist *roomlist);
# 266 "/usr/include/libpurple/roomlist.h"
PurpleRoomlistRoom *purple_roomlist_room_new(PurpleRoomlistRoomType type, const gchar *name,
                                         PurpleRoomlistRoom *parent);
# 276 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_room_add_field(PurpleRoomlist *list, PurpleRoomlistRoom *room, gconstpointer field);







void purple_roomlist_room_join(PurpleRoomlist *list, PurpleRoomlistRoom *room);







PurpleRoomlistRoomType purple_roomlist_room_get_type(PurpleRoomlistRoom *room);







const char * purple_roomlist_room_get_name(PurpleRoomlistRoom *room);







PurpleRoomlistRoom * purple_roomlist_room_get_parent(PurpleRoomlistRoom *room);
# 317 "/usr/include/libpurple/roomlist.h"
GList * purple_roomlist_room_get_fields(PurpleRoomlistRoom *room);
# 337 "/usr/include/libpurple/roomlist.h"
PurpleRoomlistField *purple_roomlist_field_new(PurpleRoomlistFieldType type,
                                           const gchar *label, const gchar *name,
                                           gboolean hidden);
# 349 "/usr/include/libpurple/roomlist.h"
PurpleRoomlistFieldType purple_roomlist_field_get_type(PurpleRoomlistField *field);
# 359 "/usr/include/libpurple/roomlist.h"
const char * purple_roomlist_field_get_label(PurpleRoomlistField *field);
# 368 "/usr/include/libpurple/roomlist.h"
gboolean purple_roomlist_field_get_hidden(PurpleRoomlistField *field);
# 382 "/usr/include/libpurple/roomlist.h"
void purple_roomlist_set_ui_ops(PurpleRoomlistUiOps *ops);







PurpleRoomlistUiOps *purple_roomlist_get_ui_ops(void);
# 80 "/usr/include/libpurple/prpl.h" 2
# 1 "/usr/include/libpurple/status.h" 1
# 81 "/usr/include/libpurple/prpl.h" 2
# 1 "/usr/include/libpurple/whiteboard.h" 1
# 32 "/usr/include/libpurple/whiteboard.h"
typedef struct _PurpleWhiteboardPrplOps PurpleWhiteboardPrplOps;






typedef struct _PurpleWhiteboard
{
 int state;

 PurpleAccount *account;
 char *who;

 void *ui_data;
 void *proto_data;
 PurpleWhiteboardPrplOps *prpl_ops;

 GList *draw_list;
} PurpleWhiteboard;




typedef struct _PurpleWhiteboardUiOps
{
 void (*create)(PurpleWhiteboard *wb);
 void (*destroy)(PurpleWhiteboard *wb);
 void (*set_dimensions)(PurpleWhiteboard *wb, int width, int height);
 void (*set_brush) (PurpleWhiteboard *wb, int size, int color);
 void (*draw_point)(PurpleWhiteboard *wb, int x, int y,
        int color, int size);
 void (*draw_line)(PurpleWhiteboard *wb, int x1, int y1,
       int x2, int y2,
       int color, int size);
 void (*clear)(PurpleWhiteboard *wb);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
} PurpleWhiteboardUiOps;




struct _PurpleWhiteboardPrplOps
{
 void (*start)(PurpleWhiteboard *wb);
 void (*end)(PurpleWhiteboard *wb);
 void (*get_dimensions)(const PurpleWhiteboard *wb, int *width, int *height);
 void (*set_dimensions)(PurpleWhiteboard *wb, int width, int height);
 void (*get_brush) (const PurpleWhiteboard *wb, int *size, int *color);
 void (*set_brush) (PurpleWhiteboard *wb, int size, int color);
 void (*send_draw_list)(PurpleWhiteboard *wb, GList *draw_list);
 void (*clear)(PurpleWhiteboard *wb);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};
# 109 "/usr/include/libpurple/whiteboard.h"
void purple_whiteboard_set_ui_ops(PurpleWhiteboardUiOps *ops);







void purple_whiteboard_set_prpl_ops(PurpleWhiteboard *wb, PurpleWhiteboardPrplOps *ops);
# 128 "/usr/include/libpurple/whiteboard.h"
PurpleWhiteboard *purple_whiteboard_create(PurpleAccount *account, const char *who, int state);






void purple_whiteboard_destroy(PurpleWhiteboard *wb);






void purple_whiteboard_start(PurpleWhiteboard *wb);
# 152 "/usr/include/libpurple/whiteboard.h"
PurpleWhiteboard *purple_whiteboard_get_session(const PurpleAccount *account, const char *who);






void purple_whiteboard_draw_list_destroy(GList *draw_list);
# 170 "/usr/include/libpurple/whiteboard.h"
gboolean purple_whiteboard_get_dimensions(const PurpleWhiteboard *wb, int *width, int *height);
# 179 "/usr/include/libpurple/whiteboard.h"
void purple_whiteboard_set_dimensions(PurpleWhiteboard *wb, int width, int height);
# 190 "/usr/include/libpurple/whiteboard.h"
void purple_whiteboard_draw_point(PurpleWhiteboard *wb, int x, int y, int color, int size);







void purple_whiteboard_send_draw_list(PurpleWhiteboard *wb, GList *list);
# 211 "/usr/include/libpurple/whiteboard.h"
void purple_whiteboard_draw_line(PurpleWhiteboard *wb, int x1, int y1, int x2, int y2, int color, int size);






void purple_whiteboard_clear(PurpleWhiteboard *wb);






void purple_whiteboard_send_clear(PurpleWhiteboard *wb);
# 234 "/usr/include/libpurple/whiteboard.h"
void purple_whiteboard_send_brush(PurpleWhiteboard *wb, int size, int color);
# 245 "/usr/include/libpurple/whiteboard.h"
gboolean purple_whiteboard_get_brush(const PurpleWhiteboard *wb, int *size, int *color);
# 254 "/usr/include/libpurple/whiteboard.h"
void purple_whiteboard_set_brush(PurpleWhiteboard *wb, int size, int color);
# 82 "/usr/include/libpurple/prpl.h" 2



struct _PurpleBuddyIconSpec {





 char *format;

 int min_width;
 int min_height;
 int max_width;
 int max_height;
 size_t max_filesize;
 PurpleIconScaleRules scale_rules;
};




struct proto_chat_entry {
 const char *label;
 const char *identifier;
 gboolean required;
 gboolean is_int;
 int min;
 int max;
 gboolean secret;
};




struct _PurpleAttentionType
{
 const char *name;
 const char *incoming_description;
 const char *outgoing_description;
 const char *icon_name;
 const char *unlocalized_name;


 gpointer _reserved2;
 gpointer _reserved3;
 gpointer _reserved4;
};






typedef enum
{







 OPT_PROTO_UNIQUE_CHATNAME = 0x00000004,






 OPT_PROTO_CHAT_TOPIC = 0x00000008,







 OPT_PROTO_NO_PASSWORD = 0x00000010,






 OPT_PROTO_MAIL_CHECK = 0x00000020,






 OPT_PROTO_IM_IMAGE = 0x00000040,







 OPT_PROTO_PASSWORD_OPTIONAL = 0x00000080,






 OPT_PROTO_USE_POINTSIZE = 0x00000100,
# 198 "/usr/include/libpurple/prpl.h"
 OPT_PROTO_REGISTER_NOSCREENNAME = 0x00000200,






 OPT_PROTO_SLASH_COMMANDS_NATIVE = 0x00000400,






 OPT_PROTO_INVITE_MESSAGE = 0x00000800

} PurpleProtocolOptions;
# 223 "/usr/include/libpurple/prpl.h"
struct _PurplePluginProtocolInfo
{
 PurpleProtocolOptions options;

 GList *user_splits;
 GList *protocol_options;

 PurpleBuddyIconSpec icon_spec;
# 240 "/usr/include/libpurple/prpl.h"
 const char *(*list_icon)(PurpleAccount *account, PurpleBuddy *buddy);





 const char *(*list_emblem)(PurpleBuddy *buddy);





 char *(*status_text)(PurpleBuddy *buddy);




 void (*tooltip_text)(PurpleBuddy *buddy, PurpleNotifyUserInfo *user_info, gboolean full);






 GList *(*status_types)(PurpleAccount *account);






 GList *(*blist_node_menu)(PurpleBlistNode *node);
# 280 "/usr/include/libpurple/prpl.h"
 GList *(*chat_info)(PurpleConnection *);
# 292 "/usr/include/libpurple/prpl.h"
 GHashTable *(*chat_info_defaults)(PurpleConnection *, const char *chat_name);




 void (*login)(PurpleAccount *);


 void (*close)(PurpleConnection *);
# 311 "/usr/include/libpurple/prpl.h"
 int (*send_im)(PurpleConnection *, const char *who,
     const char *message,
     PurpleMessageFlags flags);

 void (*set_info)(PurpleConnection *, const char *info);
# 324 "/usr/include/libpurple/prpl.h"
 unsigned int (*send_typing)(PurpleConnection *, const char *name, PurpleTypingState state);





 void (*get_info)(PurpleConnection *, const char *who);
 void (*set_status)(PurpleAccount *account, PurpleStatus *status);

 void (*set_idle)(PurpleConnection *, int idletime);
 void (*change_passwd)(PurpleConnection *, const char *old_pass,
        const char *new_pass);
# 347 "/usr/include/libpurple/prpl.h"
 void (*add_buddy)(PurpleConnection *, PurpleBuddy *buddy, PurpleGroup *group);
 void (*add_buddies)(PurpleConnection *, GList *buddies, GList *groups);
 void (*remove_buddy)(PurpleConnection *, PurpleBuddy *buddy, PurpleGroup *group);
 void (*remove_buddies)(PurpleConnection *, GList *buddies, GList *groups);
 void (*add_permit)(PurpleConnection *, const char *name);
 void (*add_deny)(PurpleConnection *, const char *name);
 void (*rem_permit)(PurpleConnection *, const char *name);
 void (*rem_deny)(PurpleConnection *, const char *name);
 void (*set_permit_deny)(PurpleConnection *);
# 367 "/usr/include/libpurple/prpl.h"
 void (*join_chat)(PurpleConnection *, GHashTable *components);







 void (*reject_chat)(PurpleConnection *, GHashTable *components);
# 384 "/usr/include/libpurple/prpl.h"
 char *(*get_chat_name)(GHashTable *components);
# 394 "/usr/include/libpurple/prpl.h"
 void (*chat_invite)(PurpleConnection *, int id,
      const char *message, const char *who);





 void (*chat_leave)(PurpleConnection *, int id);
# 410 "/usr/include/libpurple/prpl.h"
 void (*chat_whisper)(PurpleConnection *, int id,
       const char *who, const char *message);
# 430 "/usr/include/libpurple/prpl.h"
 int (*chat_send)(PurpleConnection *, int id, const char *message, PurpleMessageFlags flags);







 void (*keepalive)(PurpleConnection *);


 void (*register_user)(PurpleAccount *);




 void (*get_cb_info)(PurpleConnection *, int, const char *who);




 void (*get_cb_away)(PurpleConnection *, int, const char *who);


 void (*alias_buddy)(PurpleConnection *, const char *who,
      const char *alias);


 void (*group_buddy)(PurpleConnection *, const char *who,
      const char *old_group, const char *new_group);


 void (*rename_group)(PurpleConnection *, const char *old_name,
       PurpleGroup *group, GList *moved_buddies);

 void (*buddy_free)(PurpleBuddy *);

 void (*convo_closed)(PurpleConnection *, const char *who);






 const char *(*normalize)(const PurpleAccount *, const char *who);






 void (*set_buddy_icon)(PurpleConnection *, PurpleStoredImage *img);

 void (*remove_group)(PurpleConnection *gc, PurpleGroup *group);
# 494 "/usr/include/libpurple/prpl.h"
 char *(*get_cb_real_name)(PurpleConnection *gc, int id, const char *who);

 void (*set_chat_topic)(PurpleConnection *gc, int id, const char *topic);

 PurpleChat *(*find_blist_chat)(PurpleAccount *account, const char *name);


 PurpleRoomlist *(*roomlist_get_list)(PurpleConnection *gc);
 void (*roomlist_cancel)(PurpleRoomlist *list);
 void (*roomlist_expand_category)(PurpleRoomlist *list, PurpleRoomlistRoom *category);


 gboolean (*can_receive_file)(PurpleConnection *, const char *who);
 void (*send_file)(PurpleConnection *, const char *who, const char *filename);
 PurpleXfer *(*new_xfer)(PurpleConnection *, const char *who);





 gboolean (*offline_message)(const PurpleBuddy *buddy);

 PurpleWhiteboardPrplOps *whiteboard_prpl_ops;


 int (*send_raw)(PurpleConnection *gc, const char *buf, int len);


 char *(*roomlist_room_serialize)(PurpleRoomlistRoom *room);
# 531 "/usr/include/libpurple/prpl.h"
 void (*unregister_user)(PurpleAccount *, PurpleAccountUnregistrationCb cb, void *user_data);


 gboolean (*send_attention)(PurpleConnection *gc, const char *username, guint type);
 GList *(*get_attention_types)(PurpleAccount *acct);





 unsigned long struct_size;
# 567 "/usr/include/libpurple/prpl.h"
 GHashTable *(*get_account_text_table)(PurpleAccount *account);
# 577 "/usr/include/libpurple/prpl.h"
 gboolean (*initiate_media)(PurpleAccount *account, const char *who,
     PurpleMediaSessionType type);
# 587 "/usr/include/libpurple/prpl.h"
 PurpleMediaCaps (*get_media_caps)(PurpleAccount *account,
       const char *who);






 PurpleMood *(*get_moods)(PurpleAccount *account);
# 615 "/usr/include/libpurple/prpl.h"
 void (*set_public_alias)(PurpleConnection *gc, const char *alias,
                          PurpleSetPublicAliasSuccessCallback success_cb,
                          PurpleSetPublicAliasFailureCallback failure_cb);
# 632 "/usr/include/libpurple/prpl.h"
 void (*get_public_alias)(PurpleConnection *gc,
                          PurpleGetPublicAliasSuccessCallback success_cb,
                          PurpleGetPublicAliasFailureCallback failure_cb);
# 648 "/usr/include/libpurple/prpl.h"
 void (*add_buddy_with_invite)(PurpleConnection *pc, PurpleBuddy *buddy, PurpleGroup *group, const char *message);
 void (*add_buddies_with_invite)(PurpleConnection *pc, GList *buddies, GList *groups, const char *message);
};
# 686 "/usr/include/libpurple/prpl.h"
PurpleAttentionType *purple_attention_type_new(const char *ulname, const char *name,
        const char *inc_desc, const char *out_desc);
# 698 "/usr/include/libpurple/prpl.h"
void purple_attention_type_set_name(PurpleAttentionType *type, const char *name);
# 708 "/usr/include/libpurple/prpl.h"
void purple_attention_type_set_incoming_desc(PurpleAttentionType *type, const char *desc);
# 718 "/usr/include/libpurple/prpl.h"
void purple_attention_type_set_outgoing_desc(PurpleAttentionType *type, const char *desc);
# 728 "/usr/include/libpurple/prpl.h"
void purple_attention_type_set_icon_name(PurpleAttentionType *type, const char *name);
# 739 "/usr/include/libpurple/prpl.h"
void purple_attention_type_set_unlocalized_name(PurpleAttentionType *type, const char *ulname);
# 748 "/usr/include/libpurple/prpl.h"
const char *purple_attention_type_get_name(const PurpleAttentionType *type);
# 757 "/usr/include/libpurple/prpl.h"
const char *purple_attention_type_get_incoming_desc(const PurpleAttentionType *type);
# 766 "/usr/include/libpurple/prpl.h"
const char *purple_attention_type_get_outgoing_desc(const PurpleAttentionType *type);
# 776 "/usr/include/libpurple/prpl.h"
const char *purple_attention_type_get_icon_name(const PurpleAttentionType *type);
# 785 "/usr/include/libpurple/prpl.h"
const char *purple_attention_type_get_unlocalized_name(const PurpleAttentionType *type);
# 803 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_account_idle(PurpleAccount *account, gboolean idle,
        time_t idle_time);
# 814 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_account_login_time(PurpleAccount *account, time_t login_time);
# 826 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_account_status(PurpleAccount *account,
          const char *status_id, ...) __attribute__((__sentinel__));
# 841 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_account_actions(PurpleAccount *account);
# 856 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_user_idle(PurpleAccount *account, const char *name,
        gboolean idle, time_t idle_time);
# 868 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_user_login_time(PurpleAccount *account, const char *name,
           time_t login_time);
# 882 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_user_status(PurpleAccount *account, const char *name,
          const char *status_id, ...) __attribute__((__sentinel__));
# 894 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_user_status_deactive(PurpleAccount *account, const char *name,
     const char *status_id);
# 905 "/usr/include/libpurple/prpl.h"
void purple_prpl_change_account_status(PurpleAccount *account,
          PurpleStatus *old_status,
          PurpleStatus *new_status);
# 917 "/usr/include/libpurple/prpl.h"
GList *purple_prpl_get_statuses(PurpleAccount *account, PurplePresence *presence);
# 933 "/usr/include/libpurple/prpl.h"
void purple_prpl_send_attention(PurpleConnection *gc, const char *who, guint type_code);
# 945 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_attention(PurpleConnection *gc, const char *who, guint type_code);
# 958 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_attention_in_chat(PurpleConnection *gc, int id, const char *who, guint type_code);
# 968 "/usr/include/libpurple/prpl.h"
PurpleMediaCaps purple_prpl_get_media_caps(PurpleAccount *account,
      const char *who);
# 980 "/usr/include/libpurple/prpl.h"
gboolean purple_prpl_initiate_media(PurpleAccount *account,
     const char *who,
     PurpleMediaSessionType type);
# 993 "/usr/include/libpurple/prpl.h"
void purple_prpl_got_media_caps(PurpleAccount *account, const char *who);
# 1007 "/usr/include/libpurple/prpl.h"
PurplePlugin *purple_find_prpl(const char *id);
# 40 "/usr/include/libpurple/buddyicon.h" 2
# 66 "/usr/include/libpurple/buddyicon.h"
PurpleBuddyIcon *purple_buddy_icon_new(PurpleAccount *account, const char *username,
                                       void *icon_data, size_t icon_len,
                                       const char *checksum);
# 77 "/usr/include/libpurple/buddyicon.h"
PurpleBuddyIcon *purple_buddy_icon_ref(PurpleBuddyIcon *icon);
# 88 "/usr/include/libpurple/buddyicon.h"
PurpleBuddyIcon *purple_buddy_icon_unref(PurpleBuddyIcon *icon);






void purple_buddy_icon_update(PurpleBuddyIcon *icon);
# 106 "/usr/include/libpurple/buddyicon.h"
void
purple_buddy_icon_set_data(PurpleBuddyIcon *icon, guchar *data,
                           size_t len, const char *checksum);
# 117 "/usr/include/libpurple/buddyicon.h"
PurpleAccount *purple_buddy_icon_get_account(const PurpleBuddyIcon *icon);
# 126 "/usr/include/libpurple/buddyicon.h"
const char *purple_buddy_icon_get_username(const PurpleBuddyIcon *icon);
# 137 "/usr/include/libpurple/buddyicon.h"
const char *purple_buddy_icon_get_checksum(const PurpleBuddyIcon *icon);
# 148 "/usr/include/libpurple/buddyicon.h"
gconstpointer purple_buddy_icon_get_data(const PurpleBuddyIcon *icon, size_t *len);
# 158 "/usr/include/libpurple/buddyicon.h"
const char *purple_buddy_icon_get_extension(const PurpleBuddyIcon *icon);
# 174 "/usr/include/libpurple/buddyicon.h"
char *purple_buddy_icon_get_full_path(PurpleBuddyIcon *icon);
# 193 "/usr/include/libpurple/buddyicon.h"
void
purple_buddy_icons_set_for_user(PurpleAccount *account, const char *username,
                                void *icon_data, size_t icon_len,
                                const char *checksum);
# 208 "/usr/include/libpurple/buddyicon.h"
const char *
purple_buddy_icons_get_checksum_for_user(PurpleBuddy *buddy);
# 220 "/usr/include/libpurple/buddyicon.h"
PurpleBuddyIcon *
purple_buddy_icons_find(PurpleAccount *account, const char *username);
# 237 "/usr/include/libpurple/buddyicon.h"
PurpleStoredImage *
purple_buddy_icons_find_account_icon(PurpleAccount *account);
# 255 "/usr/include/libpurple/buddyicon.h"
PurpleStoredImage *
purple_buddy_icons_set_account_icon(PurpleAccount *account,
                                    guchar *icon_data, size_t icon_len);
# 269 "/usr/include/libpurple/buddyicon.h"
time_t
purple_buddy_icons_get_account_icon_timestamp(PurpleAccount *account);
# 280 "/usr/include/libpurple/buddyicon.h"
gboolean
purple_buddy_icons_node_has_custom_icon(PurpleBlistNode *node);
# 298 "/usr/include/libpurple/buddyicon.h"
PurpleStoredImage *
purple_buddy_icons_node_find_custom_icon(PurpleBlistNode *node);
# 316 "/usr/include/libpurple/buddyicon.h"
PurpleStoredImage *
purple_buddy_icons_node_set_custom_icon(PurpleBlistNode *node,
                                        guchar *icon_data, size_t icon_len);
# 334 "/usr/include/libpurple/buddyicon.h"
PurpleStoredImage *
purple_buddy_icons_node_set_custom_icon_from_file(PurpleBlistNode *node,
                                                  const gchar *filename);
# 346 "/usr/include/libpurple/buddyicon.h"
gboolean
purple_buddy_icons_has_custom_icon(PurpleContact *contact);
# 356 "/usr/include/libpurple/buddyicon.h"
PurpleStoredImage *
purple_buddy_icons_find_custom_icon(PurpleContact *contact);
# 366 "/usr/include/libpurple/buddyicon.h"
PurpleStoredImage *
purple_buddy_icons_set_custom_icon(PurpleContact *contact,
                                   guchar *icon_data, size_t icon_len);
# 377 "/usr/include/libpurple/buddyicon.h"
void purple_buddy_icons_set_caching(gboolean caching);
# 387 "/usr/include/libpurple/buddyicon.h"
gboolean purple_buddy_icons_is_caching(void);






void purple_buddy_icons_set_cache_dir(const char *cache_dir);
# 404 "/usr/include/libpurple/buddyicon.h"
const char *purple_buddy_icons_get_cache_dir(void);






void *purple_buddy_icons_get_handle(void);




void purple_buddy_icons_init(void);




void purple_buddy_icons_uninit(void);
# 433 "/usr/include/libpurple/buddyicon.h"
void purple_buddy_icon_get_scale_size(PurpleBuddyIconSpec *spec, int *width, int *height);
# 111 "/usr/include/libpurple/blist.h" 2
# 124 "/usr/include/libpurple/blist.h"
struct _PurpleBlistNode {
 PurpleBlistNodeType type;
 PurpleBlistNode *prev;
 PurpleBlistNode *next;
 PurpleBlistNode *parent;
 PurpleBlistNode *child;
 GHashTable *settings;
 void *ui_data;
 PurpleBlistNodeFlags flags;
};




struct _PurpleBuddy {
 PurpleBlistNode node;
 char *name;
 char *alias;
 char *server_alias;
 void *proto_data;
 PurpleBuddyIcon *icon;
 PurpleAccount *account;
 PurplePresence *presence;
 PurpleMediaCaps media_caps;
};




struct _PurpleContact {
 PurpleBlistNode node;
 char *alias;
 int totalsize;
 int currentsize;
 int online;
 PurpleBuddy *priority;
 gboolean priority_valid;
};





struct _PurpleGroup {
 PurpleBlistNode node;
 char *name;
 int totalsize;
 int currentsize;
 int online;
};





struct _PurpleChat {
 PurpleBlistNode node;
 char *alias;
 GHashTable *components;
 PurpleAccount *account;
};




struct _PurpleBuddyList {
 PurpleBlistNode *root;
 GHashTable *buddies;
 void *ui_data;
};
# 203 "/usr/include/libpurple/blist.h"
struct _PurpleBlistUiOps
{
 void (*new_list)(PurpleBuddyList *list);
 void (*new_node)(PurpleBlistNode *node);
 void (*show)(PurpleBuddyList *list);
 void (*update)(PurpleBuddyList *list,
         PurpleBlistNode *node);
 void (*remove)(PurpleBuddyList *list,
         PurpleBlistNode *node);
 void (*destroy)(PurpleBuddyList *list);
 void (*set_visible)(PurpleBuddyList *list,
       gboolean show);
 void (*request_add_buddy)(PurpleAccount *account, const char *username,
         const char *group, const char *alias);
 void (*request_add_chat)(PurpleAccount *account, PurpleGroup *group,
        const char *alias, const char *name);
 void (*request_add_group)(void);
# 232 "/usr/include/libpurple/blist.h"
 void (*save_node)(PurpleBlistNode *node);
# 246 "/usr/include/libpurple/blist.h"
 void (*remove_node)(PurpleBlistNode *node);
# 261 "/usr/include/libpurple/blist.h"
 void (*save_account)(PurpleAccount *account);

 void (*_purple_reserved1)(void);
};
# 281 "/usr/include/libpurple/blist.h"
PurpleBuddyList *purple_blist_new(void);







void purple_set_blist(PurpleBuddyList *blist);






PurpleBuddyList *purple_get_blist(void);






PurpleBlistNode *purple_blist_get_root(void);
# 316 "/usr/include/libpurple/blist.h"
GSList *purple_blist_get_buddies(void);
# 325 "/usr/include/libpurple/blist.h"
gpointer purple_blist_get_ui_data(void);
# 334 "/usr/include/libpurple/blist.h"
void purple_blist_set_ui_data(gpointer ui_data);
# 348 "/usr/include/libpurple/blist.h"
PurpleBlistNode *purple_blist_node_next(PurpleBlistNode *node, gboolean offline);
# 361 "/usr/include/libpurple/blist.h"
PurpleBlistNode *purple_blist_node_get_parent(PurpleBlistNode *node);
# 374 "/usr/include/libpurple/blist.h"
PurpleBlistNode *purple_blist_node_get_first_child(PurpleBlistNode *node);
# 387 "/usr/include/libpurple/blist.h"
PurpleBlistNode *purple_blist_node_get_sibling_next(PurpleBlistNode *node);
# 400 "/usr/include/libpurple/blist.h"
PurpleBlistNode *purple_blist_node_get_sibling_prev(PurpleBlistNode *node);
# 409 "/usr/include/libpurple/blist.h"
gpointer purple_blist_node_get_ui_data(const PurpleBlistNode *node);
# 419 "/usr/include/libpurple/blist.h"
void purple_blist_node_set_ui_data(PurpleBlistNode *node, gpointer ui_data);




void purple_blist_show(void);
# 434 "/usr/include/libpurple/blist.h"
void purple_blist_destroy(void);






void purple_blist_set_visible(gboolean show);
# 451 "/usr/include/libpurple/blist.h"
void purple_blist_update_buddy_status(PurpleBuddy *buddy, PurpleStatus *old_status);
# 460 "/usr/include/libpurple/blist.h"
void purple_blist_update_node_icon(PurpleBlistNode *node);
# 469 "/usr/include/libpurple/blist.h"
void purple_blist_update_buddy_icon(PurpleBuddy *buddy);
# 478 "/usr/include/libpurple/blist.h"
void purple_blist_rename_buddy(PurpleBuddy *buddy, const char *name);







void purple_blist_alias_contact(PurpleContact *contact, const char *alias);







void purple_blist_alias_buddy(PurpleBuddy *buddy, const char *alias);
# 503 "/usr/include/libpurple/blist.h"
void purple_blist_server_alias_buddy(PurpleBuddy *buddy, const char *alias);







void purple_blist_alias_chat(PurpleChat *chat, const char *alias);







void purple_blist_rename_group(PurpleGroup *group, const char *name);
# 531 "/usr/include/libpurple/blist.h"
PurpleChat *purple_chat_new(PurpleAccount *account, const char *alias, GHashTable *components);






void purple_chat_destroy(PurpleChat *chat);
# 551 "/usr/include/libpurple/blist.h"
void purple_blist_add_chat(PurpleChat *chat, PurpleGroup *group, PurpleBlistNode *node);
# 568 "/usr/include/libpurple/blist.h"
PurpleBuddy *purple_buddy_new(PurpleAccount *account, const char *name, const char *alias);






void purple_buddy_destroy(PurpleBuddy *buddy);
# 588 "/usr/include/libpurple/blist.h"
void purple_buddy_set_icon(PurpleBuddy *buddy, PurpleBuddyIcon *icon);
# 597 "/usr/include/libpurple/blist.h"
PurpleAccount *purple_buddy_get_account(const PurpleBuddy *buddy);
# 606 "/usr/include/libpurple/blist.h"
const char *purple_buddy_get_name(const PurpleBuddy *buddy);
# 615 "/usr/include/libpurple/blist.h"
PurpleBuddyIcon *purple_buddy_get_icon(const PurpleBuddy *buddy);
# 628 "/usr/include/libpurple/blist.h"
gpointer purple_buddy_get_protocol_data(const PurpleBuddy *buddy);
# 641 "/usr/include/libpurple/blist.h"
void purple_buddy_set_protocol_data(PurpleBuddy *buddy, gpointer data);
# 650 "/usr/include/libpurple/blist.h"
PurpleContact *purple_buddy_get_contact(PurpleBuddy *buddy);
# 659 "/usr/include/libpurple/blist.h"
PurplePresence *purple_buddy_get_presence(const PurpleBuddy *buddy);
# 669 "/usr/include/libpurple/blist.h"
PurpleMediaCaps purple_buddy_get_media_caps(const PurpleBuddy *buddy);







void purple_buddy_set_media_caps(PurpleBuddy *buddy, PurpleMediaCaps media_caps);
# 692 "/usr/include/libpurple/blist.h"
void purple_blist_add_buddy(PurpleBuddy *buddy, PurpleContact *contact, PurpleGroup *group, PurpleBlistNode *node);
# 703 "/usr/include/libpurple/blist.h"
PurpleGroup *purple_group_new(const char *name);






void purple_group_destroy(PurpleGroup *group);
# 721 "/usr/include/libpurple/blist.h"
void purple_blist_add_group(PurpleGroup *group, PurpleBlistNode *node);






PurpleContact *purple_contact_new(void);






void purple_contact_destroy(PurpleContact *contact);
# 745 "/usr/include/libpurple/blist.h"
PurpleGroup *purple_contact_get_group(const PurpleContact *contact);
# 757 "/usr/include/libpurple/blist.h"
void purple_blist_add_contact(PurpleContact *contact, PurpleGroup *group, PurpleBlistNode *node);
# 767 "/usr/include/libpurple/blist.h"
void purple_blist_merge_contact(PurpleContact *source, PurpleBlistNode *node);







PurpleBuddy *purple_contact_get_priority_buddy(PurpleContact *contact);
# 786 "/usr/include/libpurple/blist.h"
void purple_contact_set_alias(PurpleContact *contact, const char *alias);
# 795 "/usr/include/libpurple/blist.h"
const char *purple_contact_get_alias(PurpleContact *contact);
# 805 "/usr/include/libpurple/blist.h"
gboolean purple_contact_on_account(PurpleContact *contact, PurpleAccount *account);







void purple_contact_invalidate_priority_buddy(PurpleContact *contact);
# 823 "/usr/include/libpurple/blist.h"
void purple_blist_remove_buddy(PurpleBuddy *buddy);
# 834 "/usr/include/libpurple/blist.h"
void purple_blist_remove_contact(PurpleContact *contact);






void purple_blist_remove_chat(PurpleChat *chat);







void purple_blist_remove_group(PurpleGroup *group);
# 858 "/usr/include/libpurple/blist.h"
const char *purple_buddy_get_alias_only(PurpleBuddy *buddy);







const char *purple_buddy_get_server_alias(PurpleBuddy *buddy);
# 877 "/usr/include/libpurple/blist.h"
const char *purple_buddy_get_contact_alias(PurpleBuddy *buddy);
# 889 "/usr/include/libpurple/blist.h"
const char *purple_buddy_get_local_alias(PurpleBuddy *buddy);
# 900 "/usr/include/libpurple/blist.h"
const char *purple_buddy_get_alias(PurpleBuddy *buddy);
# 910 "/usr/include/libpurple/blist.h"
const char *purple_buddy_get_local_buddy_alias(PurpleBuddy *buddy);







const char *purple_chat_get_name(PurpleChat *chat);
# 927 "/usr/include/libpurple/blist.h"
PurpleBuddy *purple_find_buddy(PurpleAccount *account, const char *name);
# 937 "/usr/include/libpurple/blist.h"
PurpleBuddy *purple_find_buddy_in_group(PurpleAccount *account, const char *name,
  PurpleGroup *group);
# 948 "/usr/include/libpurple/blist.h"
GSList *purple_find_buddies(PurpleAccount *account, const char *name);
# 957 "/usr/include/libpurple/blist.h"
PurpleGroup *purple_find_group(const char *name);
# 967 "/usr/include/libpurple/blist.h"
PurpleChat *purple_blist_find_chat(PurpleAccount *account, const char *name);
# 976 "/usr/include/libpurple/blist.h"
PurpleGroup *purple_chat_get_group(PurpleChat *chat);
# 987 "/usr/include/libpurple/blist.h"
PurpleAccount *purple_chat_get_account(PurpleChat *chat);
# 998 "/usr/include/libpurple/blist.h"
GHashTable *purple_chat_get_components(PurpleChat *chat);







PurpleGroup *purple_buddy_get_group(PurpleBuddy *buddy);
# 1017 "/usr/include/libpurple/blist.h"
GSList *purple_group_get_accounts(PurpleGroup *g);
# 1027 "/usr/include/libpurple/blist.h"
gboolean purple_group_on_account(PurpleGroup *g, PurpleAccount *account);
# 1036 "/usr/include/libpurple/blist.h"
const char *purple_group_get_name(PurpleGroup *group);







void purple_blist_add_account(PurpleAccount *account);
# 1053 "/usr/include/libpurple/blist.h"
void purple_blist_remove_account(PurpleAccount *account);
# 1063 "/usr/include/libpurple/blist.h"
int purple_blist_get_group_size(PurpleGroup *group, gboolean offline);







int purple_blist_get_group_online_count(PurpleGroup *group);
# 1082 "/usr/include/libpurple/blist.h"
void purple_blist_load(void);
# 1091 "/usr/include/libpurple/blist.h"
void purple_blist_schedule_save(void);
# 1102 "/usr/include/libpurple/blist.h"
void purple_blist_request_add_buddy(PurpleAccount *account, const char *username,
          const char *group, const char *alias);
# 1114 "/usr/include/libpurple/blist.h"
void purple_blist_request_add_chat(PurpleAccount *account, PurpleGroup *group,
         const char *alias, const char *name);





void purple_blist_request_add_group(void);
# 1130 "/usr/include/libpurple/blist.h"
void purple_blist_node_set_bool(PurpleBlistNode *node, const char *key, gboolean value);
# 1140 "/usr/include/libpurple/blist.h"
gboolean purple_blist_node_get_bool(PurpleBlistNode *node, const char *key);
# 1149 "/usr/include/libpurple/blist.h"
void purple_blist_node_set_int(PurpleBlistNode *node, const char *key, int value);
# 1159 "/usr/include/libpurple/blist.h"
int purple_blist_node_get_int(PurpleBlistNode *node, const char *key);
# 1168 "/usr/include/libpurple/blist.h"
void purple_blist_node_set_string(PurpleBlistNode *node, const char *key,
  const char *value);
# 1179 "/usr/include/libpurple/blist.h"
const char *purple_blist_node_get_string(PurpleBlistNode *node, const char *key);







void purple_blist_node_remove_setting(PurpleBlistNode *node, const char *key);
# 1197 "/usr/include/libpurple/blist.h"
void purple_blist_node_set_flags(PurpleBlistNode *node, PurpleBlistNodeFlags flags);
# 1206 "/usr/include/libpurple/blist.h"
PurpleBlistNodeFlags purple_blist_node_get_flags(PurpleBlistNode *node);
# 1217 "/usr/include/libpurple/blist.h"
PurpleBlistNodeType purple_blist_node_get_type(PurpleBlistNode *node);
# 1227 "/usr/include/libpurple/blist.h"
GList *purple_blist_node_get_extended_menu(PurpleBlistNode *n);
# 1239 "/usr/include/libpurple/blist.h"
void purple_blist_set_ui_ops(PurpleBlistUiOps *ops);






PurpleBlistUiOps *purple_blist_get_ui_ops(void);
# 1260 "/usr/include/libpurple/blist.h"
void *purple_blist_get_handle(void);




void purple_blist_init(void);




void purple_blist_uninit(void);
# 134 "/usr/include/libpurple/status.h" 2
# 168 "/usr/include/libpurple/status.h"
const char *purple_primitive_get_id_from_type(PurpleStatusPrimitive type);
# 179 "/usr/include/libpurple/status.h"
const char *purple_primitive_get_name_from_type(PurpleStatusPrimitive type);
# 189 "/usr/include/libpurple/status.h"
PurpleStatusPrimitive purple_primitive_get_type_from_id(const char *id);
# 214 "/usr/include/libpurple/status.h"
PurpleStatusType *purple_status_type_new_full(PurpleStatusPrimitive primitive,
            const char *id, const char *name,
            gboolean saveable,
            gboolean user_settable,
            gboolean independent);
# 233 "/usr/include/libpurple/status.h"
PurpleStatusType *purple_status_type_new(PurpleStatusPrimitive primitive,
          const char *id, const char *name,
          gboolean user_settable);
# 257 "/usr/include/libpurple/status.h"
PurpleStatusType *purple_status_type_new_with_attrs(PurpleStatusPrimitive primitive,
            const char *id,
            const char *name,
            gboolean saveable,
            gboolean user_settable,
            gboolean independent,
            const char *attr_id,
            const char *attr_name,
            PurpleValue *attr_value, ...) __attribute__((__sentinel__));






void purple_status_type_destroy(PurpleStatusType *status_type);
# 287 "/usr/include/libpurple/status.h"
void purple_status_type_set_primary_attr(PurpleStatusType *status_type,
            const char *attr_id);
# 304 "/usr/include/libpurple/status.h"
void purple_status_type_add_attr(PurpleStatusType *status_type, const char *id,
          const char *name, PurpleValue *value);
# 322 "/usr/include/libpurple/status.h"
void purple_status_type_add_attrs(PurpleStatusType *status_type, const char *id,
        const char *name, PurpleValue *value, ...) __attribute__((__sentinel__));
# 337 "/usr/include/libpurple/status.h"
void purple_status_type_add_attrs_vargs(PurpleStatusType *status_type,
           va_list args);
# 348 "/usr/include/libpurple/status.h"
PurpleStatusPrimitive purple_status_type_get_primitive(
 const PurpleStatusType *status_type);
# 358 "/usr/include/libpurple/status.h"
const char *purple_status_type_get_id(const PurpleStatusType *status_type);
# 367 "/usr/include/libpurple/status.h"
const char *purple_status_type_get_name(const PurpleStatusType *status_type);
# 377 "/usr/include/libpurple/status.h"
gboolean purple_status_type_is_saveable(const PurpleStatusType *status_type);
# 388 "/usr/include/libpurple/status.h"
gboolean purple_status_type_is_user_settable(const PurpleStatusType *status_type);
# 400 "/usr/include/libpurple/status.h"
gboolean purple_status_type_is_independent(const PurpleStatusType *status_type);
# 409 "/usr/include/libpurple/status.h"
gboolean purple_status_type_is_exclusive(const PurpleStatusType *status_type);
# 420 "/usr/include/libpurple/status.h"
gboolean purple_status_type_is_available(const PurpleStatusType *status_type);
# 432 "/usr/include/libpurple/status.h"
const char *purple_status_type_get_primary_attr(const PurpleStatusType *type);
# 443 "/usr/include/libpurple/status.h"
PurpleStatusAttr *purple_status_type_get_attr(const PurpleStatusType *status_type,
            const char *id);
# 453 "/usr/include/libpurple/status.h"
GList *purple_status_type_get_attrs(const PurpleStatusType *status_type);
# 464 "/usr/include/libpurple/status.h"
const PurpleStatusType *purple_status_type_find_with_id(GList *status_types,
             const char *id);
# 483 "/usr/include/libpurple/status.h"
PurpleStatusAttr *purple_status_attr_new(const char *id, const char *name,
          PurpleValue *value_type);






void purple_status_attr_destroy(PurpleStatusAttr *attr);
# 500 "/usr/include/libpurple/status.h"
const char *purple_status_attr_get_id(const PurpleStatusAttr *attr);
# 509 "/usr/include/libpurple/status.h"
const char *purple_status_attr_get_name(const PurpleStatusAttr *attr);
# 518 "/usr/include/libpurple/status.h"
PurpleValue *purple_status_attr_get_value(const PurpleStatusAttr *attr);
# 535 "/usr/include/libpurple/status.h"
PurpleStatus *purple_status_new(PurpleStatusType *status_type,
       PurplePresence *presence);






void purple_status_destroy(PurpleStatus *status);
# 553 "/usr/include/libpurple/status.h"
void purple_status_set_active(PurpleStatus *status, gboolean active);
# 567 "/usr/include/libpurple/status.h"
void purple_status_set_active_with_attrs(PurpleStatus *status, gboolean active,
            va_list args);
# 582 "/usr/include/libpurple/status.h"
void purple_status_set_active_with_attrs_list(PurpleStatus *status, gboolean active,
           GList *attrs);
# 596 "/usr/include/libpurple/status.h"
void purple_status_set_attr_boolean(PurpleStatus *status, const char *id,
          gboolean value);
# 611 "/usr/include/libpurple/status.h"
void purple_status_set_attr_int(PurpleStatus *status, const char *id,
         int value);
# 626 "/usr/include/libpurple/status.h"
void purple_status_set_attr_string(PurpleStatus *status, const char *id,
         const char *value);
# 637 "/usr/include/libpurple/status.h"
PurpleStatusType *purple_status_get_type(const PurpleStatus *status);
# 646 "/usr/include/libpurple/status.h"
PurplePresence *purple_status_get_presence(const PurpleStatus *status);
# 658 "/usr/include/libpurple/status.h"
const char *purple_status_get_id(const PurpleStatus *status);
# 670 "/usr/include/libpurple/status.h"
const char *purple_status_get_name(const PurpleStatus *status);
# 682 "/usr/include/libpurple/status.h"
gboolean purple_status_is_independent(const PurpleStatus *status);
# 694 "/usr/include/libpurple/status.h"
gboolean purple_status_is_exclusive(const PurpleStatus *status);
# 708 "/usr/include/libpurple/status.h"
gboolean purple_status_is_available(const PurpleStatus *status);
# 717 "/usr/include/libpurple/status.h"
gboolean purple_status_is_active(const PurpleStatus *status);
# 726 "/usr/include/libpurple/status.h"
gboolean purple_status_is_online(const PurpleStatus *status);
# 736 "/usr/include/libpurple/status.h"
PurpleValue *purple_status_get_attr_value(const PurpleStatus *status,
           const char *id);
# 747 "/usr/include/libpurple/status.h"
gboolean purple_status_get_attr_boolean(const PurpleStatus *status,
           const char *id);
# 758 "/usr/include/libpurple/status.h"
int purple_status_get_attr_int(const PurpleStatus *status, const char *id);
# 768 "/usr/include/libpurple/status.h"
const char *purple_status_get_attr_string(const PurpleStatus *status,
          const char *id);
# 781 "/usr/include/libpurple/status.h"
gint purple_status_compare(const PurpleStatus *status1, const PurpleStatus *status2);
# 797 "/usr/include/libpurple/status.h"
PurplePresence *purple_presence_new(PurplePresenceContext context);
# 806 "/usr/include/libpurple/status.h"
PurplePresence *purple_presence_new_for_account(PurpleAccount *account);
# 815 "/usr/include/libpurple/status.h"
PurplePresence *purple_presence_new_for_conv(PurpleConversation *conv);
# 824 "/usr/include/libpurple/status.h"
PurplePresence *purple_presence_new_for_buddy(PurpleBuddy *buddy);
# 834 "/usr/include/libpurple/status.h"
void purple_presence_destroy(PurplePresence *presence);
# 846 "/usr/include/libpurple/status.h"
void purple_presence_add_status(PurplePresence *presence, PurpleStatus *status);
# 859 "/usr/include/libpurple/status.h"
void purple_presence_add_list(PurplePresence *presence, GList *source_list);
# 873 "/usr/include/libpurple/status.h"
void purple_presence_set_status_active(PurplePresence *presence,
          const char *status_id, gboolean active);
# 885 "/usr/include/libpurple/status.h"
void purple_presence_switch_status(PurplePresence *presence,
         const char *status_id);
# 898 "/usr/include/libpurple/status.h"
void purple_presence_set_idle(PurplePresence *presence, gboolean idle,
       time_t idle_time);







void purple_presence_set_login_time(PurplePresence *presence, time_t login_time);
# 917 "/usr/include/libpurple/status.h"
PurplePresenceContext purple_presence_get_context(const PurplePresence *presence);
# 926 "/usr/include/libpurple/status.h"
PurpleAccount *purple_presence_get_account(const PurplePresence *presence);
# 935 "/usr/include/libpurple/status.h"
PurpleConversation *purple_presence_get_conversation(const PurplePresence *presence);
# 944 "/usr/include/libpurple/status.h"
const char *purple_presence_get_chat_user(const PurplePresence *presence);
# 953 "/usr/include/libpurple/status.h"
PurpleBuddy *purple_presence_get_buddy(const PurplePresence *presence);
# 962 "/usr/include/libpurple/status.h"
GList *purple_presence_get_statuses(const PurplePresence *presence);
# 972 "/usr/include/libpurple/status.h"
PurpleStatus *purple_presence_get_status(const PurplePresence *presence,
          const char *status_id);
# 982 "/usr/include/libpurple/status.h"
PurpleStatus *purple_presence_get_active_status(const PurplePresence *presence);
# 993 "/usr/include/libpurple/status.h"
gboolean purple_presence_is_available(const PurplePresence *presence);
# 1002 "/usr/include/libpurple/status.h"
gboolean purple_presence_is_online(const PurplePresence *presence);
# 1014 "/usr/include/libpurple/status.h"
gboolean purple_presence_is_status_active(const PurplePresence *presence,
          const char *status_id);
# 1028 "/usr/include/libpurple/status.h"
gboolean purple_presence_is_status_primitive_active(
 const PurplePresence *presence, PurpleStatusPrimitive primitive);
# 1040 "/usr/include/libpurple/status.h"
gboolean purple_presence_is_idle(const PurplePresence *presence);
# 1049 "/usr/include/libpurple/status.h"
time_t purple_presence_get_idle_time(const PurplePresence *presence);
# 1058 "/usr/include/libpurple/status.h"
time_t purple_presence_get_login_time(const PurplePresence *presence);
# 1070 "/usr/include/libpurple/status.h"
gint purple_presence_compare(const PurplePresence *presence1,
         const PurplePresence *presence2);
# 1085 "/usr/include/libpurple/status.h"
void *purple_status_get_handle(void);




void purple_status_init(void);




void purple_status_uninit(void);
# 152 "/usr/include/libpurple/connection.h" 2
# 1 "/usr/include/libpurple/sslconn.h" 1
# 30 "/usr/include/libpurple/sslconn.h"
typedef enum
{
 PURPLE_SSL_HANDSHAKE_FAILED = 1,
 PURPLE_SSL_CONNECT_FAILED = 2,
 PURPLE_SSL_CERTIFICATE_INVALID = 3
} PurpleSslErrorType;

# 1 "/usr/include/libpurple/certificate.h" 1
# 43 "/usr/include/libpurple/certificate.h"
typedef enum
{
 PURPLE_CERTIFICATE_INVALID = 0,
 PURPLE_CERTIFICATE_VALID = 1
} PurpleCertificateVerificationStatus;

typedef struct _PurpleCertificate PurpleCertificate;
typedef struct _PurpleCertificatePool PurpleCertificatePool;
typedef struct _PurpleCertificateScheme PurpleCertificateScheme;
typedef struct _PurpleCertificateVerifier PurpleCertificateVerifier;
typedef struct _PurpleCertificateVerificationRequest PurpleCertificateVerificationRequest;






typedef void (*PurpleCertificateVerifiedCallback)
  (PurpleCertificateVerificationStatus st,
   gpointer userdata);






struct _PurpleCertificate
{

 PurpleCertificateScheme * scheme;

 gpointer data;
};







struct _PurpleCertificatePool
{

 gchar *scheme_name;

 gchar *name;






 gchar *fullname;


 gpointer data;
# 107 "/usr/include/libpurple/certificate.h"
 gboolean (* init)(void);






 void (* uninit)(void);


 gboolean (* cert_in_pool)(const gchar *id);

 PurpleCertificate * (* get_cert)(const gchar *id);




 gboolean (* put_cert)(const gchar *id, PurpleCertificate *crt);

 gboolean (* delete_cert)(const gchar *id);


 GList * (* get_idlist)(void);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};
# 145 "/usr/include/libpurple/certificate.h"
struct _PurpleCertificateScheme
{





 gchar * name;






 gchar * fullname;







 PurpleCertificate * (* import_certificate)(const gchar * filename);
# 177 "/usr/include/libpurple/certificate.h"
 gboolean (* export_certificate)(const gchar *filename, PurpleCertificate *crt);
# 187 "/usr/include/libpurple/certificate.h"
 PurpleCertificate * (* copy_certificate)(PurpleCertificate *crt);
# 198 "/usr/include/libpurple/certificate.h"
 void (* destroy_certificate)(PurpleCertificate * crt);



 gboolean (*signed_by)(PurpleCertificate *crt, PurpleCertificate *issuer);







 GByteArray * (* get_fingerprint_sha1)(PurpleCertificate *crt);
# 219 "/usr/include/libpurple/certificate.h"
 gchar * (* get_unique_id)(PurpleCertificate *crt);
# 228 "/usr/include/libpurple/certificate.h"
 gchar * (* get_issuer_unique_id)(PurpleCertificate *crt);
# 241 "/usr/include/libpurple/certificate.h"
 gchar * (* get_subject_name)(PurpleCertificate *crt);






 gboolean (* check_subject_name)(PurpleCertificate *crt, const gchar *name);


 gboolean (* get_times)(PurpleCertificate *crt, time_t *activation, time_t *expiration);







 GSList * (* import_certificates)(const gchar * filename);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
};
# 275 "/usr/include/libpurple/certificate.h"
struct _PurpleCertificateVerifier
{





 gchar *scheme_name;


 gchar *name;
# 297 "/usr/include/libpurple/certificate.h"
 void (* start_verification)(PurpleCertificateVerificationRequest *vrq);
# 307 "/usr/include/libpurple/certificate.h"
 void (* destroy_request)(PurpleCertificateVerificationRequest *vrq);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};






struct _PurpleCertificateVerificationRequest
{

 PurpleCertificateVerifier *verifier;




 PurpleCertificateScheme *scheme;






 gchar *subject_name;






 GList *cert_chain;


 gpointer data;


 PurpleCertificateVerifiedCallback cb;

 gpointer cb_data;
};
# 381 "/usr/include/libpurple/certificate.h"
void
purple_certificate_verify (PurpleCertificateVerifier *verifier,
      const gchar *subject_name, GList *cert_chain,
      PurpleCertificateVerifiedCallback cb,
      gpointer cb_data);
# 394 "/usr/include/libpurple/certificate.h"
void
purple_certificate_verify_complete(PurpleCertificateVerificationRequest *vrq,
       PurpleCertificateVerificationStatus st);
# 411 "/usr/include/libpurple/certificate.h"
PurpleCertificate *
purple_certificate_copy(PurpleCertificate *crt);







GList *
purple_certificate_copy_list(GList *crt_list);






void
purple_certificate_destroy (PurpleCertificate *crt);






void
purple_certificate_destroy_list (GList * crt_list);
# 449 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_signed_by(PurpleCertificate *crt, PurpleCertificate *issuer);
# 470 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_check_signature_chain_with_failing(GList *chain,
  PurpleCertificate **failing);
# 488 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_check_signature_chain(GList *chain);
# 498 "/usr/include/libpurple/certificate.h"
PurpleCertificate *
purple_certificate_import(PurpleCertificateScheme *scheme, const gchar *filename);
# 508 "/usr/include/libpurple/certificate.h"
GSList *
purple_certificates_import(PurpleCertificateScheme *scheme, const gchar *filename);
# 518 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_export(const gchar *filename, PurpleCertificate *crt);
# 530 "/usr/include/libpurple/certificate.h"
GByteArray *
purple_certificate_get_fingerprint_sha1(PurpleCertificate *crt);







gchar *
purple_certificate_get_unique_id(PurpleCertificate *crt);
# 549 "/usr/include/libpurple/certificate.h"
gchar *
purple_certificate_get_issuer_unique_id(PurpleCertificate *crt);
# 561 "/usr/include/libpurple/certificate.h"
gchar *
purple_certificate_get_subject_name(PurpleCertificate *crt);







gboolean
purple_certificate_check_subject_name(PurpleCertificate *crt, const gchar *name);
# 583 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_get_times(PurpleCertificate *crt, time_t *activation, time_t *expiration);
# 603 "/usr/include/libpurple/certificate.h"
gchar *
purple_certificate_pool_mkpath(PurpleCertificatePool *pool, const gchar *id);
# 615 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_pool_usable(PurpleCertificatePool *pool);
# 626 "/usr/include/libpurple/certificate.h"
PurpleCertificateScheme *
purple_certificate_pool_get_scheme(PurpleCertificatePool *pool);







gboolean
purple_certificate_pool_contains(PurpleCertificatePool *pool, const gchar *id);







PurpleCertificate *
purple_certificate_pool_retrieve(PurpleCertificatePool *pool, const gchar *id);
# 657 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_pool_store(PurpleCertificatePool *pool, const gchar *id, PurpleCertificate *crt);
# 667 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_pool_delete(PurpleCertificatePool *pool, const gchar *id);
# 677 "/usr/include/libpurple/certificate.h"
GList *
purple_certificate_pool_get_idlist(PurpleCertificatePool *pool);






void
purple_certificate_pool_destroy_idlist(GList *idlist);
# 698 "/usr/include/libpurple/certificate.h"
void
purple_certificate_init(void);




void
purple_certificate_uninit(void);




gpointer
purple_certificate_get_handle(void);





PurpleCertificateScheme *
purple_certificate_find_scheme(const gchar *name);







GList *
purple_certificate_get_schemes(void);
# 737 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_register_scheme(PurpleCertificateScheme *scheme);
# 747 "/usr/include/libpurple/certificate.h"
gboolean
purple_certificate_unregister_scheme(PurpleCertificateScheme *scheme);






PurpleCertificateVerifier *
purple_certificate_find_verifier(const gchar *scheme_name, const gchar *ver_name);







GList *
purple_certificate_get_verifiers(void);







gboolean
purple_certificate_register_verifier(PurpleCertificateVerifier *vr);







gboolean
purple_certificate_unregister_verifier(PurpleCertificateVerifier *vr);






PurpleCertificatePool *
purple_certificate_find_pool(const gchar *scheme_name, const gchar *pool_name);







GList *
purple_certificate_get_pools(void);







gboolean
purple_certificate_register_pool(PurpleCertificatePool *pool);







gboolean
purple_certificate_unregister_pool(PurpleCertificatePool *pool);
# 829 "/usr/include/libpurple/certificate.h"
void
purple_certificate_display_x509(PurpleCertificate *crt);






void purple_certificate_add_ca_search_path(const char *path);
# 38 "/usr/include/libpurple/sslconn.h" 2





typedef struct _PurpleSslConnection PurpleSslConnection;

typedef void (*PurpleSslInputFunction)(gpointer, PurpleSslConnection *,
          PurpleInputCondition);
typedef void (*PurpleSslErrorFunction)(PurpleSslConnection *, PurpleSslErrorType,
          gpointer);

struct _PurpleSslConnection
{

 char *host;

 int port;

 void *connect_cb_data;

 PurpleSslInputFunction connect_cb;

 PurpleSslErrorFunction error_cb;

 void *recv_cb_data;

 PurpleSslInputFunction recv_cb;


 int fd;


 guint inpa;

 PurpleProxyConnectData *connect_data;


 void *private_data;


 PurpleCertificateVerifier *verifier;
};







typedef struct
{




 gboolean (*init)(void);



 void (*uninit)(void);




 void (*connectfunc)(PurpleSslConnection *gsc);




 void (*close)(PurpleSslConnection *gsc);
# 117 "/usr/include/libpurple/sslconn.h"
 size_t (*read)(PurpleSslConnection *gsc, void *data, size_t len);
# 126 "/usr/include/libpurple/sslconn.h"
 size_t (*write)(PurpleSslConnection *gsc, const void *data, size_t len);
# 136 "/usr/include/libpurple/sslconn.h"
 GList * (* get_peer_certificates)(PurpleSslConnection * gsc);

 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
} PurpleSslOps;
# 157 "/usr/include/libpurple/sslconn.h"
gboolean purple_ssl_is_supported(void);







const gchar * purple_ssl_strerror(PurpleSslErrorType error);
# 184 "/usr/include/libpurple/sslconn.h"
PurpleSslConnection *purple_ssl_connect(PurpleAccount *account, const char *host,
         int port, PurpleSslInputFunction func,
         PurpleSslErrorFunction error_func,
         void *data);
# 208 "/usr/include/libpurple/sslconn.h"
PurpleSslConnection *purple_ssl_connect_with_ssl_cn(PurpleAccount *account, const char *host,
         int port, PurpleSslInputFunction func,
         PurpleSslErrorFunction error_func,
         const char *ssl_host,
         void *data);
# 228 "/usr/include/libpurple/sslconn.h"
PurpleSslConnection *purple_ssl_connect_fd(PurpleAccount *account, int fd,
            PurpleSslInputFunction func,
            PurpleSslErrorFunction error_func,
             void *data);
# 248 "/usr/include/libpurple/sslconn.h"
PurpleSslConnection *purple_ssl_connect_with_host_fd(PurpleAccount *account, int fd,
                                           PurpleSslInputFunction func,
                                           PurpleSslErrorFunction error_func,
                                           const char *host,
                                           void *data);
# 262 "/usr/include/libpurple/sslconn.h"
void purple_ssl_input_add(PurpleSslConnection *gsc, PurpleSslInputFunction func,
      void *data);






void purple_ssl_close(PurpleSslConnection *gsc);
# 281 "/usr/include/libpurple/sslconn.h"
size_t purple_ssl_read(PurpleSslConnection *gsc, void *buffer, size_t len);
# 292 "/usr/include/libpurple/sslconn.h"
size_t purple_ssl_write(PurpleSslConnection *gsc, const void *buffer, size_t len);
# 304 "/usr/include/libpurple/sslconn.h"
GList * purple_ssl_get_peer_certificates(PurpleSslConnection *gsc);
# 318 "/usr/include/libpurple/sslconn.h"
void purple_ssl_set_ops(PurpleSslOps *ops);






PurpleSslOps *purple_ssl_get_ops(void);




void purple_ssl_init(void);




void purple_ssl_uninit(void);
# 153 "/usr/include/libpurple/connection.h" 2
# 162 "/usr/include/libpurple/connection.h"
typedef struct
{







 void (*connect_progress)(PurpleConnection *gc,
                          const char *text,
                          size_t step,
                          size_t step_count);





 void (*connected)(PurpleConnection *gc);





 void (*disconnected)(PurpleConnection *gc);







 void (*notice)(PurpleConnection *gc, const char *text);
# 204 "/usr/include/libpurple/connection.h"
 void (*report_disconnect)(PurpleConnection *gc, const char *text);







 void (*network_connected)(void);





 void (*network_disconnected)(void);
# 234 "/usr/include/libpurple/connection.h"
 void (*report_disconnect_reason)(PurpleConnection *gc,
                                  PurpleConnectionError reason,
                                  const char *text);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
} PurpleConnectionUiOps;



struct _PurpleConnection
{
 PurplePlugin *prpl;
 PurpleConnectionFlags flags;

 PurpleConnectionState state;

 PurpleAccount *account;
 char *password;
 int inpa;

 GSList *buddy_chats;


 void *proto_data;

 char *display_name;
 guint keepalive;
# 271 "/usr/include/libpurple/connection.h"
 gboolean wants_to_die;

 guint disconnect_timeout;
 time_t last_received;

};
# 307 "/usr/include/libpurple/connection.h"
void purple_connection_new(PurpleAccount *account, gboolean regist,
         const char *password);
# 326 "/usr/include/libpurple/connection.h"
void purple_connection_new_unregister(PurpleAccount *account, const char *password, PurpleAccountUnregistrationCb cb, void *user_data);
# 341 "/usr/include/libpurple/connection.h"
void purple_connection_destroy(PurpleConnection *gc);
# 354 "/usr/include/libpurple/connection.h"
void purple_connection_set_state(PurpleConnection *gc, PurpleConnectionState state);







void purple_connection_set_account(PurpleConnection *gc, PurpleAccount *account);







void purple_connection_set_display_name(PurpleConnection *gc, const char *name);
# 380 "/usr/include/libpurple/connection.h"
void purple_connection_set_protocol_data(PurpleConnection *connection, void *proto_data);
# 389 "/usr/include/libpurple/connection.h"
PurpleConnectionState purple_connection_get_state(const PurpleConnection *gc);
# 406 "/usr/include/libpurple/connection.h"
PurpleAccount *purple_connection_get_account(const PurpleConnection *gc);
# 417 "/usr/include/libpurple/connection.h"
PurplePlugin * purple_connection_get_prpl(const PurpleConnection *gc);
# 426 "/usr/include/libpurple/connection.h"
const char *purple_connection_get_password(const PurpleConnection *gc);
# 435 "/usr/include/libpurple/connection.h"
const char *purple_connection_get_display_name(const PurpleConnection *gc);
# 446 "/usr/include/libpurple/connection.h"
void *purple_connection_get_protocol_data(const PurpleConnection *connection);
# 456 "/usr/include/libpurple/connection.h"
void purple_connection_update_progress(PurpleConnection *gc, const char *text,
          size_t step, size_t count);







void purple_connection_notice(PurpleConnection *gc, const char *text);
# 480 "/usr/include/libpurple/connection.h"
void purple_connection_error(PurpleConnection *gc, const char *reason);
# 494 "/usr/include/libpurple/connection.h"
void
purple_connection_error_reason (PurpleConnection *gc,
                                PurpleConnectionError reason,
                                const char *description);
# 506 "/usr/include/libpurple/connection.h"
void
purple_connection_ssl_error (PurpleConnection *gc,
                             PurpleSslErrorType ssl_error);
# 530 "/usr/include/libpurple/connection.h"
gboolean
purple_connection_error_is_fatal (PurpleConnectionError reason);
# 543 "/usr/include/libpurple/connection.h"
void purple_connections_disconnect_all(void);







GList *purple_connections_get_all(void);






GList *purple_connections_get_connecting(void);
# 586 "/usr/include/libpurple/connection.h"
void purple_connections_set_ui_ops(PurpleConnectionUiOps *ops);






PurpleConnectionUiOps *purple_connections_get_ui_ops(void);
# 605 "/usr/include/libpurple/connection.h"
void purple_connections_init(void);




void purple_connections_uninit(void);






void *purple_connections_get_handle(void);
# 48 "/usr/include/libpurple/account.h" 2

# 1 "/usr/include/libpurple/privacy.h" 1
# 32 "/usr/include/libpurple/privacy.h"
typedef enum _PurplePrivacyType
{
 PURPLE_PRIVACY_ALLOW_ALL = 1,
 PURPLE_PRIVACY_DENY_ALL,
 PURPLE_PRIVACY_ALLOW_USERS,
 PURPLE_PRIVACY_DENY_USERS,
 PURPLE_PRIVACY_ALLOW_BUDDYLIST
} PurplePrivacyType;
# 50 "/usr/include/libpurple/privacy.h"
typedef struct
{
 void (*permit_added)(PurpleAccount *account, const char *name);
 void (*permit_removed)(PurpleAccount *account, const char *name);
 void (*deny_added)(PurpleAccount *account, const char *name);
 void (*deny_removed)(PurpleAccount *account, const char *name);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
} PurplePrivacyUiOps;
# 73 "/usr/include/libpurple/privacy.h"
gboolean purple_privacy_permit_add(PurpleAccount *account, const char *name,
         gboolean local_only);
# 86 "/usr/include/libpurple/privacy.h"
gboolean purple_privacy_permit_remove(PurpleAccount *account, const char *name,
         gboolean local_only);
# 99 "/usr/include/libpurple/privacy.h"
gboolean purple_privacy_deny_add(PurpleAccount *account, const char *name,
          gboolean local_only);
# 112 "/usr/include/libpurple/privacy.h"
gboolean purple_privacy_deny_remove(PurpleAccount *account, const char *name,
          gboolean local_only);
# 135 "/usr/include/libpurple/privacy.h"
void purple_privacy_allow(PurpleAccount *account, const char *who, gboolean local,
      gboolean restore);
# 158 "/usr/include/libpurple/privacy.h"
void purple_privacy_deny(PurpleAccount *account, const char *who, gboolean local,
      gboolean restore);
# 169 "/usr/include/libpurple/privacy.h"
gboolean purple_privacy_check(PurpleAccount *account, const char *who);






void purple_privacy_set_ui_ops(PurplePrivacyUiOps *ops);






PurplePrivacyUiOps *purple_privacy_get_ui_ops(void);




void purple_privacy_init(void);
# 50 "/usr/include/libpurple/account.h" 2







typedef enum
{
 PURPLE_ACCOUNT_REQUEST_AUTHORIZATION = 0
} PurpleAccountRequestType;




typedef enum
{
 PURPLE_ACCOUNT_RESPONSE_IGNORE = -2,
 PURPLE_ACCOUNT_RESPONSE_DENY = -1,
 PURPLE_ACCOUNT_RESPONSE_PASS = 0,
 PURPLE_ACCOUNT_RESPONSE_ACCEPT = 1
} PurpleAccountRequestResponse;




struct _PurpleAccountUiOps
{



 void (*notify_added)(PurpleAccount *account,
                      const char *remote_user,
                      const char *id,
                      const char *alias,
                      const char *message);


 void (*status_changed)(PurpleAccount *account,
                        PurpleStatus *status);


 void (*request_add)(PurpleAccount *account,
                     const char *remote_user,
                     const char *id,
                     const char *alias,
                     const char *message);






 void *(*request_authorize)(PurpleAccount *account,
                            const char *remote_user,
                            const char *id,
                            const char *alias,
                            const char *message,
                            gboolean on_list,
                            PurpleAccountRequestAuthorizationCb authorize_cb,
                            PurpleAccountRequestAuthorizationCb deny_cb,
                            void *user_data);




 void (*close_account_request)(void *ui_handle);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
};



struct _PurpleAccount
{
 char *username;
 char *alias;
 char *password;
 char *user_info;

 char *buddy_icon_path;

 gboolean remember_pass;

 char *protocol_id;

 PurpleConnection *gc;
 gboolean disconnecting;

 GHashTable *settings;
 GHashTable *ui_settings;

 PurpleProxyInfo *proxy_info;
# 158 "/usr/include/libpurple/account.h"
 GSList *permit;
 GSList *deny;
 PurplePrivacyType perm_deny;

 GList *status_types;

 PurplePresence *presence;
 PurpleLog *system_log;

 void *ui_data;
 PurpleAccountRegistrationCb registration_cb;
 void *registration_cb_user_data;

 gpointer priv;
};
# 191 "/usr/include/libpurple/account.h"
PurpleAccount *purple_account_new(const char *username, const char *protocol_id);






void purple_account_destroy(PurpleAccount *account);






void purple_account_connect(PurpleAccount *account);
# 214 "/usr/include/libpurple/account.h"
void purple_account_set_register_callback(PurpleAccount *account, PurpleAccountRegistrationCb cb, void *user_data);






void purple_account_register(PurpleAccount *account);
# 230 "/usr/include/libpurple/account.h"
void purple_account_unregister(PurpleAccount *account, PurpleAccountUnregistrationCb cb, void *user_data);






void purple_account_disconnect(PurpleAccount *account);
# 252 "/usr/include/libpurple/account.h"
void purple_account_notify_added(PurpleAccount *account, const char *remote_user,
                               const char *id, const char *alias,
                               const char *message);
# 271 "/usr/include/libpurple/account.h"
void purple_account_request_add(PurpleAccount *account, const char *remote_user,
                              const char *id, const char *alias,
                              const char *message);
# 294 "/usr/include/libpurple/account.h"
void *purple_account_request_authorization(PurpleAccount *account, const char *remote_user,
     const char *id, const char *alias, const char *message, gboolean on_list,
     PurpleAccountRequestAuthorizationCb auth_cb, PurpleAccountRequestAuthorizationCb deny_cb, void *user_data);






void purple_account_request_close_with_account(PurpleAccount *account);






void purple_account_request_close(void *ui_handle);
# 321 "/usr/include/libpurple/account.h"
void purple_account_request_password(PurpleAccount *account, GCallback ok_cb,
         GCallback cancel_cb, void *user_data);






void purple_account_request_change_password(PurpleAccount *account);







void purple_account_request_change_user_info(PurpleAccount *account);







void purple_account_set_username(PurpleAccount *account, const char *username);







void purple_account_set_password(PurpleAccount *account, const char *password);







void purple_account_set_alias(PurpleAccount *account, const char *alias);







void purple_account_set_user_info(PurpleAccount *account, const char *user_info);







void purple_account_set_buddy_icon_path(PurpleAccount *account, const char *path);







void purple_account_set_protocol_id(PurpleAccount *account,
          const char *protocol_id);







void purple_account_set_connection(PurpleAccount *account, PurpleConnection *gc);







void purple_account_set_remember_password(PurpleAccount *account, gboolean value);







void purple_account_set_check_mail(PurpleAccount *account, gboolean value);
# 420 "/usr/include/libpurple/account.h"
void purple_account_set_enabled(PurpleAccount *account, const char *ui,
         gboolean value);







void purple_account_set_proxy_info(PurpleAccount *account, PurpleProxyInfo *info);
# 439 "/usr/include/libpurple/account.h"
void purple_account_set_privacy_type(PurpleAccount *account, PurplePrivacyType privacy_type);







void purple_account_set_status_types(PurpleAccount *account, GList *status_types);







void purple_account_set_status(PurpleAccount *account, const char *status_id,
 gboolean active, ...) __attribute__((__sentinel__));
# 476 "/usr/include/libpurple/account.h"
void purple_account_set_status_list(PurpleAccount *account,
 const char *status_id, gboolean active, GList *attrs);
# 497 "/usr/include/libpurple/account.h"
void purple_account_set_public_alias(PurpleAccount *account,
 const char *alias, PurpleSetPublicAliasSuccessCallback success_cb,
 PurpleSetPublicAliasFailureCallback failure_cb);
# 511 "/usr/include/libpurple/account.h"
void purple_account_get_public_alias(PurpleAccount *account,
 PurpleGetPublicAliasSuccessCallback success_cb,
 PurpleGetPublicAliasFailureCallback failure_cb);
# 522 "/usr/include/libpurple/account.h"
gboolean purple_account_get_silence_suppression(const PurpleAccount *account);







void purple_account_set_silence_suppression(PurpleAccount *account,
           gboolean value);






void purple_account_clear_settings(PurpleAccount *account);
# 548 "/usr/include/libpurple/account.h"
void purple_account_remove_setting(PurpleAccount *account, const char *setting);
# 557 "/usr/include/libpurple/account.h"
void purple_account_set_int(PurpleAccount *account, const char *name, int value);
# 566 "/usr/include/libpurple/account.h"
void purple_account_set_string(PurpleAccount *account, const char *name,
        const char *value);
# 576 "/usr/include/libpurple/account.h"
void purple_account_set_bool(PurpleAccount *account, const char *name,
         gboolean value);
# 587 "/usr/include/libpurple/account.h"
void purple_account_set_ui_int(PurpleAccount *account, const char *ui,
        const char *name, int value);
# 598 "/usr/include/libpurple/account.h"
void purple_account_set_ui_string(PurpleAccount *account, const char *ui,
        const char *name, const char *value);
# 609 "/usr/include/libpurple/account.h"
void purple_account_set_ui_bool(PurpleAccount *account, const char *ui,
         const char *name, gboolean value);
# 619 "/usr/include/libpurple/account.h"
gboolean purple_account_is_connected(const PurpleAccount *account);
# 628 "/usr/include/libpurple/account.h"
gboolean purple_account_is_connecting(const PurpleAccount *account);
# 637 "/usr/include/libpurple/account.h"
gboolean purple_account_is_disconnected(const PurpleAccount *account);
# 646 "/usr/include/libpurple/account.h"
const char *purple_account_get_username(const PurpleAccount *account);
# 655 "/usr/include/libpurple/account.h"
const char *purple_account_get_password(const PurpleAccount *account);
# 664 "/usr/include/libpurple/account.h"
const char *purple_account_get_alias(const PurpleAccount *account);
# 673 "/usr/include/libpurple/account.h"
const char *purple_account_get_user_info(const PurpleAccount *account);
# 682 "/usr/include/libpurple/account.h"
const char *purple_account_get_buddy_icon_path(const PurpleAccount *account);
# 691 "/usr/include/libpurple/account.h"
const char *purple_account_get_protocol_id(const PurpleAccount *account);
# 700 "/usr/include/libpurple/account.h"
const char *purple_account_get_protocol_name(const PurpleAccount *account);
# 709 "/usr/include/libpurple/account.h"
PurpleConnection *purple_account_get_connection(const PurpleAccount *account);
# 723 "/usr/include/libpurple/account.h"
const gchar *purple_account_get_name_for_display(const PurpleAccount *account);
# 732 "/usr/include/libpurple/account.h"
gboolean purple_account_get_remember_password(const PurpleAccount *account);
# 741 "/usr/include/libpurple/account.h"
gboolean purple_account_get_check_mail(const PurpleAccount *account);
# 752 "/usr/include/libpurple/account.h"
gboolean purple_account_get_enabled(const PurpleAccount *account,
      const char *ui);
# 762 "/usr/include/libpurple/account.h"
PurpleProxyInfo *purple_account_get_proxy_info(const PurpleAccount *account);
# 773 "/usr/include/libpurple/account.h"
PurplePrivacyType purple_account_get_privacy_type(const PurpleAccount *account);
# 785 "/usr/include/libpurple/account.h"
PurpleStatus *purple_account_get_active_status(const PurpleAccount *account);
# 798 "/usr/include/libpurple/account.h"
PurpleStatus *purple_account_get_status(const PurpleAccount *account,
         const char *status_id);
# 809 "/usr/include/libpurple/account.h"
PurpleStatusType *purple_account_get_status_type(const PurpleAccount *account,
            const char *id);
# 823 "/usr/include/libpurple/account.h"
PurpleStatusType *purple_account_get_status_type_with_primitive(
       const PurpleAccount *account,
       PurpleStatusPrimitive primitive);
# 834 "/usr/include/libpurple/account.h"
PurplePresence *purple_account_get_presence(const PurpleAccount *account);
# 844 "/usr/include/libpurple/account.h"
gboolean purple_account_is_status_active(const PurpleAccount *account,
            const char *status_id);
# 854 "/usr/include/libpurple/account.h"
GList *purple_account_get_status_types(const PurpleAccount *account);
# 865 "/usr/include/libpurple/account.h"
int purple_account_get_int(const PurpleAccount *account, const char *name,
       int default_value);
# 877 "/usr/include/libpurple/account.h"
const char *purple_account_get_string(const PurpleAccount *account,
         const char *name,
         const char *default_value);
# 890 "/usr/include/libpurple/account.h"
gboolean purple_account_get_bool(const PurpleAccount *account, const char *name,
          gboolean default_value);
# 903 "/usr/include/libpurple/account.h"
int purple_account_get_ui_int(const PurpleAccount *account, const char *ui,
       const char *name, int default_value);
# 916 "/usr/include/libpurple/account.h"
const char *purple_account_get_ui_string(const PurpleAccount *account,
            const char *ui, const char *name,
            const char *default_value);
# 930 "/usr/include/libpurple/account.h"
gboolean purple_account_get_ui_bool(const PurpleAccount *account, const char *ui,
          const char *name, gboolean default_value);
# 947 "/usr/include/libpurple/account.h"
PurpleLog *purple_account_get_log(PurpleAccount *account, gboolean create);






void purple_account_destroy_log(PurpleAccount *account);
# 964 "/usr/include/libpurple/account.h"
void purple_account_add_buddy(PurpleAccount *account, PurpleBuddy *buddy);
# 974 "/usr/include/libpurple/account.h"
void purple_account_add_buddy_with_invite(PurpleAccount *account, PurpleBuddy *buddy, const char *message);
# 984 "/usr/include/libpurple/account.h"
void purple_account_add_buddies(PurpleAccount *account, GList *buddies);
# 994 "/usr/include/libpurple/account.h"
void purple_account_add_buddies_with_invite(PurpleAccount *account, GList *buddies, const char *message);
# 1003 "/usr/include/libpurple/account.h"
void purple_account_remove_buddy(PurpleAccount *account, PurpleBuddy *buddy,
        PurpleGroup *group);
# 1017 "/usr/include/libpurple/account.h"
void purple_account_remove_buddies(PurpleAccount *account, GList *buddies,
         GList *groups);







void purple_account_remove_group(PurpleAccount *account, PurpleGroup *group);
# 1035 "/usr/include/libpurple/account.h"
void purple_account_change_password(PurpleAccount *account, const char *orig_pw,
         const char *new_pw);







gboolean purple_account_supports_offline_message(PurpleAccount *account, PurpleBuddy *buddy);
# 1056 "/usr/include/libpurple/account.h"
const PurpleConnectionErrorInfo *purple_account_get_current_error(PurpleAccount *account);






void purple_account_clear_current_error(PurpleAccount *account);
# 1077 "/usr/include/libpurple/account.h"
void purple_accounts_add(PurpleAccount *account);






void purple_accounts_remove(PurpleAccount *account);
# 1095 "/usr/include/libpurple/account.h"
void purple_accounts_delete(PurpleAccount *account);







void purple_accounts_reorder(PurpleAccount *account, gint new_index);






GList *purple_accounts_get_all(void);
# 1119 "/usr/include/libpurple/account.h"
GList *purple_accounts_get_all_active(void);
# 1129 "/usr/include/libpurple/account.h"
PurpleAccount *purple_accounts_find(const char *name, const char *protocol);
# 1140 "/usr/include/libpurple/account.h"
void purple_accounts_restore_current_statuses(void);
# 1154 "/usr/include/libpurple/account.h"
void purple_accounts_set_ui_ops(PurpleAccountUiOps *ops);






PurpleAccountUiOps *purple_accounts_get_ui_ops(void);
# 1176 "/usr/include/libpurple/account.h"
void *purple_accounts_get_handle(void);




void purple_accounts_init(void);




void purple_accounts_uninit(void);
# 48 "src/bnet.h" 2
# 1 "/usr/include/libpurple/accountopt.h" 1
# 37 "/usr/include/libpurple/accountopt.h"
typedef struct
{
 PurplePrefType type;

 char *text;
 char *pref_name;

 union
 {
  gboolean boolean;
  int integer;
  char *string;
  GList *list;

 } default_value;

 gboolean masked;



} PurpleAccountOption;







typedef struct
{
 char *text;
 char *default_value;
 char field_sep;
 gboolean reverse;



} PurpleAccountUserSplit;
# 97 "/usr/include/libpurple/accountopt.h"
PurpleAccountOption *purple_account_option_new(PurplePrefType type,
 const char *text, const char *pref_name);
# 109 "/usr/include/libpurple/accountopt.h"
PurpleAccountOption *purple_account_option_bool_new(const char *text,
 const char *pref_name, gboolean default_value);
# 121 "/usr/include/libpurple/accountopt.h"
PurpleAccountOption *purple_account_option_int_new(const char *text,
 const char *pref_name, int default_value);
# 133 "/usr/include/libpurple/accountopt.h"
PurpleAccountOption *purple_account_option_string_new(const char *text,
 const char *pref_name, const char *default_value);
# 153 "/usr/include/libpurple/accountopt.h"
PurpleAccountOption *purple_account_option_list_new(const char *text,
 const char *pref_name, GList *list);






void purple_account_option_destroy(PurpleAccountOption *option);







void purple_account_option_set_default_bool(PurpleAccountOption *option,
            gboolean value);







void purple_account_option_set_default_int(PurpleAccountOption *option,
           int value);







void purple_account_option_set_default_string(PurpleAccountOption *option,
           const char *value);
# 198 "/usr/include/libpurple/accountopt.h"
void
purple_account_option_set_masked(PurpleAccountOption *option, gboolean masked);
# 213 "/usr/include/libpurple/accountopt.h"
void purple_account_option_set_list(PurpleAccountOption *option, GList *values);
# 222 "/usr/include/libpurple/accountopt.h"
void purple_account_option_add_list_item(PurpleAccountOption *option,
            const char *key, const char *value);
# 232 "/usr/include/libpurple/accountopt.h"
PurplePrefType purple_account_option_get_type(const PurpleAccountOption *option);
# 241 "/usr/include/libpurple/accountopt.h"
const char *purple_account_option_get_text(const PurpleAccountOption *option);
# 252 "/usr/include/libpurple/accountopt.h"
const char *purple_account_option_get_setting(const PurpleAccountOption *option);
# 261 "/usr/include/libpurple/accountopt.h"
gboolean purple_account_option_get_default_bool(const PurpleAccountOption *option);
# 270 "/usr/include/libpurple/accountopt.h"
int purple_account_option_get_default_int(const PurpleAccountOption *option);
# 279 "/usr/include/libpurple/accountopt.h"
const char *purple_account_option_get_default_string(
 const PurpleAccountOption *option);
# 289 "/usr/include/libpurple/accountopt.h"
const char *purple_account_option_get_default_list_value(
 const PurpleAccountOption *option);
# 301 "/usr/include/libpurple/accountopt.h"
gboolean
purple_account_option_get_masked(const PurpleAccountOption *option);
# 314 "/usr/include/libpurple/accountopt.h"
GList *purple_account_option_get_list(const PurpleAccountOption *option);
# 333 "/usr/include/libpurple/accountopt.h"
PurpleAccountUserSplit *purple_account_user_split_new(const char *text,
              const char *default_value,
              char sep);






void purple_account_user_split_destroy(PurpleAccountUserSplit *split);
# 351 "/usr/include/libpurple/accountopt.h"
const char *purple_account_user_split_get_text(const PurpleAccountUserSplit *split);
# 360 "/usr/include/libpurple/accountopt.h"
const char *purple_account_user_split_get_default_value(
  const PurpleAccountUserSplit *split);
# 370 "/usr/include/libpurple/accountopt.h"
char purple_account_user_split_get_separator(const PurpleAccountUserSplit *split);
# 379 "/usr/include/libpurple/accountopt.h"
gboolean purple_account_user_split_get_reverse(const PurpleAccountUserSplit *split);







void purple_account_user_split_set_reverse(PurpleAccountUserSplit *split, gboolean reverse);
# 49 "src/bnet.h" 2
# 1 "/usr/include/libpurple/blist.h" 1
# 50 "src/bnet.h" 2
# 1 "/usr/include/libpurple/circbuffer.h" 1
# 33 "/usr/include/libpurple/circbuffer.h"
typedef struct _PurpleCircBuffer {


 gchar *buffer;



 gsize growsize;


 gsize buflen;


 gsize bufused;



 gchar *inptr;



 gchar *outptr;

} PurpleCircBuffer;
# 69 "/usr/include/libpurple/circbuffer.h"
PurpleCircBuffer *purple_circ_buffer_new(gsize growsize);







void purple_circ_buffer_destroy(PurpleCircBuffer *buf);
# 87 "/usr/include/libpurple/circbuffer.h"
void purple_circ_buffer_append(PurpleCircBuffer *buf, gconstpointer src, gsize len);
# 101 "/usr/include/libpurple/circbuffer.h"
gsize purple_circ_buffer_get_max_read(const PurpleCircBuffer *buf);
# 112 "/usr/include/libpurple/circbuffer.h"
gboolean purple_circ_buffer_mark_read(PurpleCircBuffer *buf, gsize len);
# 51 "src/bnet.h" 2
# 1 "/usr/include/libpurple/connection.h" 1
# 52 "src/bnet.h" 2
# 1 "/usr/include/libpurple/cmds.h" 1
# 35 "/usr/include/libpurple/cmds.h"
typedef enum _PurpleCmdStatus {
 PURPLE_CMD_STATUS_OK,
 PURPLE_CMD_STATUS_FAILED,
 PURPLE_CMD_STATUS_NOT_FOUND,
 PURPLE_CMD_STATUS_WRONG_ARGS,
 PURPLE_CMD_STATUS_WRONG_PRPL,
 PURPLE_CMD_STATUS_WRONG_TYPE
} PurpleCmdStatus;
# 51 "/usr/include/libpurple/cmds.h"
typedef enum _PurpleCmdRet {
 PURPLE_CMD_RET_OK,
 PURPLE_CMD_RET_FAILED,
 PURPLE_CMD_RET_CONTINUE
} PurpleCmdRet;







typedef PurpleCmdRet (*PurpleCmdFunc)(PurpleConversation *, const gchar *cmd,
                                  gchar **args, gchar **error, void *data);




typedef guint PurpleCmdId;

typedef enum _PurpleCmdPriority {
 PURPLE_CMD_P_VERY_LOW = -1000,
 PURPLE_CMD_P_LOW = 0,
 PURPLE_CMD_P_DEFAULT = 1000,
 PURPLE_CMD_P_PRPL = 2000,
 PURPLE_CMD_P_PLUGIN = 3000,
 PURPLE_CMD_P_ALIAS = 4000,
 PURPLE_CMD_P_HIGH = 5000,
 PURPLE_CMD_P_VERY_HIGH = 6000
} PurpleCmdPriority;







typedef enum _PurpleCmdFlag {

 PURPLE_CMD_FLAG_IM = 0x01,

 PURPLE_CMD_FLAG_CHAT = 0x02,

 PURPLE_CMD_FLAG_PRPL_ONLY = 0x04,

 PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS = 0x08
} PurpleCmdFlag;
# 161 "/usr/include/libpurple/cmds.h"
PurpleCmdId purple_cmd_register(const gchar *cmd, const gchar *args, PurpleCmdPriority p, PurpleCmdFlag f,
                             const gchar *prpl_id, PurpleCmdFunc func, const gchar *helpstr, void *data);
# 173 "/usr/include/libpurple/cmds.h"
void purple_cmd_unregister(PurpleCmdId id);
# 193 "/usr/include/libpurple/cmds.h"
PurpleCmdStatus purple_cmd_do_command(PurpleConversation *conv, const gchar *cmdline,
                                  const gchar *markup, gchar **errormsg);
# 209 "/usr/include/libpurple/cmds.h"
GList *purple_cmd_list(PurpleConversation *conv);
# 223 "/usr/include/libpurple/cmds.h"
GList *purple_cmd_help(PurpleConversation *conv, const gchar *cmd);






gpointer purple_cmds_get_handle(void);





void purple_cmds_init(void);





void purple_cmds_uninit(void);
# 53 "src/bnet.h" 2
# 1 "/usr/include/libpurple/debug.h" 1
# 35 "/usr/include/libpurple/debug.h"
typedef enum
{
 PURPLE_DEBUG_ALL = 0,
 PURPLE_DEBUG_MISC,
 PURPLE_DEBUG_INFO,
 PURPLE_DEBUG_WARNING,
 PURPLE_DEBUG_ERROR,
 PURPLE_DEBUG_FATAL

} PurpleDebugLevel;




typedef struct
{
 void (*print)(PurpleDebugLevel level, const char *category,
      const char *arg_s);
 gboolean (*is_enabled)(PurpleDebugLevel level,
   const char *category);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
 void (*_purple_reserved4)(void);
} PurpleDebugUiOps;
# 76 "/usr/include/libpurple/debug.h"
void purple_debug(PurpleDebugLevel level, const char *category,
    const char *format, ...) __attribute__((__format__ (__printf__, 3, 4)));
# 90 "/usr/include/libpurple/debug.h"
void purple_debug_misc(const char *category, const char *format, ...) __attribute__((__format__ (__printf__, 2, 3)));
# 103 "/usr/include/libpurple/debug.h"
void purple_debug_info(const char *category, const char *format, ...) __attribute__((__format__ (__printf__, 2, 3)));
# 116 "/usr/include/libpurple/debug.h"
void purple_debug_warning(const char *category, const char *format, ...) __attribute__((__format__ (__printf__, 2, 3)));
# 129 "/usr/include/libpurple/debug.h"
void purple_debug_error(const char *category, const char *format, ...) __attribute__((__format__ (__printf__, 2, 3)));
# 142 "/usr/include/libpurple/debug.h"
void purple_debug_fatal(const char *category, const char *format, ...) __attribute__((__format__ (__printf__, 2, 3)));






void purple_debug_set_enabled(gboolean enabled);






gboolean purple_debug_is_enabled(void);
# 167 "/usr/include/libpurple/debug.h"
void purple_debug_set_verbose(gboolean verbose);
# 176 "/usr/include/libpurple/debug.h"
gboolean purple_debug_is_verbose(void);
# 189 "/usr/include/libpurple/debug.h"
void purple_debug_set_unsafe(gboolean unsafe);
# 200 "/usr/include/libpurple/debug.h"
gboolean purple_debug_is_unsafe(void);
# 215 "/usr/include/libpurple/debug.h"
void purple_debug_set_ui_ops(PurpleDebugUiOps *ops);







PurpleDebugUiOps *purple_debug_get_ui_ops(void);
# 235 "/usr/include/libpurple/debug.h"
void purple_debug_init(void);
# 54 "src/bnet.h" 2
# 1 "/usr/include/libpurple/network.h" 1
# 38 "/usr/include/libpurple/network.h"
typedef struct _PurpleNetworkListenData PurpleNetworkListenData;

typedef void (*PurpleNetworkListenCallback) (int listenfd, gpointer data);
# 54 "/usr/include/libpurple/network.h"
const unsigned char *purple_network_ip_atoi(const char *ip);
# 64 "/usr/include/libpurple/network.h"
void purple_network_set_public_ip(const char *ip);
# 74 "/usr/include/libpurple/network.h"
const char *purple_network_get_public_ip(void);
# 88 "/usr/include/libpurple/network.h"
const char *purple_network_get_local_system_ip(int fd);
# 99 "/usr/include/libpurple/network.h"
GList *purple_network_get_all_local_system_ips(void);
# 118 "/usr/include/libpurple/network.h"
const char *purple_network_get_my_ip(int fd);
# 130 "/usr/include/libpurple/network.h"
void purple_network_listen_map_external(gboolean map_external);
# 157 "/usr/include/libpurple/network.h"
PurpleNetworkListenData *purple_network_listen(unsigned short port,
  int socket_type, PurpleNetworkListenCallback cb, gpointer cb_data);
# 177 "/usr/include/libpurple/network.h"
PurpleNetworkListenData *purple_network_listen_family(unsigned short port,
 int socket_family, int socket_type, PurpleNetworkListenCallback cb,
 gpointer cb_data);
# 211 "/usr/include/libpurple/network.h"
PurpleNetworkListenData *purple_network_listen_range(unsigned short start,
  unsigned short end, int socket_type,
  PurpleNetworkListenCallback cb, gpointer cb_data);
# 233 "/usr/include/libpurple/network.h"
PurpleNetworkListenData *purple_network_listen_range_family(
 unsigned short start, unsigned short end, int socket_family,
 int socket_type, PurpleNetworkListenCallback cb, gpointer cb_data);
# 245 "/usr/include/libpurple/network.h"
void purple_network_listen_cancel(PurpleNetworkListenData *listen_data);
# 255 "/usr/include/libpurple/network.h"
unsigned short purple_network_get_port_from_fd(int fd);






gboolean purple_network_is_available(void);
# 273 "/usr/include/libpurple/network.h"
void purple_network_force_online(void);






void *purple_network_get_handle(void);
# 289 "/usr/include/libpurple/network.h"
void purple_network_set_stun_server(const gchar *stun_server);







const gchar *purple_network_get_stun_ip(void);
# 306 "/usr/include/libpurple/network.h"
void purple_network_set_turn_server(const gchar *turn_server);







const gchar *purple_network_get_turn_ip(void);







void purple_network_remove_port_mapping(gint fd);
# 341 "/usr/include/libpurple/network.h"
int purple_network_convert_idn_to_ascii(const gchar *in, gchar **out);




void purple_network_init(void);




void purple_network_uninit(void);
# 55 "src/bnet.h" 2
# 1 "/usr/include/libpurple/notify.h" 1
# 56 "src/bnet.h" 2
# 1 "/usr/include/libpurple/plugin.h" 1
# 57 "src/bnet.h" 2
# 1 "/usr/include/libpurple/prpl.h" 1
# 58 "src/bnet.h" 2
# 1 "/usr/include/libpurple/roomlist.h" 1
# 59 "src/bnet.h" 2
# 1 "/usr/include/libpurple/request.h" 1
# 34 "/usr/include/libpurple/request.h"
typedef struct _PurpleRequestField PurpleRequestField;
# 43 "/usr/include/libpurple/request.h"
typedef enum
{
 PURPLE_REQUEST_INPUT = 0,
 PURPLE_REQUEST_CHOICE,
 PURPLE_REQUEST_ACTION,
 PURPLE_REQUEST_FIELDS,
 PURPLE_REQUEST_FILE,
 PURPLE_REQUEST_FOLDER

} PurpleRequestType;




typedef enum
{
 PURPLE_REQUEST_FIELD_NONE,
 PURPLE_REQUEST_FIELD_STRING,
 PURPLE_REQUEST_FIELD_INTEGER,
 PURPLE_REQUEST_FIELD_BOOLEAN,
 PURPLE_REQUEST_FIELD_CHOICE,
 PURPLE_REQUEST_FIELD_LIST,
 PURPLE_REQUEST_FIELD_LABEL,
 PURPLE_REQUEST_FIELD_IMAGE,
 PURPLE_REQUEST_FIELD_ACCOUNT

} PurpleRequestFieldType;




typedef struct
{
 GList *groups;

 GHashTable *fields;

 GList *required_fields;

 void *ui_data;

} PurpleRequestFields;




typedef struct
{
 PurpleRequestFields *fields_list;

 char *title;

 GList *fields;

} PurpleRequestFieldGroup;





struct _PurpleRequestField
{
 PurpleRequestFieldType type;
 PurpleRequestFieldGroup *group;

 char *id;
 char *label;
 char *type_hint;

 gboolean visible;
 gboolean required;

 union
 {
  struct
  {
   gboolean multiline;
   gboolean masked;
   gboolean editable;
   char *default_value;
   char *value;

  } string;

  struct
  {
   int default_value;
   int value;

  } integer;

  struct
  {
   gboolean default_value;
   gboolean value;

  } boolean;

  struct
  {
   int default_value;
   int value;

   GList *labels;

  } choice;

  struct
  {
   GList *items;
   GList *icons;
   GHashTable *item_data;
   GList *selected;
   GHashTable *selected_table;

   gboolean multiple_selection;

  } list;

  struct
  {
   PurpleAccount *default_account;
   PurpleAccount *account;
   gboolean show_all;

   PurpleFilterAccountFunc filter_func;

  } account;

  struct
  {
   unsigned int scale_x;
   unsigned int scale_y;
   const char *buffer;
   gsize size;
  } image;

 } u;

 void *ui_data;

};





typedef struct
{

 void *(*request_input)(const char *title, const char *primary,
                        const char *secondary, const char *default_value,
                        gboolean multiline, gboolean masked, gchar *hint,
                        const char *ok_text, GCallback ok_cb,
                        const char *cancel_text, GCallback cancel_cb,
                        PurpleAccount *account, const char *who,
                        PurpleConversation *conv, void *user_data);


 void *(*request_choice)(const char *title, const char *primary,
                         const char *secondary, int default_value,
                         const char *ok_text, GCallback ok_cb,
                         const char *cancel_text, GCallback cancel_cb,
                         PurpleAccount *account, const char *who,
                         PurpleConversation *conv, void *user_data,
                         va_list choices);


 void *(*request_action)(const char *title, const char *primary,
                         const char *secondary, int default_action,
                         PurpleAccount *account, const char *who,
                         PurpleConversation *conv, void *user_data,
                         size_t action_count, va_list actions);


 void *(*request_fields)(const char *title, const char *primary,
                         const char *secondary, PurpleRequestFields *fields,
                         const char *ok_text, GCallback ok_cb,
                         const char *cancel_text, GCallback cancel_cb,
                         PurpleAccount *account, const char *who,
                         PurpleConversation *conv, void *user_data);


 void *(*request_file)(const char *title, const char *filename,
                       gboolean savedialog, GCallback ok_cb,
                       GCallback cancel_cb, PurpleAccount *account,
                       const char *who, PurpleConversation *conv,
                       void *user_data);

 void (*close_request)(PurpleRequestType type, void *ui_handle);


 void *(*request_folder)(const char *title, const char *dirname,
                         GCallback ok_cb, GCallback cancel_cb,
                         PurpleAccount *account, const char *who,
                         PurpleConversation *conv, void *user_data);


 void *(*request_action_with_icon)(const char *title, const char *primary,
                         const char *secondary, int default_action,
                         PurpleAccount *account, const char *who,
                         PurpleConversation *conv,
                         gconstpointer icon_data, gsize icon_size,
                         void *user_data,
                         size_t action_count, va_list actions);

 void (*_purple_reserved1)(void);
 void (*_purple_reserved2)(void);
 void (*_purple_reserved3)(void);
} PurpleRequestUiOps;

typedef void (*PurpleRequestInputCb)(void *, const char *);





typedef void (*PurpleRequestActionCb)(void *, int);
typedef void (*PurpleRequestChoiceCb)(void *, int);
typedef void (*PurpleRequestFieldsCb)(void *, PurpleRequestFields *fields);
typedef void (*PurpleRequestFileCb)(void *, const char *filename);
# 279 "/usr/include/libpurple/request.h"
PurpleRequestFields *purple_request_fields_new(void);






void purple_request_fields_destroy(PurpleRequestFields *fields);







void purple_request_fields_add_group(PurpleRequestFields *fields,
           PurpleRequestFieldGroup *group);
# 304 "/usr/include/libpurple/request.h"
GList *purple_request_fields_get_groups(const PurpleRequestFields *fields);
# 314 "/usr/include/libpurple/request.h"
gboolean purple_request_fields_exists(const PurpleRequestFields *fields,
         const char *id);
# 324 "/usr/include/libpurple/request.h"
GList *purple_request_fields_get_required(const PurpleRequestFields *fields);
# 334 "/usr/include/libpurple/request.h"
gboolean purple_request_fields_is_field_required(const PurpleRequestFields *fields,
              const char *id);
# 344 "/usr/include/libpurple/request.h"
gboolean purple_request_fields_all_required_filled(
 const PurpleRequestFields *fields);
# 355 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_fields_get_field(
  const PurpleRequestFields *fields, const char *id);
# 366 "/usr/include/libpurple/request.h"
const char *purple_request_fields_get_string(const PurpleRequestFields *fields,
             const char *id);
# 377 "/usr/include/libpurple/request.h"
int purple_request_fields_get_integer(const PurpleRequestFields *fields,
         const char *id);
# 388 "/usr/include/libpurple/request.h"
gboolean purple_request_fields_get_bool(const PurpleRequestFields *fields,
           const char *id);
# 399 "/usr/include/libpurple/request.h"
int purple_request_fields_get_choice(const PurpleRequestFields *fields,
           const char *id);
# 410 "/usr/include/libpurple/request.h"
PurpleAccount *purple_request_fields_get_account(const PurpleRequestFields *fields,
            const char *id);
# 427 "/usr/include/libpurple/request.h"
PurpleRequestFieldGroup *purple_request_field_group_new(const char *title);






void purple_request_field_group_destroy(PurpleRequestFieldGroup *group);







void purple_request_field_group_add_field(PurpleRequestFieldGroup *group,
          PurpleRequestField *field);
# 452 "/usr/include/libpurple/request.h"
const char *purple_request_field_group_get_title(
  const PurpleRequestFieldGroup *group);
# 462 "/usr/include/libpurple/request.h"
GList *purple_request_field_group_get_fields(
  const PurpleRequestFieldGroup *group);
# 481 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_new(const char *id, const char *text,
           PurpleRequestFieldType type);






void purple_request_field_destroy(PurpleRequestField *field);







void purple_request_field_set_label(PurpleRequestField *field, const char *label);







void purple_request_field_set_visible(PurpleRequestField *field, gboolean visible);
# 516 "/usr/include/libpurple/request.h"
void purple_request_field_set_type_hint(PurpleRequestField *field,
           const char *type_hint);







void purple_request_field_set_required(PurpleRequestField *field,
          gboolean required);
# 535 "/usr/include/libpurple/request.h"
PurpleRequestFieldType purple_request_field_get_type(const PurpleRequestField *field);
# 546 "/usr/include/libpurple/request.h"
PurpleRequestFieldGroup *purple_request_field_get_group(const PurpleRequestField *field);
# 555 "/usr/include/libpurple/request.h"
const char *purple_request_field_get_id(const PurpleRequestField *field);
# 564 "/usr/include/libpurple/request.h"
const char *purple_request_field_get_label(const PurpleRequestField *field);
# 573 "/usr/include/libpurple/request.h"
gboolean purple_request_field_is_visible(const PurpleRequestField *field);
# 582 "/usr/include/libpurple/request.h"
const char *purple_request_field_get_type_hint(const PurpleRequestField *field);
# 591 "/usr/include/libpurple/request.h"
gboolean purple_request_field_is_required(const PurpleRequestField *field);
# 602 "/usr/include/libpurple/request.h"
gpointer purple_request_field_get_ui_data(const PurpleRequestField *field);
# 614 "/usr/include/libpurple/request.h"
void purple_request_field_set_ui_data(PurpleRequestField *field,
                                      gpointer ui_data);
# 634 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_string_new(const char *id,
            const char *text,
            const char *default_value,
            gboolean multiline);







void purple_request_field_string_set_default_value(PurpleRequestField *field,
             const char *default_value);







void purple_request_field_string_set_value(PurpleRequestField *field,
           const char *value);
# 664 "/usr/include/libpurple/request.h"
void purple_request_field_string_set_masked(PurpleRequestField *field,
            gboolean masked);







void purple_request_field_string_set_editable(PurpleRequestField *field,
           gboolean editable);
# 683 "/usr/include/libpurple/request.h"
const char *purple_request_field_string_get_default_value(
  const PurpleRequestField *field);
# 693 "/usr/include/libpurple/request.h"
const char *purple_request_field_string_get_value(const PurpleRequestField *field);
# 702 "/usr/include/libpurple/request.h"
gboolean purple_request_field_string_is_multiline(const PurpleRequestField *field);
# 711 "/usr/include/libpurple/request.h"
gboolean purple_request_field_string_is_masked(const PurpleRequestField *field);
# 720 "/usr/include/libpurple/request.h"
gboolean purple_request_field_string_is_editable(const PurpleRequestField *field);
# 738 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_int_new(const char *id,
            const char *text,
            int default_value);







void purple_request_field_int_set_default_value(PurpleRequestField *field,
             int default_value);







void purple_request_field_int_set_value(PurpleRequestField *field, int value);
# 766 "/usr/include/libpurple/request.h"
int purple_request_field_int_get_default_value(const PurpleRequestField *field);
# 775 "/usr/include/libpurple/request.h"
int purple_request_field_int_get_value(const PurpleRequestField *field);
# 795 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_bool_new(const char *id,
             const char *text,
             gboolean default_value);







void purple_request_field_bool_set_default_value(PurpleRequestField *field,
              gboolean default_value);







void purple_request_field_bool_set_value(PurpleRequestField *field,
            gboolean value);
# 824 "/usr/include/libpurple/request.h"
gboolean purple_request_field_bool_get_default_value(
  const PurpleRequestField *field);
# 834 "/usr/include/libpurple/request.h"
gboolean purple_request_field_bool_get_value(const PurpleRequestField *field);
# 854 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_choice_new(const char *id,
            const char *text,
            int default_value);







void purple_request_field_choice_add(PurpleRequestField *field,
           const char *label);







void purple_request_field_choice_set_default_value(PurpleRequestField *field,
             int default_value);







void purple_request_field_choice_set_value(PurpleRequestField *field, int value);
# 891 "/usr/include/libpurple/request.h"
int purple_request_field_choice_get_default_value(const PurpleRequestField *field);
# 900 "/usr/include/libpurple/request.h"
int purple_request_field_choice_get_value(const PurpleRequestField *field);
# 909 "/usr/include/libpurple/request.h"
GList *purple_request_field_choice_get_labels(const PurpleRequestField *field);
# 926 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_list_new(const char *id, const char *text);
# 935 "/usr/include/libpurple/request.h"
void purple_request_field_list_set_multi_select(PurpleRequestField *field,
             gboolean multi_select);
# 945 "/usr/include/libpurple/request.h"
gboolean purple_request_field_list_get_multi_select(
 const PurpleRequestField *field);
# 956 "/usr/include/libpurple/request.h"
void *purple_request_field_list_get_data(const PurpleRequestField *field,
            const char *text);
# 968 "/usr/include/libpurple/request.h"
void purple_request_field_list_add(PurpleRequestField *field,
         const char *item, void *data);
# 979 "/usr/include/libpurple/request.h"
void purple_request_field_list_add_icon(PurpleRequestField *field,
         const char *item, const char* icon_path, void* data);







void purple_request_field_list_add_selected(PurpleRequestField *field,
            const char *item);






void purple_request_field_list_clear_selected(PurpleRequestField *field);







void purple_request_field_list_set_selected(PurpleRequestField *field,
            GList *items);
# 1015 "/usr/include/libpurple/request.h"
gboolean purple_request_field_list_is_selected(const PurpleRequestField *field,
            const char *item);
# 1028 "/usr/include/libpurple/request.h"
GList *purple_request_field_list_get_selected(
 const PurpleRequestField *field);
# 1038 "/usr/include/libpurple/request.h"
GList *purple_request_field_list_get_items(const PurpleRequestField *field);
# 1050 "/usr/include/libpurple/request.h"
GList *purple_request_field_list_get_icons(const PurpleRequestField *field);
# 1067 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_label_new(const char *id,
              const char *text);
# 1087 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_image_new(const char *id, const char *text,
              const char *buf, gsize size);
# 1097 "/usr/include/libpurple/request.h"
void purple_request_field_image_set_scale(PurpleRequestField *field, unsigned int x, unsigned int y);
# 1106 "/usr/include/libpurple/request.h"
const char *purple_request_field_image_get_buffer(PurpleRequestField *field);
# 1115 "/usr/include/libpurple/request.h"
gsize purple_request_field_image_get_size(PurpleRequestField *field);
# 1124 "/usr/include/libpurple/request.h"
unsigned int purple_request_field_image_get_scale_x(PurpleRequestField *field);
# 1133 "/usr/include/libpurple/request.h"
unsigned int purple_request_field_image_get_scale_y(PurpleRequestField *field);
# 1153 "/usr/include/libpurple/request.h"
PurpleRequestField *purple_request_field_account_new(const char *id,
             const char *text,
             PurpleAccount *account);







void purple_request_field_account_set_default_value(PurpleRequestField *field,
              PurpleAccount *default_value);







void purple_request_field_account_set_value(PurpleRequestField *field,
            PurpleAccount *value);
# 1184 "/usr/include/libpurple/request.h"
void purple_request_field_account_set_show_all(PurpleRequestField *field,
            gboolean show_all);
# 1196 "/usr/include/libpurple/request.h"
void purple_request_field_account_set_filter(PurpleRequestField *field,
             PurpleFilterAccountFunc filter_func);
# 1206 "/usr/include/libpurple/request.h"
PurpleAccount *purple_request_field_account_get_default_value(
  const PurpleRequestField *field);
# 1216 "/usr/include/libpurple/request.h"
PurpleAccount *purple_request_field_account_get_value(
  const PurpleRequestField *field);
# 1228 "/usr/include/libpurple/request.h"
gboolean purple_request_field_account_get_show_all(
  const PurpleRequestField *field);
# 1241 "/usr/include/libpurple/request.h"
PurpleFilterAccountFunc purple_request_field_account_get_filter(
  const PurpleRequestField *field);
# 1297 "/usr/include/libpurple/request.h"
void *purple_request_input(void *handle, const char *title, const char *primary,
 const char *secondary, const char *default_value, gboolean multiline,
 gboolean masked, gchar *hint,
 const char *ok_text, GCallback ok_cb,
 const char *cancel_text, GCallback cancel_cb,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 void *user_data);
# 1338 "/usr/include/libpurple/request.h"
void *purple_request_choice(void *handle, const char *title, const char *primary,
 const char *secondary, int default_value,
 const char *ok_text, GCallback ok_cb,
 const char *cancel_text, GCallback cancel_cb,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 void *user_data, ...) __attribute__((__sentinel__));




void *purple_request_choice_varg(void *handle, const char *title,
 const char *primary, const char *secondary, int default_value,
 const char *ok_text, GCallback ok_cb,
 const char *cancel_text, GCallback cancel_cb,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 void *user_data, va_list choices);
# 1390 "/usr/include/libpurple/request.h"
void *purple_request_action(void *handle, const char *title, const char *primary,
 const char *secondary, int default_action, PurpleAccount *account,
 const char *who, PurpleConversation *conv, void *user_data,
 size_t action_count, ...);




void *purple_request_action_varg(void *handle, const char *title,
 const char *primary, const char *secondary, int default_action,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 void *user_data, size_t action_count, va_list actions);






void *purple_request_action_with_icon(void *handle, const char *title,
 const char *primary, const char *secondary, int default_action,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 gconstpointer icon_data, gsize icon_size, void *user_data,
 size_t action_count, ...);






void *purple_request_action_with_icon_varg(void *handle, const char *title,
 const char *primary, const char *secondary, int default_action,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 gconstpointer icon_data, gsize icon_size,
 void *user_data, size_t action_count, va_list actions);
# 1455 "/usr/include/libpurple/request.h"
void *purple_request_fields(void *handle, const char *title, const char *primary,
 const char *secondary, PurpleRequestFields *fields,
 const char *ok_text, GCallback ok_cb,
 const char *cancel_text, GCallback cancel_cb,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 void *user_data);







void purple_request_close(PurpleRequestType type, void *uihandle);
# 1478 "/usr/include/libpurple/request.h"
void purple_request_close_with_handle(void *handle);
# 1547 "/usr/include/libpurple/request.h"
void *purple_request_file(void *handle, const char *title, const char *filename,
 gboolean savedialog, GCallback ok_cb, GCallback cancel_cb,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 void *user_data);
# 1574 "/usr/include/libpurple/request.h"
void *purple_request_folder(void *handle, const char *title, const char *dirname,
 GCallback ok_cb, GCallback cancel_cb,
 PurpleAccount *account, const char *who, PurpleConversation *conv,
 void *user_data);
# 1592 "/usr/include/libpurple/request.h"
void purple_request_set_ui_ops(PurpleRequestUiOps *ops);







PurpleRequestUiOps *purple_request_get_ui_ops(void);
# 60 "src/bnet.h" 2
# 1 "/usr/include/libpurple/version.h" 1
# 53 "/usr/include/libpurple/version.h"
const char *purple_version_check(guint required_major, guint required_minor, guint required_micro);
# 62 "/usr/include/libpurple/version.h"
extern const guint purple_major_version;
# 71 "/usr/include/libpurple/version.h"
extern const guint purple_minor_version;
# 81 "/usr/include/libpurple/version.h"
extern const guint purple_micro_version;
# 61 "src/bnet.h" 2


# 1 "src/bufferer.h" 1
# 29 "src/bufferer.h"
# 1 "/usr/include/ctype.h" 1 3 4
# 29 "/usr/include/ctype.h" 3 4

# 47 "/usr/include/ctype.h" 3 4
enum
{
  _ISupper = ((0) < 8 ? ((1 << (0)) << 8) : ((1 << (0)) >> 8)),
  _ISlower = ((1) < 8 ? ((1 << (1)) << 8) : ((1 << (1)) >> 8)),
  _ISalpha = ((2) < 8 ? ((1 << (2)) << 8) : ((1 << (2)) >> 8)),
  _ISdigit = ((3) < 8 ? ((1 << (3)) << 8) : ((1 << (3)) >> 8)),
  _ISxdigit = ((4) < 8 ? ((1 << (4)) << 8) : ((1 << (4)) >> 8)),
  _ISspace = ((5) < 8 ? ((1 << (5)) << 8) : ((1 << (5)) >> 8)),
  _ISprint = ((6) < 8 ? ((1 << (6)) << 8) : ((1 << (6)) >> 8)),
  _ISgraph = ((7) < 8 ? ((1 << (7)) << 8) : ((1 << (7)) >> 8)),
  _ISblank = ((8) < 8 ? ((1 << (8)) << 8) : ((1 << (8)) >> 8)),
  _IScntrl = ((9) < 8 ? ((1 << (9)) << 8) : ((1 << (9)) >> 8)),
  _ISpunct = ((10) < 8 ? ((1 << (10)) << 8) : ((1 << (10)) >> 8)),
  _ISalnum = ((11) < 8 ? ((1 << (11)) << 8) : ((1 << (11)) >> 8))
};
# 80 "/usr/include/ctype.h" 3 4
extern const unsigned short int **__ctype_b_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_tolower_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
extern const __int32_t **__ctype_toupper_loc (void)
     __attribute__ ((__nothrow__ , __leaf__)) __attribute__ ((__const__));
# 105 "/usr/include/ctype.h" 3 4






extern int isalnum (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha (int) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit (int) __attribute__ ((__nothrow__ , __leaf__));
extern int islower (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint (int) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit (int) __attribute__ ((__nothrow__ , __leaf__));



extern int tolower (int __c) __attribute__ ((__nothrow__ , __leaf__));


extern int toupper (int __c) __attribute__ ((__nothrow__ , __leaf__));








extern int isblank (int) __attribute__ ((__nothrow__ , __leaf__));


# 151 "/usr/include/ctype.h" 3 4
extern int isascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int toascii (int __c) __attribute__ ((__nothrow__ , __leaf__));



extern int _toupper (int) __attribute__ ((__nothrow__ , __leaf__));
extern int _tolower (int) __attribute__ ((__nothrow__ , __leaf__));
# 215 "/usr/include/ctype.h" 3 4
extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) tolower (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_tolower_loc ())[__c] : __c;
}

extern __inline int
__attribute__ ((__nothrow__ , __leaf__)) toupper (int __c)
{
  return __c >= -128 && __c < 256 ? (*__ctype_toupper_loc ())[__c] : __c;
}
# 272 "/usr/include/ctype.h" 3 4
extern int isalnum_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isalpha_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int iscntrl_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int islower_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isgraph_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isprint_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int ispunct_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isspace_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isupper_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));
extern int isxdigit_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));

extern int isblank_l (int, __locale_t) __attribute__ ((__nothrow__ , __leaf__));



extern int __tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int tolower_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));


extern int __toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
extern int toupper_l (int __c, __locale_t __l) __attribute__ ((__nothrow__ , __leaf__));
# 348 "/usr/include/ctype.h" 3 4

# 30 "src/bufferer.h" 2






# 1 "/usr/include/libpurple/util.h" 1
# 37 "src/bufferer.h" 2
# 57 "src/bufferer.h"
typedef struct {
    gchar *data;
    guint16 len;
    guint16 pos;
    gboolean allocd;
} BnetPacket;

void bnet_packet_free(BnetPacket *bnet_packet);

gboolean bnet_packet_insert(BnetPacket *bnet_packet, gconstpointer data, const gsize length);

BnetPacket *bnet_packet_refer(const gchar *start, const gsize length);
BnetPacket *bnet_packet_refer_bnls(const gchar *start, const gsize length);

BnetPacket *bnet_packet_deserialize(const gchar *start);

gboolean bnet_packet_can_read(BnetPacket *bnet_packet, const gsize size);
void *bnet_packet_read(BnetPacket *bnet_packet, const gsize size);
char *bnet_packet_read_cstring(BnetPacket *bnet_packet);
guint64 bnet_packet_read_qword(BnetPacket *bnet_packet);
guint32 bnet_packet_read_dword(BnetPacket *bnet_packet);
guint16 bnet_packet_read_word(BnetPacket *bnet_packet);
guint8 bnet_packet_read_byte(BnetPacket *bnet_packet);

BnetPacket *bnet_packet_create(const gsize header_length);

int bnet_packet_send(BnetPacket *bnet_packet, const guint8 id, const int fd);
int bnet_packet_send_bnls(BnetPacket *bnet_packet, const guint8 id, const int fd);

gchar *bnet_packet_serialize(BnetPacket *bnet_packet);

char *bnet_packet_debug(const BnetPacket *bnet_packet);
void clear_line(char *line, int size);
char * ascii_char(char *position, int c);
char * hex_char(char *position, int c);
# 64 "src/bnet.h" 2
# 1 "src/keydecode.h" 1
# 67 "src/keydecode.h"
# 1 "src/sha1.h" 1
# 51 "src/sha1.h"
typedef enum {
    SHA1_RESULT_SUCCESS = 0,
    SHA1_RESULT_NULL,
    SHA1_RESULT_INPUT_TOO_LONG,
    SHA1_RESULT_STATE_ERROR
} sha1_result;




typedef enum {
    SHA1_TYPE_NORMAL,
    SHA1_TYPE_BROKEN,
    SHA1_TYPE_LOCKDOWN
} sha1_type;





typedef struct {
    guint32 intermediate_hash[5];
    guint32 length_low;
    guint32 length_high;
    gint16 message_block_index;
    guint8 message_block[64];
    guint8 computed;
    guint8 corrupted;
    sha1_type version;
} sha1_context;



sha1_result sha1_reset(sha1_context *);
sha1_result sha1_input(sha1_context *, const guint8 *, guint32);
sha1_result sha1_digest(sha1_context *, guint8 *);
guint32 sha1_checksum(guint8 *data, guint32 length, guint32 version);
# 68 "src/keydecode.h" 2
# 95 "src/keydecode.h"
typedef struct {
    guint32 length;
    guint32 product_value;
    guint32 public_value;
    guint32 private_value;
    guint8 key_hash[20];
} BnetKey;

typedef enum {
    CDKEY_TYPE_SC = 13,
    CDKEY_TYPE_W2D2 = 16,
    CDKEY_TYPE_W3 = 26,
    CDKEY_TYPE_UNKNOWN = 0
} CDKeyType;




typedef struct {
    char* cdkey;
    gboolean initialized;
    gboolean keyOK;
    gsize keyLen;
    guint8 *keyHash;
    gsize hashLen;
    CDKeyType keyType;
    guint64 value1;
    guint64 value2;
    guint64 product;
    char* w3value2;
} CDKeyDecoder;

gboolean bnet_key_decode(BnetKey keys[2], int key_count,
         guint32 client_cookie, guint32 server_cookie,
         const char *key1_string, const char *key2_string);
gboolean bnet_key_decode_legacy_verify_only(char *key,
         guint32 client_cookie, guint32 server_cookie,
         const char *key1_string);
gboolean bnet_key_decode_legacy(BnetKey *key,
         guint32 client_cookie, guint32 server_cookie,
         const char *key1_string);
void bnet_key_free(CDKeyDecoder *ctx);
CDKeyDecoder *bnet_key_create_context(const char *cdkey);
gboolean bnet_is_key_valid(CDKeyDecoder *ctx);
int bnet_key_get_val2_length(CDKeyDecoder *ctx);
guint32 bnet_key_get_product(CDKeyDecoder *ctx);
guint32 bnet_key_get_val1(CDKeyDecoder *ctx);
guint32 bnet_key_get_val2(CDKeyDecoder *ctx);
guint32 bnet_key_get_long_val2(CDKeyDecoder *ctx, char* out);
gsize bnet_key_calculate_hash_legacy(CDKeyDecoder *ctx, const guint32 clientToken,
      const guint32 serverToken);
gsize bnet_key_calculate_hash(CDKeyDecoder *ctx, guint32 clientToken,
      guint32 serverToken);
gsize bnet_key_get_hash(CDKeyDecoder *ctx, guint8* outputBuffer);
gboolean process_sc(CDKeyDecoder *ctx);
gboolean process_w2d2(CDKeyDecoder *ctx);
gboolean process_w3(CDKeyDecoder *ctx);
void mult(int r, const int x, int* a, int dcByte);
void decodeKeyTable(int* keyTable);
char getHexValue(int v);
int getNumValue(char c);
# 65 "src/bnet.h" 2

# 1 "src/srp.h" 1
# 57 "src/srp.h"
# 1 "/usr/include/gmp.h" 1 3 4
# 51 "/usr/include/gmp.h" 3 4
# 1 "/usr/include/gmp-x86_64.h" 1 3 4
# 53 "/usr/include/gmp-x86_64.h" 3 4
# 1 "/usr/lib/gcc/x86_64-redhat-linux/4.8.1/include/stddef.h" 1 3 4
# 54 "/usr/include/gmp-x86_64.h" 2 3 4
# 140 "/usr/include/gmp-x86_64.h" 3 4
typedef unsigned long int mp_limb_t;
typedef long int mp_limb_signed_t;


typedef unsigned long int mp_bitcnt_t;




typedef struct
{
  int _mp_alloc;

  int _mp_size;


  mp_limb_t *_mp_d;
} __mpz_struct;




typedef __mpz_struct MP_INT;
typedef __mpz_struct mpz_t[1];

typedef mp_limb_t * mp_ptr;
typedef const mp_limb_t * mp_srcptr;







typedef long int mp_size_t;
typedef long int mp_exp_t;


typedef struct
{
  __mpz_struct _mp_num;
  __mpz_struct _mp_den;
} __mpq_struct;

typedef __mpq_struct MP_RAT;
typedef __mpq_struct mpq_t[1];

typedef struct
{
  int _mp_prec;



  int _mp_size;


  mp_exp_t _mp_exp;
  mp_limb_t *_mp_d;
} __mpf_struct;


typedef __mpf_struct mpf_t[1];


typedef enum
{
  GMP_RAND_ALG_DEFAULT = 0,
  GMP_RAND_ALG_LC = GMP_RAND_ALG_DEFAULT
} gmp_randalg_t;


typedef struct
{
  mpz_t _mp_seed;
  gmp_randalg_t _mp_alg;
  union {
    void *_mp_lc;
  } _mp_algdata;
} __gmp_randstate_struct;
typedef __gmp_randstate_struct gmp_randstate_t[1];



typedef const __mpz_struct *mpz_srcptr;
typedef __mpz_struct *mpz_ptr;
typedef const __mpf_struct *mpf_srcptr;
typedef __mpf_struct *mpf_ptr;
typedef const __mpq_struct *mpq_srcptr;
typedef __mpq_struct *mpq_ptr;
# 481 "/usr/include/gmp-x86_64.h" 3 4
 void __gmp_set_memory_functions (void *(*) (size_t),
          void *(*) (void *, size_t, size_t),
          void (*) (void *, size_t)) ;


 void __gmp_get_memory_functions (void *(**) (size_t),
                                      void *(**) (void *, size_t, size_t),
                                      void (**) (void *, size_t)) ;


 extern const int __gmp_bits_per_limb;


 extern int __gmp_errno;


 extern const char * const __gmp_version;






 void __gmp_randinit (gmp_randstate_t, gmp_randalg_t, ...);


 void __gmp_randinit_default (gmp_randstate_t);


 void __gmp_randinit_lc_2exp (gmp_randstate_t, mpz_srcptr, unsigned long int, mp_bitcnt_t);


 int __gmp_randinit_lc_2exp_size (gmp_randstate_t, mp_bitcnt_t);


 void __gmp_randinit_mt (gmp_randstate_t);


 void __gmp_randinit_set (gmp_randstate_t, const __gmp_randstate_struct *);


 void __gmp_randseed (gmp_randstate_t, mpz_srcptr);


 void __gmp_randseed_ui (gmp_randstate_t, unsigned long int);


 void __gmp_randclear (gmp_randstate_t);


 unsigned long __gmp_urandomb_ui (gmp_randstate_t, unsigned long);


 unsigned long __gmp_urandomm_ui (gmp_randstate_t, unsigned long);





 int __gmp_asprintf (char **, const char *, ...);



 int __gmp_fprintf (FILE *, const char *, ...);
# 558 "/usr/include/gmp-x86_64.h" 3 4
 int __gmp_printf (const char *, ...);


 int __gmp_snprintf (char *, size_t, const char *, ...);


 int __gmp_sprintf (char *, const char *, ...);



 int __gmp_vasprintf (char **, const char *, va_list);




 int __gmp_vfprintf (FILE *, const char *, va_list);




 int __gmp_vprintf (const char *, va_list);




 int __gmp_vsnprintf (char *, size_t, const char *, va_list);




 int __gmp_vsprintf (char *, const char *, va_list);







 int __gmp_fscanf (FILE *, const char *, ...);



 int __gmp_scanf (const char *, ...);


 int __gmp_sscanf (const char *, const char *, ...);



 int __gmp_vfscanf (FILE *, const char *, va_list);




 int __gmp_vscanf (const char *, va_list);




 int __gmp_vsscanf (const char *, const char *, va_list);







 void *__gmpz_realloc (mpz_ptr, mp_size_t);



 void __gmpz_abs (mpz_ptr, mpz_srcptr);



 void __gmpz_add (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_add_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_addmul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_addmul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_and (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_array_init (mpz_ptr, mp_size_t, mp_size_t);


 void __gmpz_bin_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_bin_uiui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_cdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_cdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_cdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_cdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_cdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_cdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_cdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_clear (mpz_ptr);


 void __gmpz_clears (mpz_ptr, ...);


 void __gmpz_clrbit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_cmp (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_cmp_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmp_si (mpz_srcptr, signed long int) __attribute__ ((__pure__));


 int __gmpz_cmp_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 int __gmpz_cmpabs (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_cmpabs_d (mpz_srcptr, double) __attribute__ ((__pure__));


 int __gmpz_cmpabs_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_com (mpz_ptr, mpz_srcptr);


 void __gmpz_combit (mpz_ptr, mp_bitcnt_t);


 int __gmpz_congruent_p (mpz_srcptr, mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_congruent_2exp_p (mpz_srcptr, mpz_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 int __gmpz_congruent_ui_p (mpz_srcptr, unsigned long, unsigned long) __attribute__ ((__pure__));


 void __gmpz_divexact (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_divexact_ui (mpz_ptr, mpz_srcptr, unsigned long);


 int __gmpz_divisible_p (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_divisible_ui_p (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_divisible_2exp_p (mpz_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 void __gmpz_dump (mpz_srcptr);


 void *__gmpz_export (void *, size_t *, int, size_t, int, size_t, mpz_srcptr);


 void __gmpz_fac_ui (mpz_ptr, unsigned long int);


 void __gmpz_2fac_ui (mpz_ptr, unsigned long int);


 void __gmpz_mfac_uiui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_primorial_ui (mpz_ptr, unsigned long int);


 void __gmpz_fdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_fdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_fdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_fdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_fdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 unsigned long int __gmpz_fdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_fib_ui (mpz_ptr, unsigned long int);


 void __gmpz_fib2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_fits_sint_p (mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_fits_slong_p (mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_fits_sshort_p (mpz_srcptr) __attribute__ ((__pure__));



 int __gmpz_fits_uint_p (mpz_srcptr) __attribute__ ((__pure__));




 int __gmpz_fits_ulong_p (mpz_srcptr) __attribute__ ((__pure__));




 int __gmpz_fits_ushort_p (mpz_srcptr) __attribute__ ((__pure__));



 void __gmpz_gcd (mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_gcd_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_gcdext (mpz_ptr, mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 double __gmpz_get_d (mpz_srcptr) __attribute__ ((__pure__));


 double __gmpz_get_d_2exp (signed long int *, mpz_srcptr);


 long int __gmpz_get_si (mpz_srcptr) __attribute__ ((__pure__));


 char *__gmpz_get_str (char *, int, mpz_srcptr);



 unsigned long int __gmpz_get_ui (mpz_srcptr) __attribute__ ((__pure__));




 mp_limb_t __gmpz_getlimbn (mpz_srcptr, mp_size_t) __attribute__ ((__pure__));



 mp_bitcnt_t __gmpz_hamdist (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));


 void __gmpz_import (mpz_ptr, size_t, int, size_t, int, size_t, const void *);


 void __gmpz_init (mpz_ptr);


 void __gmpz_init2 (mpz_ptr, mp_bitcnt_t);


 void __gmpz_inits (mpz_ptr, ...);


 void __gmpz_init_set (mpz_ptr, mpz_srcptr);


 void __gmpz_init_set_d (mpz_ptr, double);


 void __gmpz_init_set_si (mpz_ptr, signed long int);


 int __gmpz_init_set_str (mpz_ptr, const char *, int);


 void __gmpz_init_set_ui (mpz_ptr, unsigned long int);



 size_t __gmpz_inp_raw (mpz_ptr, FILE *);




 size_t __gmpz_inp_str (mpz_ptr, FILE *, int);



 int __gmpz_invert (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_ior (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_jacobi (mpz_srcptr, mpz_srcptr) __attribute__ ((__pure__));




 int __gmpz_kronecker_si (mpz_srcptr, long) __attribute__ ((__pure__));


 int __gmpz_kronecker_ui (mpz_srcptr, unsigned long) __attribute__ ((__pure__));


 int __gmpz_si_kronecker (long, mpz_srcptr) __attribute__ ((__pure__));


 int __gmpz_ui_kronecker (unsigned long, mpz_srcptr) __attribute__ ((__pure__));


 void __gmpz_lcm (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_lcm_ui (mpz_ptr, mpz_srcptr, unsigned long);




 void __gmpz_lucnum_ui (mpz_ptr, unsigned long int);


 void __gmpz_lucnum2_ui (mpz_ptr, mpz_ptr, unsigned long int);


 int __gmpz_millerrabin (mpz_srcptr, int) __attribute__ ((__pure__));


 void __gmpz_mod (mpz_ptr, mpz_srcptr, mpz_srcptr);




 void __gmpz_mul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_mul_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 void __gmpz_mul_si (mpz_ptr, mpz_srcptr, long int);


 void __gmpz_mul_ui (mpz_ptr, mpz_srcptr, unsigned long int);



 void __gmpz_neg (mpz_ptr, mpz_srcptr);



 void __gmpz_nextprime (mpz_ptr, mpz_srcptr);



 size_t __gmpz_out_raw (FILE *, mpz_srcptr);




 size_t __gmpz_out_str (FILE *, int, mpz_srcptr);



 int __gmpz_perfect_power_p (mpz_srcptr) __attribute__ ((__pure__));



 int __gmpz_perfect_square_p (mpz_srcptr) __attribute__ ((__pure__));




 mp_bitcnt_t __gmpz_popcount (mpz_srcptr) __attribute__ ((__pure__));



 void __gmpz_pow_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_powm (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_powm_sec (mpz_ptr, mpz_srcptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_powm_ui (mpz_ptr, mpz_srcptr, unsigned long int, mpz_srcptr);


 int __gmpz_probab_prime_p (mpz_srcptr, int) __attribute__ ((__pure__));


 void __gmpz_random (mpz_ptr, mp_size_t);


 void __gmpz_random2 (mpz_ptr, mp_size_t);


 void __gmpz_realloc2 (mpz_ptr, mp_bitcnt_t);


 mp_bitcnt_t __gmpz_remove (mpz_ptr, mpz_srcptr, mpz_srcptr);


 int __gmpz_root (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rootrem (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_rrandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 mp_bitcnt_t __gmpz_scan0 (mpz_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpz_scan1 (mpz_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 void __gmpz_set (mpz_ptr, mpz_srcptr);


 void __gmpz_set_d (mpz_ptr, double);


 void __gmpz_set_f (mpz_ptr, mpf_srcptr);



 void __gmpz_set_q (mpz_ptr, mpq_srcptr);



 void __gmpz_set_si (mpz_ptr, signed long int);


 int __gmpz_set_str (mpz_ptr, const char *, int);


 void __gmpz_set_ui (mpz_ptr, unsigned long int);


 void __gmpz_setbit (mpz_ptr, mp_bitcnt_t);



 size_t __gmpz_size (mpz_srcptr) __attribute__ ((__pure__));



 size_t __gmpz_sizeinbase (mpz_srcptr, int) __attribute__ ((__pure__));


 void __gmpz_sqrt (mpz_ptr, mpz_srcptr);


 void __gmpz_sqrtrem (mpz_ptr, mpz_ptr, mpz_srcptr);


 void __gmpz_sub (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_sub_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_ui_sub (mpz_ptr, unsigned long int, mpz_srcptr);


 void __gmpz_submul (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_submul_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_swap (mpz_ptr, mpz_ptr) ;


 unsigned long int __gmpz_tdiv_ui (mpz_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpz_tdiv_q (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_q_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_q_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_qr (mpz_ptr, mpz_ptr, mpz_srcptr, mpz_srcptr);


 unsigned long int __gmpz_tdiv_qr_ui (mpz_ptr, mpz_ptr, mpz_srcptr, unsigned long int);


 void __gmpz_tdiv_r (mpz_ptr, mpz_srcptr, mpz_srcptr);


 void __gmpz_tdiv_r_2exp (mpz_ptr, mpz_srcptr, mp_bitcnt_t);


 unsigned long int __gmpz_tdiv_r_ui (mpz_ptr, mpz_srcptr, unsigned long int);


 int __gmpz_tstbit (mpz_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 void __gmpz_ui_pow_ui (mpz_ptr, unsigned long int, unsigned long int);


 void __gmpz_urandomb (mpz_ptr, gmp_randstate_t, mp_bitcnt_t);


 void __gmpz_urandomm (mpz_ptr, gmp_randstate_t, mpz_srcptr);



 void __gmpz_xor (mpz_ptr, mpz_srcptr, mpz_srcptr);






 void __gmpq_abs (mpq_ptr, mpq_srcptr);



 void __gmpq_add (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_canonicalize (mpq_ptr);


 void __gmpq_clear (mpq_ptr);


 void __gmpq_clears (mpq_ptr, ...);


 int __gmpq_cmp (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));


 int __gmpq_cmp_si (mpq_srcptr, long, unsigned long) __attribute__ ((__pure__));


 int __gmpq_cmp_ui (mpq_srcptr, unsigned long int, unsigned long int) __attribute__ ((__pure__));


 void __gmpq_div (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_div_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);


 int __gmpq_equal (mpq_srcptr, mpq_srcptr) __attribute__ ((__pure__));


 void __gmpq_get_num (mpz_ptr, mpq_srcptr);


 void __gmpq_get_den (mpz_ptr, mpq_srcptr);


 double __gmpq_get_d (mpq_srcptr) __attribute__ ((__pure__));


 char *__gmpq_get_str (char *, int, mpq_srcptr);


 void __gmpq_init (mpq_ptr);


 void __gmpq_inits (mpq_ptr, ...);



 size_t __gmpq_inp_str (mpq_ptr, FILE *, int);



 void __gmpq_inv (mpq_ptr, mpq_srcptr);


 void __gmpq_mul (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_mul_2exp (mpq_ptr, mpq_srcptr, mp_bitcnt_t);



 void __gmpq_neg (mpq_ptr, mpq_srcptr);




 size_t __gmpq_out_str (FILE *, int, mpq_srcptr);



 void __gmpq_set (mpq_ptr, mpq_srcptr);


 void __gmpq_set_d (mpq_ptr, double);


 void __gmpq_set_den (mpq_ptr, mpz_srcptr);


 void __gmpq_set_f (mpq_ptr, mpf_srcptr);


 void __gmpq_set_num (mpq_ptr, mpz_srcptr);


 void __gmpq_set_si (mpq_ptr, signed long int, unsigned long int);


 int __gmpq_set_str (mpq_ptr, const char *, int);


 void __gmpq_set_ui (mpq_ptr, unsigned long int, unsigned long int);


 void __gmpq_set_z (mpq_ptr, mpz_srcptr);


 void __gmpq_sub (mpq_ptr, mpq_srcptr, mpq_srcptr);


 void __gmpq_swap (mpq_ptr, mpq_ptr) ;





 void __gmpf_abs (mpf_ptr, mpf_srcptr);


 void __gmpf_add (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_add_ui (mpf_ptr, mpf_srcptr, unsigned long int);

 void __gmpf_ceil (mpf_ptr, mpf_srcptr);


 void __gmpf_clear (mpf_ptr);


 void __gmpf_clears (mpf_ptr, ...);


 int __gmpf_cmp (mpf_srcptr, mpf_srcptr) __attribute__ ((__pure__));


 int __gmpf_cmp_d (mpf_srcptr, double) __attribute__ ((__pure__));


 int __gmpf_cmp_si (mpf_srcptr, signed long int) __attribute__ ((__pure__));


 int __gmpf_cmp_ui (mpf_srcptr, unsigned long int) __attribute__ ((__pure__));


 void __gmpf_div (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_div_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_div_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_dump (mpf_srcptr);


 int __gmpf_eq (mpf_srcptr, mpf_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 int __gmpf_fits_sint_p (mpf_srcptr) __attribute__ ((__pure__));


 int __gmpf_fits_slong_p (mpf_srcptr) __attribute__ ((__pure__));


 int __gmpf_fits_sshort_p (mpf_srcptr) __attribute__ ((__pure__));


 int __gmpf_fits_uint_p (mpf_srcptr) __attribute__ ((__pure__));


 int __gmpf_fits_ulong_p (mpf_srcptr) __attribute__ ((__pure__));


 int __gmpf_fits_ushort_p (mpf_srcptr) __attribute__ ((__pure__));


 void __gmpf_floor (mpf_ptr, mpf_srcptr);


 double __gmpf_get_d (mpf_srcptr) __attribute__ ((__pure__));


 double __gmpf_get_d_2exp (signed long int *, mpf_srcptr);


 mp_bitcnt_t __gmpf_get_default_prec (void) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpf_get_prec (mpf_srcptr) __attribute__ ((__pure__));


 long __gmpf_get_si (mpf_srcptr) __attribute__ ((__pure__));


 char *__gmpf_get_str (char *, mp_exp_t *, int, size_t, mpf_srcptr);


 unsigned long __gmpf_get_ui (mpf_srcptr) __attribute__ ((__pure__));


 void __gmpf_init (mpf_ptr);


 void __gmpf_init2 (mpf_ptr, mp_bitcnt_t);


 void __gmpf_inits (mpf_ptr, ...);


 void __gmpf_init_set (mpf_ptr, mpf_srcptr);


 void __gmpf_init_set_d (mpf_ptr, double);


 void __gmpf_init_set_si (mpf_ptr, signed long int);


 int __gmpf_init_set_str (mpf_ptr, const char *, int);


 void __gmpf_init_set_ui (mpf_ptr, unsigned long int);



 size_t __gmpf_inp_str (mpf_ptr, FILE *, int);



 int __gmpf_integer_p (mpf_srcptr) __attribute__ ((__pure__));


 void __gmpf_mul (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_mul_2exp (mpf_ptr, mpf_srcptr, mp_bitcnt_t);


 void __gmpf_mul_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_neg (mpf_ptr, mpf_srcptr);



 size_t __gmpf_out_str (FILE *, int, size_t, mpf_srcptr);



 void __gmpf_pow_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_random2 (mpf_ptr, mp_size_t, mp_exp_t);


 void __gmpf_reldiff (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_set (mpf_ptr, mpf_srcptr);


 void __gmpf_set_d (mpf_ptr, double);


 void __gmpf_set_default_prec (mp_bitcnt_t) ;


 void __gmpf_set_prec (mpf_ptr, mp_bitcnt_t);


 void __gmpf_set_prec_raw (mpf_ptr, mp_bitcnt_t) ;


 void __gmpf_set_q (mpf_ptr, mpq_srcptr);


 void __gmpf_set_si (mpf_ptr, signed long int);


 int __gmpf_set_str (mpf_ptr, const char *, int);


 void __gmpf_set_ui (mpf_ptr, unsigned long int);


 void __gmpf_set_z (mpf_ptr, mpz_srcptr);


 size_t __gmpf_size (mpf_srcptr) __attribute__ ((__pure__));


 void __gmpf_sqrt (mpf_ptr, mpf_srcptr);


 void __gmpf_sqrt_ui (mpf_ptr, unsigned long int);


 void __gmpf_sub (mpf_ptr, mpf_srcptr, mpf_srcptr);


 void __gmpf_sub_ui (mpf_ptr, mpf_srcptr, unsigned long int);


 void __gmpf_swap (mpf_ptr, mpf_ptr) ;


 void __gmpf_trunc (mpf_ptr, mpf_srcptr);


 void __gmpf_ui_div (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_ui_sub (mpf_ptr, unsigned long int, mpf_srcptr);


 void __gmpf_urandomb (mpf_t, gmp_randstate_t, mp_bitcnt_t);
# 1447 "/usr/include/gmp-x86_64.h" 3 4
 mp_limb_t __gmpn_add (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);




 mp_limb_t __gmpn_add_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) ;



 mp_limb_t __gmpn_add_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_addmul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);



 int __gmpn_cmp (mp_srcptr, mp_srcptr, mp_size_t) __attribute__ ((__pure__));






 mp_limb_t __gmpn_divexact_by3c (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);





 mp_limb_t __gmpn_divrem (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_divrem_1 (mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_limb_t);


 mp_limb_t __gmpn_divrem_2 (mp_ptr, mp_size_t, mp_ptr, mp_size_t, mp_srcptr);


 mp_limb_t __gmpn_div_qr_2 (mp_ptr, mp_ptr, mp_srcptr, mp_size_t, mp_srcptr);


 mp_size_t __gmpn_gcd (mp_ptr, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 mp_limb_t __gmpn_gcd_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_limb_t __gmpn_gcdext_1 (mp_limb_signed_t *, mp_limb_signed_t *, mp_limb_t, mp_limb_t);


 mp_size_t __gmpn_gcdext (mp_ptr, mp_ptr, mp_size_t *, mp_ptr, mp_size_t, mp_ptr, mp_size_t);


 size_t __gmpn_get_str (unsigned char *, int, mp_ptr, mp_size_t);


 mp_bitcnt_t __gmpn_hamdist (mp_srcptr, mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 mp_limb_t __gmpn_lshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_limb_t __gmpn_mod_1 (mp_srcptr, mp_size_t, mp_limb_t) __attribute__ ((__pure__));


 mp_limb_t __gmpn_mul (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_mul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_mul_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_sqr (mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_neg (mp_ptr, mp_srcptr, mp_size_t);




 void __gmpn_com (mp_ptr, mp_srcptr, mp_size_t);



 int __gmpn_perfect_square_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 int __gmpn_perfect_power_p (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_popcount (mp_srcptr, mp_size_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_pow_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t, mp_ptr);



 mp_limb_t __gmpn_preinv_mod_1 (mp_srcptr, mp_size_t, mp_limb_t, mp_limb_t) __attribute__ ((__pure__));


 void __gmpn_random (mp_ptr, mp_size_t);


 void __gmpn_random2 (mp_ptr, mp_size_t);


 mp_limb_t __gmpn_rshift (mp_ptr, mp_srcptr, mp_size_t, unsigned int);


 mp_bitcnt_t __gmpn_scan0 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_bitcnt_t __gmpn_scan1 (mp_srcptr, mp_bitcnt_t) __attribute__ ((__pure__));


 mp_size_t __gmpn_set_str (mp_ptr, const unsigned char *, size_t, int);


 mp_size_t __gmpn_sqrtrem (mp_ptr, mp_ptr, mp_srcptr, mp_size_t);



 mp_limb_t __gmpn_sub (mp_ptr, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);




 mp_limb_t __gmpn_sub_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t) ;



 mp_limb_t __gmpn_sub_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 mp_limb_t __gmpn_submul_1 (mp_ptr, mp_srcptr, mp_size_t, mp_limb_t);


 void __gmpn_tdiv_qr (mp_ptr, mp_ptr, mp_size_t, mp_srcptr, mp_size_t, mp_srcptr, mp_size_t);


 void __gmpn_and_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_andn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nand_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_ior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_iorn_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_nior_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);

 void __gmpn_xnor_n (mp_ptr, mp_srcptr, mp_srcptr, mp_size_t);


 void __gmpn_copyi (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_copyd (mp_ptr, mp_srcptr, mp_size_t);

 void __gmpn_zero (mp_ptr, mp_size_t);
# 1630 "/usr/include/gmp-x86_64.h" 3 4
extern __inline__ void
__gmpz_abs (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = ((__gmp_w->_mp_size) >= 0 ? (__gmp_w->_mp_size) : -(__gmp_w->_mp_size));
}
# 1654 "/usr/include/gmp-x86_64.h" 3 4
extern __inline__

int
__gmpz_fits_uint_p (mpz_srcptr __gmp_z)
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned) 0)));;
}




extern __inline__

int
__gmpz_fits_ulong_p (mpz_srcptr __gmp_z)
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= (~ (unsigned long) 0)));;
}




extern __inline__

int
__gmpz_fits_ushort_p (mpz_srcptr __gmp_z)
{
  mp_size_t __gmp_n = __gmp_z->_mp_size; mp_ptr __gmp_p = __gmp_z->_mp_d; return (__gmp_n == 0 || (__gmp_n == 1 && __gmp_p[0] <= ((unsigned short) ~0)));;
}




extern __inline__

unsigned long
__gmpz_get_ui (mpz_srcptr __gmp_z)
{
  mp_ptr __gmp_p = __gmp_z->_mp_d;
  mp_size_t __gmp_n = __gmp_z->_mp_size;
  mp_limb_t __gmp_l = __gmp_p[0];






  return (__gmp_n != 0 ? __gmp_l : 0);
# 1710 "/usr/include/gmp-x86_64.h" 3 4
}




extern __inline__

mp_limb_t
__gmpz_getlimbn (mpz_srcptr __gmp_z, mp_size_t __gmp_n)
{
  mp_limb_t __gmp_result = 0;
  if (__builtin_expect ((__gmp_n >= 0 && __gmp_n < ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size))) != 0, 1))
    __gmp_result = __gmp_z->_mp_d[__gmp_n];
  return __gmp_result;
}



extern __inline__ void
__gmpz_neg (mpz_ptr __gmp_w, mpz_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpz_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_size = - __gmp_w->_mp_size;
}




extern __inline__

int
__gmpz_perfect_square_p (mpz_srcptr __gmp_a)
{
  mp_size_t __gmp_asize;
  int __gmp_result;

  __gmp_asize = __gmp_a->_mp_size;
  __gmp_result = (__gmp_asize >= 0);
  if (__builtin_expect ((__gmp_asize > 0) != 0, 1))
    __gmp_result = __gmpn_perfect_square_p (__gmp_a->_mp_d, __gmp_asize);
  return __gmp_result;
}




extern __inline__

mp_bitcnt_t
__gmpz_popcount (mpz_srcptr __gmp_u)
{
  mp_size_t __gmp_usize;
  mp_bitcnt_t __gmp_result;

  __gmp_usize = __gmp_u->_mp_size;
  __gmp_result = (__gmp_usize < 0 ? (~ (unsigned long) 0) : 0);
  if (__builtin_expect ((__gmp_usize > 0) != 0, 1))
    __gmp_result = __gmpn_popcount (__gmp_u->_mp_d, __gmp_usize);
  return __gmp_result;
}




extern __inline__

void
__gmpz_set_q (mpz_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  __gmpz_tdiv_q (__gmp_w, (&((__gmp_u)->_mp_num)), (&((__gmp_u)->_mp_den)));
}




extern __inline__

size_t
__gmpz_size (mpz_srcptr __gmp_z)
{
  return ((__gmp_z->_mp_size) >= 0 ? (__gmp_z->_mp_size) : -(__gmp_z->_mp_size));
}






extern __inline__ void
__gmpq_abs (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = ((__gmp_w->_mp_num._mp_size) >= 0 ? (__gmp_w->_mp_num._mp_size) : -(__gmp_w->_mp_num._mp_size));
}



extern __inline__ void
__gmpq_neg (mpq_ptr __gmp_w, mpq_srcptr __gmp_u)
{
  if (__gmp_w != __gmp_u)
    __gmpq_set (__gmp_w, __gmp_u);
  __gmp_w->_mp_num._mp_size = - __gmp_w->_mp_num._mp_size;
}
# 2052 "/usr/include/gmp-x86_64.h" 3 4
extern __inline__

mp_limb_t
__gmpn_add (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_add_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x + 1) & ((~ ((mp_limb_t) (0))) >> 0)) == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__

mp_limb_t
__gmpn_add_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x + (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_r) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x + 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_r) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__

int
__gmpn_cmp (mp_srcptr __gmp_xp, mp_srcptr __gmp_yp, mp_size_t __gmp_size)
{
  int __gmp_result;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_y; (__gmp_result) = 0; __gmp_i = (__gmp_size); while (--__gmp_i >= 0) { __gmp_x = (__gmp_xp)[__gmp_i]; __gmp_y = (__gmp_yp)[__gmp_i]; if (__gmp_x != __gmp_y) { (__gmp_result) = (__gmp_x > __gmp_y ? 1 : -1); break; } } } while (0);
  return __gmp_result;
}




extern __inline__

mp_limb_t
__gmpn_sub (mp_ptr __gmp_wp, mp_srcptr __gmp_xp, mp_size_t __gmp_xsize, mp_srcptr __gmp_yp, mp_size_t __gmp_ysize)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x; __gmp_i = (__gmp_ysize); if (__gmp_i != 0) { if (__gmpn_sub_n (__gmp_wp, __gmp_xp, __gmp_yp, __gmp_i)) { do { if (__gmp_i >= (__gmp_xsize)) { (__gmp_c) = 1; goto __gmp_done; } __gmp_x = (__gmp_xp)[__gmp_i]; } while ((((__gmp_wp)[__gmp_i++] = (__gmp_x - 1) & ((~ ((mp_limb_t) (0))) >> 0)), __gmp_x == 0)); } } if ((__gmp_wp) != (__gmp_xp)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_xsize); __gmp_j++) (__gmp_wp)[__gmp_j] = (__gmp_xp)[__gmp_j]; } while (0); (__gmp_c) = 0; __gmp_done: ; } while (0);
  return __gmp_c;
}




extern __inline__

mp_limb_t
__gmpn_sub_1 (mp_ptr __gmp_dst, mp_srcptr __gmp_src, mp_size_t __gmp_size, mp_limb_t __gmp_n)
{
  mp_limb_t __gmp_c;
  do { mp_size_t __gmp_i; mp_limb_t __gmp_x, __gmp_r; __gmp_x = (__gmp_src)[0]; __gmp_r = __gmp_x - (__gmp_n); (__gmp_dst)[0] = __gmp_r; if (((__gmp_x) < ((__gmp_n)))) { (__gmp_c) = 1; for (__gmp_i = 1; __gmp_i < (__gmp_size);) { __gmp_x = (__gmp_src)[__gmp_i]; __gmp_r = __gmp_x - 1; (__gmp_dst)[__gmp_i] = __gmp_r; ++__gmp_i; if (!((__gmp_x) < (1))) { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (__gmp_i); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; break; } } } else { if ((__gmp_src) != (__gmp_dst)) do { mp_size_t __gmp_j; ; for (__gmp_j = (1); __gmp_j < (__gmp_size); __gmp_j++) (__gmp_dst)[__gmp_j] = (__gmp_src)[__gmp_j]; } while (0); (__gmp_c) = 0; } } while (0);
  return __gmp_c;
}




extern __inline__

mp_limb_t
__gmpn_neg (mp_ptr __gmp_rp, mp_srcptr __gmp_up, mp_size_t __gmp_n)
{
  mp_limb_t __gmp_ul, __gmp_cy;
  __gmp_cy = 0;
  do {
      __gmp_ul = *__gmp_up++;
      *__gmp_rp++ = -__gmp_ul - __gmp_cy;
      __gmp_cy |= __gmp_ul != 0;
  } while (--__gmp_n != 0);
  return __gmp_cy;
}
# 2209 "/usr/include/gmp-x86_64.h" 3 4
enum
{
  GMP_ERROR_NONE = 0,
  GMP_ERROR_UNSUPPORTED_ARGUMENT = 1,
  GMP_ERROR_DIVISION_BY_ZERO = 2,
  GMP_ERROR_SQRT_OF_NEGATIVE = 4,
  GMP_ERROR_INVALID_ARGUMENT = 8
};
# 52 "/usr/include/gmp.h" 2 3 4
# 58 "src/srp.h" 2
# 78 "src/srp.h"
typedef struct {
    gchar *username;
    gchar *username_upper;
    gchar *password_upper;
    guint32 username_len;
    guint32 password_len;

    mpz_t n;
    mpz_t a;

    gmp_randstate_t rand;

    gchar *A;
    gchar *S;
    gchar *K;
    gchar *M1;
    gchar *M2;
    gchar *salt;
    gchar *B;
} srp_t;





srp_t* srp_init(const gchar* username, const gchar* password);






srp_t* srp_init_l(const gchar* username, guint32 username_length,
        const gchar* password, guint32 password_length);




void srp_free(srp_t* srp);






srp_t* srp_reinit(srp_t* srp, const char* username,
        const char* password);






srp_t *srp_reinit_l(srp_t *srp, const gchar *username,
        guint32 username_length, const gchar *password,
        guint32 password_length);




guint32 srp_generate_salt_and_v(srp_t *srp, gchar *out);






void srp_get_S(srp_t* srp, char* out, const char* B, const char* salt);




void srp_get_v(srp_t* srp, char* out, const char* salt);




void srp_get_A(srp_t* srp, char* out);





void srp_get_K(srp_t* srp, char* out, const char* S);






void srp_get_M1(srp_t* srp, char* out, const char* B, const char* salt);
# 177 "src/srp.h"
int srp_check_M2(srp_t* srp, const char* var_M2);
# 187 "src/srp.h"
int srp_check_signature(guint32 address, const char* signature_raw);
# 67 "src/bnet.h" 2
# 1 "src/userdata.h" 1
# 39 "src/userdata.h"
typedef enum {
    BNET_READUSERDATA_REQUEST_NONE = 0x0,
    BNET_READUSERDATA_REQUEST_PROFILE = 0x1,
    BNET_READUSERDATA_REQUEST_RECORD = 0x2,
    BNET_READUSERDATA_REQUEST_SYSTEM = 0x4
} BnetUserDataRequestType;

typedef guint32 BnetProductID;
typedef struct _BnetUserDataRequest BnetUserDataRequest;

void bnet_userdata_request_free(BnetUserDataRequest *req);
BnetUserDataRequest *bnet_userdata_request_new(int cookie, BnetUserDataRequestType type,
                                               const gchar *username, gchar **userdata_keys,
                                               BnetProductID product);
int bnet_userdata_request_get_cookie(const BnetUserDataRequest *req);
gchar *bnet_userdata_request_get_key_by_index(const BnetUserDataRequest *req, int i);
BnetUserDataRequestType bnet_userdata_request_get_type(const BnetUserDataRequest *req);
BnetProductID bnet_userdata_request_get_product(const BnetUserDataRequest *req);
# 68 "src/bnet.h" 2
# 122 "src/bnet.h"
typedef enum {
    BNET_SID_NULL = 0x00,
    BNET_SID_CLIENTID = 0x05,
    BNET_SID_STARTVERSIONING = 0x06,
    BNET_SID_REPORTVERSION = 0x07,
    BNET_SID_ENTERCHAT = 0x0A,
    BNET_SID_GETCHANNELLIST = 0x0B,
    BNET_SID_JOINCHANNEL = 0x0C,
    BNET_SID_CHATCOMMAND = 0x0E,
    BNET_SID_CHATEVENT = 0x0F,
    BNET_SID_LEAVECHAT = 0x10,
    BNET_SID_LOCALEINFO = 0x12,
    BNET_SID_FLOODDETECTED = 0x13,
    BNET_SID_UDPPINGRESPONSE = 0x14,
    BNET_SID_MESSAGEBOX = 0x19,
    BNET_SID_LOGONCHALLENGEEX = 0x1D,
    BNET_SID_CLIENTID2 = 0x1E,
    BNET_SID_PING = 0x25,
    BNET_SID_READUSERDATA = 0x26,
    BNET_SID_WRITEUSERDATA = 0x27,
    BNET_SID_LOGONCHALLENGE = 0x28,
    BNET_SID_SYSTEMINFO = 0x2B,
    BNET_SID_CDKEY = 0x30,
    BNET_SID_W3PROFILE = 0x35,
    BNET_SID_CDKEY2 = 0x36,
    BNET_SID_LOGONRESPONSE2 = 0x3A,
    BNET_SID_CREATEACCOUNT2 = 0x3D,
    BNET_SID_LOGONREALMEX = 0x3E,
    BNET_SID_QUERYREALMS2 = 0x40,
    BNET_SID_W3GENERAL = 0x44,
    BNET_SID_NETGAMEPORT = 0x45,
    BNET_SID_NEWS_INFO = 0x46,
    BNET_SID_OPTIONALWORK = 0x4A,
    BNET_SID_REQUIREDWORK = 0x4C,
    BNET_SID_AUTH_INFO = 0x50,
    BNET_SID_AUTH_CHECK = 0x51,
    BNET_SID_AUTH_ACCOUNTCREATE = 0x52,
    BNET_SID_AUTH_ACCOUNTLOGON = 0x53,
    BNET_SID_AUTH_ACCOUNTLOGONPROOF = 0x54,
    BNET_SID_AUTH_ACCOUNTCHANGE = 0x55,
    BNET_SID_AUTH_ACCOUNTCHANGEPROOF = 0x56,
    BNET_SID_SETEMAIL = 0x59,
    BNET_SID_FRIENDSLIST = 0x65,
    BNET_SID_FRIENDSUPDATE = 0x66,
    BNET_SID_FRIENDSADD = 0x67,
    BNET_SID_FRIENDSREMOVE = 0x68,
    BNET_SID_FRIENDSPOSITION = 0x69,
    BNET_SID_CLANFINDCANDIDATES = 0x70,
    BNET_SID_CLANINVITEMULTIPLE = 0x71,
    BNET_SID_CLANCREATIONINVITATION = 0x72,
    BNET_SID_CLANDISBAND = 0x73,
    BNET_SID_CLANMAKECHIEFTAIN = 0x74,
    BNET_SID_CLANINFO = 0x75,
    BNET_SID_CLANQUITNOTIFY = 0x76,
    BNET_SID_CLANINVITATION = 0x77,
    BNET_SID_CLANREMOVEMEMBER = 0x78,
    BNET_SID_CLANINVITATIONRESPONSE = 0x79,
    BNET_SID_CLANRANKCHANGE = 0x7A,
    BNET_SID_CLANSETMOTD = 0x7B,
    BNET_SID_CLANMOTD = 0x7C,
    BNET_SID_CLANMEMBERLIST = 0x7D,
    BNET_SID_CLANMEMBERREMOVED = 0x7E,
    BNET_SID_CLANMEMBERSTATUSCHANGE = 0x7F,
    BNET_SID_CLANMEMBERRANKCHANGE = 0x81,
    BNET_SID_CLANMEMBERINFO = 0x82,
} BnetPacketID;
# 221 "src/bnet.h"
typedef guint32 BnetDwordTag;


typedef BnetDwordTag BnetProductID;


typedef gint32 BnetVersioningSystem;
# 236 "src/bnet.h"
typedef gint32 BnetLogonSystem;
# 321 "src/bnet.h"
typedef enum {
    BNET_GAME_TYPE_STAR = 0x01,
    BNET_GAME_TYPE_SEXP = 0x02,
    BNET_GAME_TYPE_W2BN = 0x03,
    BNET_GAME_TYPE_D2DV = 0x04,
    BNET_GAME_TYPE_D2XP = 0x05,
    BNET_GAME_TYPE_JSTR = 0x06,
    BNET_GAME_TYPE_WAR3 = 0x07,
    BNET_GAME_TYPE_W3XP = 0x08,
    BNET_GAME_TYPE_DRTL = 0x09,
    BNET_GAME_TYPE_DSHR = 0x0A,
    BNET_GAME_TYPE_SSHR = 0x0B,
} BnetGameType;


typedef enum {
    BNET_BNLS_REQUESTVERSIONBYTE = 0x10,
    BNET_BNLS_VERSIONCHECKEX2 = 0x1A,
    BNET_BNLS_LOGONCHALLENGE = 0x02,
    BNET_BNLS_LOGONPROOF = 0x03,
    BNET_BNLS_CHOOSENLSREVISION = 0x0D,
    BNET_BNLS_MESSAGE = 0xFF
} BnetBnlsPacketID;


typedef enum {
    BNET_CHANNELJOIN_NOCREATE = 0x00000000,
    BNET_CHANNELJOIN_FIRSTJOIN = 0x00000001,
    BNET_CHANNELJOIN_FORCEDJOIN = 0x00000002,
    BNET_CHANNELJOIN_D2FIRST = 0x00000004,
} BnetChannelJoinFlags;


typedef enum {
    BNET_EID_SHOWUSER = 0x00000001,
    BNET_EID_JOIN = 0x00000002,
    BNET_EID_LEAVE = 0x00000003,
    BNET_EID_WHISPER = 0x00000004,
    BNET_EID_TALK = 0x00000005,
    BNET_EID_BROADCAST = 0x00000006,
    BNET_EID_CHANNEL = 0x00000007,
    BNET_EID_USERFLAGS = 0x00000009,
    BNET_EID_WHISPERSENT = 0x0000000A,
    BNET_EID_CHANNELFULL = 0x0000000D,
    BNET_EID_CHANNELDOESNOTEXIST = 0x0000000E,
    BNET_EID_CHANNELRESTRICTED = 0x0000000F,
    BNET_EID_INFO = 0x00000012,
    BNET_EID_ERROR = 0x00000013,
    BNET_EID_EMOTE = 0x00000017
} BnetChatEventID;


typedef enum {
    BNET_USER_FLAG_NONE = 0x00000000,
    BNET_USER_FLAG_BLIZZREP = 0x00000001,
    BNET_USER_FLAG_OP = 0x00000002,
    BNET_USER_FLAG_VOICE = 0x00000004,
    BNET_USER_FLAG_BNETADMIN = 0x00000008,
    BNET_USER_FLAG_NOUDP = 0x00000010,
    BNET_USER_FLAG_SQUELCH = 0x00000020,
    BNET_USER_FLAG_GUEST = 0x00000040,
    BNET_USER_FLAG_BEEP = 0x00000100,

    BNET_CHAN_FLAG_NONE = 0x00000000,
    BNET_CHAN_FLAG_PUBLIC = 0x00000001,
    BNET_CHAN_FLAG_MODERATED = 0x00000002,
    BNET_CHAN_FLAG_RESTRICT = 0x00000004,
    BNET_CHAN_FLAG_SILENT = 0x00000008,
    BNET_CHAN_FLAG_SYSTEM = 0x00000010,
    BNET_CHAN_FLAG_PRODUCT = 0x00000020,
    BNET_CHAN_FLAG_GLOBAL = 0x00001000,
    BNET_CHAN_FLAG_REDIRECT = 0x00004000,
    BNET_CHAN_FLAG_CHAT = 0x00008000,
    BNET_CHAN_FLAG_TECHSPPT = 0x00010000
} BnetChatEventFlags;







typedef struct {
    gint32 type;
    gchar *username;
    gchar data[48];
} BnetUser;



typedef struct {
    guint32 type;
    char *username;
    char *stats_data;
    BnetChatEventFlags flags;
    gint32 ping;
    gboolean hidden;

    char *stats_message;
} BnetChannelUser;


typedef enum {
    BNET_FRIEND_STATUS_ONLINE = 0x00,
    BNET_FRIEND_STATUS_MUTUAL = 0x01,
    BNET_FRIEND_STATUS_DND = 0x02,
    BNET_FRIEND_STATUS_AWAY = 0x04
} BnetFriendStatus;


typedef enum {
    BNET_FRIEND_LOCATION_OFFLINE = 0x00,
    BNET_FRIEND_LOCATION_ONLINE = 0x01,
    BNET_FRIEND_LOCATION_CHANNEL = 0x02,
    BNET_FRIEND_LOCATION_GAME_PUBLIC = 0x03,
    BNET_FRIEND_LOCATION_GAME_PRIVATE = 0x04,
    BNET_FRIEND_LOCATION_GAME_PROTECTED = 0x05
} BnetFriendLocation;



typedef struct {
    guint32 type;

    char *account;

    BnetFriendStatus status;
    BnetFriendLocation location;
    BnetProductID product;
    char *location_name;



    BnetFriendStatus automated_lookup;


    gchar *dnd_stored_status;
    gchar *away_stored_status;

    gboolean on_list;


    PurpleBuddy *buddy;
} BnetFriendInfo;
# 482 "src/bnet.h"
typedef enum {
    BNET_CLAN_RANK_INITIATE = 0,
    BNET_CLAN_RANK_PEON = 1,
    BNET_CLAN_RANK_GRUNT = 2,
    BNET_CLAN_RANK_SHAMAN = 3,
    BNET_CLAN_RANK_CHIEFTAIN = 4,
} BnetClanMemberRank;

typedef enum {
    BNET_CLAN_STATUS_OFFLINE = 0,
    BNET_CLAN_STATUS_ONLINE = 1,
} BnetClanMemberStatus;

typedef struct {

    guint32 type;
    gchar *name;
    BnetClanMemberRank rank;
    BnetClanMemberStatus status;
    gchar *location;

    guint64 join_date;
} BnetClanMember;

typedef BnetDwordTag BnetClanTag;

typedef guint8 BnetClanResponseCode;
# 523 "src/bnet.h"
typedef enum {
    BNET_REALM_SUCCESS = 0x00,

    BNET_REALM_LOGON_UNAVAIL = 0x80000001,
    BNET_REALM_LOGON_BADPW = 0x80000002,


    BNET_REALM_GLIST_AVAIL = 0x04,

    BNET_REALM_GLIST_UNAVAIL = 0xFFFFFFFF,


    BNET_REALM_CHAR_EXISTS = 0x14,

    BNET_REALM_CHAR_BADNAME = 0x15,

    BNET_REALM_CHAR_PDNE = 0x46,

    BNET_REALM_CHARDEL_DNE = 0x49,

    BNET_REALM_CHAR_FAILED = 0x7A,

    BNET_REALM_CHAR_EXPIRED = 0x7B,

    BNET_REALM_CHARUP_ALREADY = 0x7C,


    BNET_REALM_GAME_BADNAME = 0x1E,

    BNET_REALM_GAME_EXISTS = 0x1F,

    BNET_REALM_GAME_UNAVAIL = 0x20,

    BNET_REALM_GAME_BADPW = 0x29,

    BNET_REALM_GAME_DNE = 0x2A,

    BNET_REALM_GAME_FULL = 0x2B,

    BNET_REALM_GAME_LEVEL = 0x2C,

    BNET_REALM_GAME_DEADHC = 0x6E,

    BNET_REALM_GAME_NOTHC = 0x71,

    BNET_REALM_GAME_NOTNM = 0x73,

    BNET_REALM_GAME_NOTHELL = 0x74,

    BNET_REALM_GAME_NOTXP = 0x78,

    BNET_REALM_GAME_NOTDV = 0x79,

    BNET_REALM_GAME_NOTL = 0x7D,


    BNET_REALM_CONNECT_NOBNCS2 = 0x02,

    BNET_REALM_CONNECT_NOBNCS10 = 0x0A,

    BNET_REALM_CONNECT_NOBNCS11 = 0x0B,

    BNET_REALM_CONNECT_NOBNCS12 = 0x0C,

    BNET_REALM_CONNECT_NOBNCS13 = 0x0D,

    BNET_REALM_CONNECT_KEYBAN = 0x7E,

    BNET_REALM_CONNECT_TEMPBAN = 0x7F,
} BnetRealmStatus;


typedef enum {
    BNET_D2MCP_STARTUP = 0x01,
    BNET_D2MCP_CHARLOGON = 0x07,
    BNET_D2MCP_MOTD = 0x12,
    BNET_D2MCP_CHARLIST2 = 0x19,
} BnetD2RealmPacketID;

typedef struct {
    guint32 up;
    gchar *name;
    gchar *descr;
} BnetD2RealmServer;

typedef struct {
    guint32 expires;
    gchar *name;
    gchar *stats;
} BnetD2RealmCharacter;

typedef enum {
    BNET_WID_USERRECORD = 0x04,
    BNET_WID_CLANRECORD = 0x08,
} BnetW3GeneralSubcommand;
# 635 "src/bnet.h"
typedef guint32 BnetW3RecordType;

typedef enum {

    BNET_LOOKUP_INFO_NONE = 0x00000000,

    BNET_LOOKUP_INFO_CANCELLED = 0x00000001,







    BNET_LOOKUP_INFO_AWAIT_WHOIS_STATUSES_AWAY = 0x00000100,
    BNET_LOOKUP_INFO_AWAIT_WHOIS_STATUSES_DND = 0x00000200,

    BNET_LOOKUP_INFO_AWAIT_WHOIS_STATUSES = 0x00000300,

    BNET_LOOKUP_INFO_AWAIT_WHOIS = 0x00000400,

    BNET_LOOKUP_INFO_AWAIT_USER_DATA = 0x00000800,

    BNET_LOOKUP_INFO_AWAIT_W3_USER_PROFILE = 0x00001000,

    BNET_LOOKUP_INFO_AWAIT_W3_USER_STATS = 0x00002000,

    BNET_LOOKUP_INFO_AWAIT_W3_CLAN_STATS = 0x00004000,

    BNET_LOOKUP_INFO_AWAIT_W3_CLAN_MI = 0x00008000,

    BNET_LOOKUP_INFO_AWAIT_MASK = 0x0000fff0,

    BNET_LOOKUP_INFO_FIRST_SECTION = 0x00010000,

    BNET_LOOKUP_INFO_FOUND_LOCPROD = 0x00100000,

    BNET_LOOKUP_INFO_FOUND_W3_CLAN = 0x00200000,
} BnetLookupInfoFlags;

typedef struct {
    guint32 timestamp;
    gchar *message;
} BnetNewsItem;

typedef struct {
    gchar *name;
    gchar *subname;
    gchar *message;
} BnetMotdItem;

struct BnetPacketCookieKey {
    guint8 packet_id;
    guint32 cookie;
};
# 707 "src/bnet.h"
struct SocketData {

    int fd;

    int prpl_input_watcher;

 gchar *inbuf;

    guint16 inbuf_length;

    guint16 inbuf_used;

    PurpleProxyConnectData *prpl_conn_data;

    gchar *server;

    guint16 port;
};


typedef struct {
    int magic;

    PurpleAccount *account;


    struct {

        struct SocketData conn;


        struct {
            BnetVersioningSystem type;
            gboolean complete;
            BnetProductID product;
            guint32 version_code;
            BnetGameType game_type;
            gchar *key_owner;
        } versioning;


        struct {
            BnetLogonSystem type;
            gboolean create_account;
            guint32 client_cookie;
            guint32 server_cookie;
            guint32 session_cookie;
            gchar *username;
            srp_t *auth_ctx;
            srp_t *auth_ctx_pending;
            guint lockout_timer_handle;
            PurpleRequestFields *prpl_setemail_fields_handle;
        } logon;


        struct {
            gboolean is_online;
            gboolean sent_enter_channel;
            gboolean first_join;
            gchar *unique_name;
            gchar *stats;
            const gchar *d2_star;
            guint updatelist_timer_tick;
            guint updatelist_timer_handle;

            GList *channel_list;
            PurpleRoomlist *prpl_room_list_handle;
            PurpleConversation *prpl_last_cmd_conv_handle;
            GHashTable *packet_cookie_table;
        } chat_env;


        BnetMotdItem motds[6];


        struct {
            guint32 latest;
            guint32 item_count;
            GList *item_list;
        } news;


        struct {
            gboolean seen_self;
            gboolean got_motd;
            gchar *name_pending;
            gchar *name;
            BnetChatEventFlags flags;
            GList *user_list;
            int prpl_chat_id;
            guint join_timer_handle;
        } channel;


        struct {
            gchar *last_sent_to;
            gboolean awaiting_confirm;
        } whisper;


        struct {
            GList *list;
        } friends;


        struct {
            BnetFriendStatus status;
            BnetFriendStatus status_pending;
            gchar *away_msg;
            gchar *dnd_msg;
        } status;


        struct {
            gchar *name;
            BnetLookupInfoFlags flags;
            BnetClanTag w3_tag;
            PurpleNotifyUserInfo *prpl_notify_handle;
        } lookup_info;


        struct {
            gboolean writing_profile;
            GList *requests;
            PurpleRequestFields *prpl_profile_fields_handle;
        } user_data;


        struct {
            gboolean in_clan;
            gboolean clan_members_in_blist;
            BnetClanTag my_clantag;
            gchar *my_clanname;
            GList *my_clanmembers;
            BnetClanMemberRank my_rank;
            PurpleRequestFields *prpl_setmotd_fields_handle;
        } w3_clan;
    } bncs;


    struct {

        struct SocketData conn;
    } bnls;


    struct {

        struct SocketData conn;


        guint32 logon_data[16];


        BnetD2RealmServer realm;


        BnetD2RealmCharacter character;


        gboolean on_character;


        PurpleRequestFields *prpl_realmlist_fields_handle;

        PurpleRequestFields *prpl_charlist_fields_handle;
    } d2mcp;
} BnetConnectionData;

typedef struct {
    BnetConnectionData *bnet;
    BnetPacketID packet_id;
    gint32 cookie;
    BnetClanTag clan_tag;
    gchar *inviter;
    gchar *clan_name;
} BnetClanInvitationCallbackData;


typedef enum {
    BNET_CMD_NONE = 0,
    BNET_CMD_AWAY,
    BNET_CMD_BAN,
    BNET_CMD_BEEP,
    BNET_CMD_CLAN,
    BNET_CMD_DESIGNATE,
    BNET_CMD_DND,
    BNET_CMD_EMOTE,
    BNET_CMD_FRIENDS,
    BNET_CMD_HELP,
    BNET_CMD_JOIN,
    BNET_CMD_KICK,
    BNET_CMD_MAIL,
    BNET_CMD_NOBEEP,
    BNET_CMD_OPTIONS,
    BNET_CMD_REJOIN,
    BNET_CMD_SQUELCH,
    BNET_CMD_STATS,
    BNET_CMD_TIME,
    BNET_CMD_UNBAN,
    BNET_CMD_UNSQUELCH,
    BNET_CMD_USERS,
    BNET_CMD_WHISPER,
    BNET_CMD_WHO,
    BNET_CMD_WHOIS,
    BNET_CMD_WHOAMI,
} BnetCommandID;

typedef enum {

    BNET_CMD_FLAG_PRPLCONTINUE = 0x1,


    BNET_CMD_FLAG_WHISPERPRPLCONTINUE = 0x2,


    BNET_CMD_FLAG_STAROND2 = 0x4,

    BNET_CMD_FLAG_INFORESPONSE = 0x8,

    BNET_CMD_FLAG_PRPL = 0x10,
} BnetCommandFlag;

struct BnetCommand {
    BnetCommandID id;
    BnetCommandFlag bnetflags;
    char *name;
    char *args;
    char *helptext;
} bnet_cmds[] = {
    { BNET_CMD_HELP, BNET_CMD_FLAG_PRPLCONTINUE | BNET_CMD_FLAG_INFORESPONSE, "help", "s",
            "help [topic]:  Request help from Battle.net on the specified topic." },
    { BNET_CMD_HELP, BNET_CMD_FLAG_INFORESPONSE, "?", "s",
            "? [topic]:  Request help from Battle.net on the specified topic." },
    { BNET_CMD_AWAY, BNET_CMD_FLAG_INFORESPONSE, "away", "s",
            "away [message]:  Set your away status to message (clear your away status by providing no message)." },
    { BNET_CMD_DND, BNET_CMD_FLAG_INFORESPONSE, "dnd", "s",
            "dnd [message]:  Set your do-not-disturb status to message (clear your do-not-disturb status by providing no message). You cannot recieve messages in this state." },
    { BNET_CMD_JOIN, 0, "channel", "s",
            "channel &lt;channel&gt;:  Join the specified channel." },
    { BNET_CMD_JOIN, 0, "join", "s",
            "join &lt;channel&gt;:  Join the specified channel." },
    { BNET_CMD_JOIN, 0, "j", "s",
            "j &lt;channel&gt;:  Join the specified channel." },
    { BNET_CMD_EMOTE, BNET_CMD_FLAG_WHISPERPRPLCONTINUE, "emote", "s",
            "emote &lt;action&gt;:  Send an IRC style action to a chat." },
    { BNET_CMD_EMOTE, BNET_CMD_FLAG_WHISPERPRPLCONTINUE, "me", "s",
            "me &lt;action&gt;:  Send an IRC style action to a chat." },
    { BNET_CMD_FRIENDS, BNET_CMD_FLAG_INFORESPONSE, "friends", "ws",
            "friends &lt;action&gt; [options]:  Perform a friends-list action (list, add &lt;user&gt;, remove &lt;user&gt;, msg &lt;message&gt;, promote &lt;user&gt;, demote &lt;user&gt;)." },
    { BNET_CMD_FRIENDS, BNET_CMD_FLAG_INFORESPONSE, "f", "ws",
            "f &lt;action&gt; [options]:  Perform a friends-list action (list, add &lt;user&gt;, remove &lt;user&gt;, msg &lt;message&gt;, promote &lt;user&gt;, demote &lt;user&gt;)." },
    { BNET_CMD_OPTIONS, BNET_CMD_FLAG_INFORESPONSE, "options", "w",
            "options &lt;option&gt;:  Change a messaging setting." },
    { BNET_CMD_OPTIONS, BNET_CMD_FLAG_INFORESPONSE, "o", "w",
            "o &lt;option&gt;:  Change a messaging setting." },
    { BNET_CMD_SQUELCH, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "squelch", "w",
            "squelch &lt;user&gt;:  Block messages from the specified user." },
    { BNET_CMD_SQUELCH, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "ignore", "w",
            "ignore &lt;user&gt;:  Block messages from the specified user." },
    { BNET_CMD_UNSQUELCH, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "unsquelch", "w",
            "unsquelch &lt;user&gt;:  Unblock messages from the specified user." },
    { BNET_CMD_UNSQUELCH, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "unignore", "w",
            "unignore &lt;user&gt;:  Unblock messages from the specified user." },
    { BNET_CMD_WHISPER, BNET_CMD_FLAG_STAROND2, "whisper", "ws",
            "whisper &lt;user&gt; &lt;message&gt;:  Send a private message, aka a whisper." },
    { BNET_CMD_WHISPER, BNET_CMD_FLAG_STAROND2, "w", "ws",
            "w &lt;user&gt; &lt;message&gt;:  Send a private message, aka a whisper." },
    { BNET_CMD_WHISPER, BNET_CMD_FLAG_STAROND2, "msg", "ws",
            "msg &lt;user&gt; &lt;message&gt;:  Send a private message, aka a whisper." },
    { BNET_CMD_WHISPER, BNET_CMD_FLAG_STAROND2, "m", "ws",
            "m &lt;user&gt; &lt;message&gt;:  Send a private message, aka a whisper." },
    { BNET_CMD_WHO, BNET_CMD_FLAG_INFORESPONSE, "who", "s",
            "who &lt;channel&gt;:  Display the list of users in a channel." },
    { BNET_CMD_WHOIS, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "whois", "w",
            "whois &lt;user&gt;:  Display where a user is on Battle.net." },
    { BNET_CMD_WHOIS, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "whereis", "w",
            "whereis &lt;user&gt;:  Display where a user is on Battle.net." },
    { BNET_CMD_WHOIS, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "where", "w",
            "where &lt;user&gt;:  Display where a user is on Battle.net." },
    { BNET_CMD_WHOAMI, BNET_CMD_FLAG_INFORESPONSE, "whoami", "",
            "whoami:  Displays where you are on Battle.net." },
    { BNET_CMD_BAN, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "ban", "ws",
            "ban &lt;user&gt; &lt;message&gt;: Remove a user from the channel, and prevent him/her from returning." },
    { BNET_CMD_UNBAN, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "unban", "w",
            "unban &lt;user&gt;: Allow a banned user to return." },
    { BNET_CMD_KICK, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "kick", "ws",
            "kick &lt;user&gt; &lt;message&gt;: Remove a user from the channel." },
    { BNET_CMD_DESIGNATE, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "designate", "w",
            "designate &lt;user&gt;:  Select the specified user to be your \"heir\", where when you lose operator status, he/she will get it automatically." },
    { BNET_CMD_REJOIN, 0, "rejoin", "",
            "rejoin:  Resign your operator status (Warcraft III clan officers will regain it immediately after)." },
    { BNET_CMD_REJOIN, 0, "resign", "",
            "resign:  Resign your operator status (Warcraft III clan officers will regain it immediately after)." },
    { BNET_CMD_CLAN, BNET_CMD_FLAG_INFORESPONSE, "clan", "ws",
            "clan &lt;action&gt; [options]:  Perform a Warcraft III clan action (public, private, mail <message>, motd <message>)." },
    { BNET_CMD_CLAN, BNET_CMD_FLAG_INFORESPONSE, "c", "ws",
            "c &lt;action&gt; [options]:  Perform a Warcraft III clan action (public, private, mail <message>, motd <message>)." },
    { BNET_CMD_TIME, BNET_CMD_FLAG_INFORESPONSE, "time", "",
            "time:  Display the Battle.net and local time." },
    { BNET_CMD_USERS, BNET_CMD_FLAG_PRPLCONTINUE | BNET_CMD_FLAG_INFORESPONSE, "users", "",
            "users:  Display the number of users on Battle.net." },
    { BNET_CMD_STATS, BNET_CMD_FLAG_INFORESPONSE, "stats", "ww",
            "stats &lt;user&gt; [product]:  Display a user's game statistics, with an optionally specified product code." },
    { BNET_CMD_STATS, BNET_CMD_FLAG_INFORESPONSE, "astat", "ww",
            "astat &lt;user&gt; [product]:  Display a user's game statistics, with an optionally specified product code." },
    { BNET_CMD_MAIL, BNET_CMD_FLAG_STAROND2 | BNET_CMD_FLAG_INFORESPONSE, "mail", "ws",
            "mail &lt;user&gt; &lt;message&gt;:  Send a message to the specified user's e-mail. They will not receive it unless they want to." },
    { BNET_CMD_BEEP, BNET_CMD_FLAG_INFORESPONSE, "beep", "",
            "beep:  (no text-bots exist anymore) Enable beep characters for text bots." },
    { BNET_CMD_NOBEEP, BNET_CMD_FLAG_INFORESPONSE, "nobeep", "",
            "nobeep:  (no text-bots exist anymore) Disable beep characters for text bots." },
    { 0, 0, ((void *)0), ((void *)0), ((void *)0) }
};

static void bnet_channel_user_free(BnetChannelUser *bcu);
static void bnet_friend_info_free(BnetFriendInfo *bfi);
static void bnet_user_free(BnetUser *bu);
static void bnet_buddy_free(PurpleBuddy *buddy);
static void bnet_news_item_free(BnetNewsItem *item);
static void bnet_connect(PurpleAccount *account, const gboolean do_register);
static void bnet_login(PurpleAccount *account);
static void bnet_bnls_login_cb(gpointer data, gint source, const gchar *error_message);
static int bnet_bnls_send_LOGONCHALLENGE(const BnetConnectionData *bnet);
static int bnet_bnls_send_VERSIONCHECKEX2(const BnetConnectionData *bnet,
            guint32 login_type, guint32 server_cookie, guint32 session_cookie,
            guint64 mpq_ft, char *mpq_fn, char *checksum_formula);
static int bnet_bnls_send_REQUESTVERSIONBYTE(BnetConnectionData *bnet);
static void bnet_bnls_input_cb(gpointer data, gint source, PurpleInputCondition cond);
static void bnet_bnls_read_input(BnetConnectionData *bnet, int len);
static void bnet_bnls_recv_CHOOSENLSREVISION(const BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_bnls_recv_LOGONCHALLENGE(const BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_bnls_recv_LOGONPROOF(const BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_bnls_recv_REQUESTVERSIONBYTE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_bnls_recv_VERSIONCHECKEX2(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_bnls_parse_packet(BnetConnectionData *bnet, const guint8 packet_id,
            const gchar *packet_start, const guint16 packet_len);
static void bnet_realm_login_cb(gpointer data, gint source, const gchar *error_message);
static gboolean bnet_realm_protocol_begin(const BnetConnectionData *bnet);
static int bnet_realm_send_STARTUP(const BnetConnectionData *bnet);
static void bnet_realm_input_cb(gpointer data, gint source, PurpleInputCondition cond);
static void bnet_realm_read_input(BnetConnectionData *bnet, int len);
static void bnet_realm_parse_packet(BnetConnectionData *bnet, const guint8 packet_id,
            const gchar *packet_start, const guint16 packet_len);
static void bnet_login_cb(gpointer data, gint source, const gchar *error_message);
static gboolean bnet_protocol_telnet_begin(const BnetConnectionData *bnet);
static gboolean bnet_protocol_begin(const BnetConnectionData *bnet);
static int bnet_send_telnet_line(const BnetConnectionData *bnet, const char *line);
static int bnet_send_protocol_byte(int byte, int fd);
static int bnet_send_NULL(const BnetConnectionData *bnet);
static int bnet_send_STARTVERSIONING(const BnetConnectionData *bnet);
static int bnet_send_REPORTVERSION(const BnetConnectionData *bnet,
            guint32 exe_version, guint32 exe_checksum, char *exe_info);
static int bnet_send_ENTERCHAT(const BnetConnectionData *bnet);
static int bnet_send_GETCHANNELLIST(const const BnetConnectionData *bnet);
static int bnet_send_JOINCHANNEL(const BnetConnectionData *bnet,
            BnetChannelJoinFlags channel_flags, char *channel);
static int bnet_send_CHATCOMMAND(const BnetConnectionData *bnet, const char *command);
static int bnet_send_CDKEY(const BnetConnectionData *bnet);
static int bnet_send_CDKEY2(const BnetConnectionData *bnet);
static int bnet_send_LOGONRESPONSE2(const BnetConnectionData *bnet);
static int bnet_send_CREATEACCOUNT2(const BnetConnectionData *bnet);
static int bnet_send_LOCALEINFO(const BnetConnectionData *bnet);
static int bnet_send_CLIENTID2(const BnetConnectionData *bnet);
static int bnet_send_CLIENTID(const BnetConnectionData *bnet);
static int bnet_send_SYSTEMINFO(const BnetConnectionData *bnet);
static int bnet_send_PING(const BnetConnectionData *bnet, guint32 cookie);
static int bnet_send_READUSERDATA(const BnetConnectionData *bnet,
            int request_cookie, const char *username, char **keys);
static int bnet_send_WRITEUSERDATA(const BnetConnectionData *bnet,
            const char *sex, const char *age, const char *location, const char *description);
static int bnet_send_NEWS_INFO(const BnetConnectionData *bnet, guint32 timestamp);
static int bnet_send_AUTH_INFO(const BnetConnectionData *bnet);
static int bnet_send_AUTH_CHECK(const BnetConnectionData *bnet,
            guint32 exe_version, guint32 exe_checksum, char *exe_info);
static int bnet_send_AUTH_ACCOUNTCREATE(const BnetConnectionData *bnet, char *salt_and_v);
static int bnet_send_AUTH_ACCOUNTLOGON(const BnetConnectionData *bnet, char *A);
static int bnet_send_AUTH_ACCOUNTLOGONPROOF(const BnetConnectionData *bnet, char *M1);
static int bnet_send_SETEMAIL(const BnetConnectionData *bnet, const char *email);
static int bnet_send_FRIENDSLIST(const BnetConnectionData *bnet);
static int bnet_send_CLANCREATIONINVITATION(const BnetConnectionData *bnet, const int cookie,
            const BnetClanTag clan_tag, const gchar *inviter_name, gboolean accept);
static int bnet_send_CLANINVITATIONRESPONSE(const BnetConnectionData *bnet, const int cookie,
            const BnetClanTag clan_tag, const gchar *inviter_name, gboolean accept);
static int bnet_send_CLANSETMOTD(const BnetConnectionData *bnet, const int cookie, const gchar *motd);
static int bnet_send_CLANMOTD(const BnetConnectionData *bnet, const int cookie);
static int bnet_send_CLANMEMBERLIST(const BnetConnectionData *bnet, const int cookie);
static void bnet_input_cb(gpointer data, gint source, PurpleInputCondition cond);
static void bnet_read_telnet_input(BnetConnectionData *bnet, int len);
static void bnet_read_input(BnetConnectionData *bnet, int len);
static void bnet_recv_STARTVERSIONING(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_REPORTVERSION(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_ENTERCHAT(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_GETCHANNELLIST(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CHATEVENT(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_MESSAGEBOX(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_LOGONCHALLENGEEX(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_PING(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_READUSERDATA(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_LOGONCHALLENGE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CDKEY(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CDKEY2(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_NEWS_INFO(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_AUTH_INFO(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_AUTH_CHECK(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_AUTH_ACCOUNTCREATE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_AUTH_ACCOUNTLOGON(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_AUTH_ACCOUNTLOGONPROOF(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_SETEMAIL(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_LOGONRESPONSE2(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CREATEACCOUNT2(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_FRIENDSLIST(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_FRIENDSUPDATE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_FRIENDSADD(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_FRIENDSREMOVE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_FRIENDSPOSITION(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANFINDCANDIDATES(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANINVITEMULTIPLE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANCREATIONINVITATION(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANDISBAND(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANMAKECHIEFTAIN(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANINFO(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANQUITNOTIFY(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANINVITATION(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANREMOVEMEMBER(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANINVITATIONRESPONSE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANRANKCHANGE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANMOTD(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANMEMBERLIST(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANMEMBERREMOVED(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANMEMBERSTATUSCHANGE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANMEMBERRANKCHANGE(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_CLANMEMBERINFO(BnetConnectionData *bnet, BnetPacket *pkt);
static void bnet_recv_event_SHOWUSER(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_JOIN(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_LEAVE(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_WHISPER(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_TALK(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_BROADCAST(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_CHANNEL(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_USERFLAGS(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_WHISPERSENT(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_CHANNELFULL(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_CHANNELDOESNOTEXIST(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_CHANNELRESTRICTED(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static gboolean bnet_recv_event_INFO_whois(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static gboolean bnet_recv_event_INFO_away_response(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static gboolean bnet_recv_event_INFO_dnd_response(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static gboolean bnet_recv_event_INFO_away_state(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static gboolean bnet_recv_event_INFO_dnd_state(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static gboolean bnet_recv_event_INFO_dnd_error(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static gboolean bnet_recv_event_INFO_ban(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static void bnet_recv_event_INFO(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_ERROR(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static void bnet_recv_event_EMOTE(BnetConnectionData *bnet, PurpleConvChat *chat,
            const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping);
static gboolean bnet_parse_telnet_line_event(BnetConnectionData *bnet, GRegex *regex,
            const gchar *text, GMatchInfo *mi);
static void bnet_parse_telnet_line(BnetConnectionData *bnet, const gchar *line);
static void bnet_parse_packet(BnetConnectionData *bnet, const guint8 packet_id,
            const gchar *packet_start, const guint16 packet_len);
static void bnet_account_register(PurpleAccount *account);
static void bnet_account_chpw(PurpleConnection *gc, const char *oldpass, const char *newpass);
static void bnet_account_logon(BnetConnectionData *bnet);
static void bnet_enter_channel(const BnetConnectionData *bnet);
static void bnet_realm_logon_cb(BnetConnectionData *bnet);
static void bnet_enter_chat(BnetConnectionData *bnet);
static int bnet_realm_logon(const BnetConnectionData *bnet, const guint32 client_cookie,
            const gchar *realm_name, const gchar *realm_pass);
static void bnet_entered_chat(BnetConnectionData *bnet);
static void bnet_realm_character_list(BnetConnectionData *bnet, GList *char_list);
static void bnet_realm_server_list(BnetConnectionData *bnet, GList *server_list);
static gboolean bnet_updatelist_timer(BnetConnectionData *bnet);
static void bnet_account_lockout_set(BnetConnectionData *bnet);
static void bnet_account_lockout_cancel(BnetConnectionData *bnet);
static gboolean bnet_account_lockout_timer(BnetConnectionData *bnet);
static void bnet_request_set_email_cb(gpointer data);
static void bnet_request_set_email(BnetConnectionData *bnet, gboolean nomatch_error);
static void bnet_clan_invite_accept_cb(void *data, int act_index);
static void bnet_clan_invite_decline_cb(void *data, int act_index);
static gint bnet_channel_user_compare(gconstpointer a, gconstpointer b);
static PurpleCmdRet bnet_handle_cmd(PurpleConversation *conv, const gchar *cmdword,
            gchar **args, gchar **error, void *data);
static double bnet_get_tz_bias(void);
static char *bnet_format_time(guint64 unixtime);
static char *bnet_format_filetime_string(char *ftime_str);
static char *bnet_format_filetime(guint64 filetime);
static guint64 bnet_get_filetime(time_t time);
static char *bnet_format_strsec(char *secs_str);
static char *bnet_to_utf8_crlf(const char *input);
static char *bnet_utf8_to_iso88951(const char *input);
static gchar *bnet_escape_text(const gchar *text, int length, gboolean replace_linebreaks);
static void bnet_find_detached_buddies(BnetConnectionData *bnet);
static void bnet_do_whois(const BnetConnectionData *bnet, const char *who);
static void bnet_friend_update(const BnetConnectionData *bnet, int index,
            BnetFriendInfo *bfi, BnetFriendStatus status,
            BnetFriendLocation location, BnetProductID product_id,
            const gchar *location_name);
static void bnet_close(PurpleConnection *gc);
static int bnet_send_raw(PurpleConnection *gc, const char *buf, int len);
static int bnet_send_whisper(PurpleConnection *gc, const char *who,
            const char *message, PurpleMessageFlags flags);
static void bnet_lookup_info(PurpleConnection *gc, const char *who);
static void bnet_lookup_info_close(gpointer user_data);
static gboolean bnet_lookup_info_cached_channel(BnetConnectionData *bnet);
static gboolean bnet_lookup_info_cached_friends(BnetConnectionData *bnet);
static gboolean bnet_lookup_info_cached_clan(BnetConnectionData *bnet);
static void bnet_lookup_info_whois(BnetConnectionData *bnet);
static void bnet_lookup_info_user_data(BnetConnectionData *bnet);
static void bnet_lookup_info_w3_user_profile(BnetConnectionData *bnet);
static void bnet_lookup_info_w3_user_stats(BnetConnectionData *bnet);
static void bnet_lookup_info_w3_clan_stats(BnetConnectionData *bnet);
static void bnet_lookup_info_w3_clan_mi(BnetConnectionData *bnet);
static void bnet_action_set_motd_cb(gpointer data);
static gint bnet_news_item_sort(gconstpointer a, gconstpointer b);
static void bnet_news_save(BnetConnectionData *bnet);
static void bnet_news_load(BnetConnectionData *bnet);
static void bnet_action_show_news(PurplePluginAction *action);
static void bnet_action_set_motd(PurplePluginAction *action);
static void bnet_action_set_user_data(PurplePluginAction *action);
static void bnet_profile_get_for_edit(BnetConnectionData *bnet);
static void bnet_profile_show_write_dialog(BnetConnectionData *bnet,
            const char *psex, const char *page, const char *ploc, const char *pdescr);
static void bnet_profile_write_cb(gpointer data);
static GHashTable *bnet_chat_info_defaults(PurpleConnection *gc, const char *chat_name);
static GList *bnet_chat_info(PurpleConnection *gc);
static char *bnet_channel_message_parse(char *stats_data, BnetChatEventFlags flags, int ping);
static PurpleConvChatBuddyFlags bnet_channel_flags_to_prpl_flags(BnetChatEventFlags flags);
static void bnet_join_chat(PurpleConnection *gc, GHashTable *components);
static int bnet_chat_im(PurpleConnection *gc, int chat_id, const char *message, PurpleMessageFlags flags);
static const char *bnet_list_icon(PurpleAccount *a, PurpleBuddy *b);
static const char *bnet_list_emblem(PurpleBuddy *b);
static char *bnet_status_text(PurpleBuddy *b);
static void bnet_tooltip_text(PurpleBuddy *buddy, PurpleNotifyUserInfo *info,
            gboolean full);
static char *bnet_get_location_text(BnetFriendLocation location, char *location_name);
static char *bnet_get_product_name(BnetProductID product);
static gchar *bnet_get_product_id_str(BnetProductID product);
static GList *bnet_status_types(PurpleAccount *account);
static void bnet_add_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group);
static void bnet_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group);
static PurpleRoomlist *bnet_roomlist_get_list(PurpleConnection *gc);
static void bnet_roomlist_cancel(PurpleRoomlist *list);
static void bnet_set_status(PurpleAccount *account, PurpleStatus *status);
static void bnet_set_away(BnetConnectionData *bnet, gboolean new_state, const gchar *message);
static void bnet_set_dnd(BnetConnectionData *bnet, gboolean new_state, const gchar *message);
static const char *bnet_normalize(const PurpleAccount *account, const char *in);
static const char *bnet_d2_normalize(const PurpleAccount *account, const char *in);
static const char *bnet_d2_get_character(const PurpleAccount *account, const char *in);
static const char *bnet_d2_get_realm(const PurpleAccount *account, const char *in);
static const char *bnet_account_normalize(const PurpleAccount *account, const char *in);
static const char *bnet_gateway_normalize(const PurpleAccount *account, const char *in);
static gboolean bnet_is_d2(const BnetConnectionData *bnet);
static gboolean bnet_is_w3(const BnetConnectionData *bnet);
static BnetVersioningSystem bnet_get_versioningsystem(const BnetConnectionData *bnet);
static int bnet_get_key_count(const BnetConnectionData *bnet);
static GList *bnet_actions(PurplePlugin *plugin, gpointer context);
static void init_plugin(PurplePlugin *plugin);

typedef void (*BnetChatEventFunction)(BnetConnectionData *, PurpleConvChat *, const gchar *,
        const gchar *, BnetChatEventFlags, gint32);

struct BnetChatEvent {
    BnetChatEventID id;
    BnetChatEventFunction fn;
    gboolean text_is_statstring;
} bnet_events[] = {
    { 0, ((void *)0), (0) },
    { BNET_EID_SHOWUSER, bnet_recv_event_SHOWUSER, (!(0)) },
    { BNET_EID_JOIN, bnet_recv_event_JOIN, (!(0)) },
    { BNET_EID_LEAVE, bnet_recv_event_LEAVE, (!(0)) },
    { BNET_EID_WHISPER, bnet_recv_event_WHISPER, (0) },
    { BNET_EID_TALK, bnet_recv_event_TALK, (0) },
    { BNET_EID_BROADCAST, bnet_recv_event_BROADCAST, (0) },
    { BNET_EID_CHANNEL, bnet_recv_event_CHANNEL, (0) },
    { 0, ((void *)0), (0) },
    { BNET_EID_USERFLAGS, bnet_recv_event_USERFLAGS, (!(0)) },
    { BNET_EID_WHISPERSENT, bnet_recv_event_WHISPERSENT, (0) },
    { 0, ((void *)0), (0) },
    { 0, ((void *)0), (0) },
    { BNET_EID_CHANNELFULL, bnet_recv_event_CHANNELFULL, (0) },
    { BNET_EID_CHANNELDOESNOTEXIST, bnet_recv_event_CHANNELDOESNOTEXIST, (0) },
    { BNET_EID_CHANNELRESTRICTED, bnet_recv_event_CHANNELRESTRICTED, (0) },
    { 0, ((void *)0), (0) },
    { 0, ((void *)0), (0) },
    { BNET_EID_INFO, bnet_recv_event_INFO, (0) },
    { BNET_EID_ERROR, bnet_recv_event_ERROR, (0) },
    { 0, ((void *)0), (0) },
    { 0, ((void *)0), (0) },
    { 0, ((void *)0), (0) },
    { BNET_EID_EMOTE, bnet_recv_event_EMOTE, (0) },
};

typedef gboolean (*BnetRegexMatchFunction)(BnetConnectionData *, GRegex *, const gchar *, GMatchInfo *);

struct BnetRegexStore {
    GRegex *regex;
    gchar *regex_str;
    BnetChatEventID event_id;
    BnetRegexMatchFunction fn;
    gchar *arg_format;
} bnet_regex_store[] = {

    { ((void *)0), "(\\d{4}) \\S+(?:\\s(.+)|)", 0, bnet_parse_telnet_line_event, ((void *)0) },


    { ((void *)0), "(\\S+) (\\d+) \\[(\\S+)\\]", 1000, ((void *)0), "nfp" },
    { ((void *)0), "(\\S+) (\\d+)", 1000, ((void *)0), "nf" },
    { ((void *)0), "(\\S+) (\\d+) \"(.*)\"", 1000, ((void *)0), "nft" },
    { ((void *)0), "\"(.*)\"", 1000, ((void *)0), "t" },


    { ((void *)0), "(?:You are |)(\\S+|\\S+ \\(\\*\\S+\\))(?:,| is) using (.+) in (.+)\\.", BNET_EID_INFO, bnet_recv_event_INFO_whois, ((void *)0) },


    { ((void *)0), "(?:You are|(\\S+|\\S+ \\(\\*\\S+\\)) is) away \\((.+)\\)", BNET_EID_INFO, bnet_recv_event_INFO_away_response, ((void *)0) },

    { ((void *)0), "(?:You are|(\\S+|\\S+ \\(\\*\\S+\\)) is) refusing messages \\((.+)\\)", BNET_EID_INFO, bnet_recv_event_INFO_dnd_response, ((void *)0) },


    { ((void *)0), "You are (still|now|no longer) marked as (?:being |)away\\.", BNET_EID_INFO, bnet_recv_event_INFO_away_state, ((void *)0) },

    { ((void *)0), "Do Not Disturb mode (engaged|cancelled)\\.", BNET_EID_INFO, bnet_recv_event_INFO_dnd_state, ((void *)0) },

    { ((void *)0), "(\\S+ \\(\\*\\S+\\)) is unavailable \\((.+)\\)", BNET_EID_INFO, bnet_recv_event_INFO_dnd_error, ((void *)0) },

    { ((void *)0), "(\\S+) was banned by (\\S+)(?: \\((.+)\\)|)\\.", BNET_EID_INFO, bnet_recv_event_INFO_ban, ((void *)0) },


    { ((void *)0), ((void *)0), 0, ((void *)0), ((void *)0) },
};
# 25 "src/bnet.c" 2

static void
_g_list_free_full(GList *list, GDestroyNotify free_fn)
{
    GList *el = g_list_first(list);
    while (el != ((void *)0)) {
        if (el->data != ((void *)0)) {
            free_fn(el->data);
        }
        el = ((el) ? (((GList *)(el))->next) : ((void *)0));
    }
    g_list_free(list);
}

static void
bnet_motd_free(BnetConnectionData *bnet, int type)
{
    if (bnet->bncs.motds[type].name != ((void *)0)) {
        purple_debug_info("bnet", "free motd[%d].name\n", type);
        g_free(bnet->bncs.motds[type].name);
        bnet->bncs.motds[type].name = ((void *)0);
    }
    if (bnet->bncs.motds[type].subname != ((void *)0)) {
        purple_debug_info("bnet", "free motd[%d].subname\n", type);
        g_free(bnet->bncs.motds[type].subname);
        bnet->bncs.motds[type].subname = ((void *)0);
    }
    if (bnet->bncs.motds[type].message != ((void *)0)) {
        purple_debug_info("bnet", "free motd[%d].message\n", type);
        g_free(bnet->bncs.motds[type].message);
        bnet->bncs.motds[type].message = ((void *)0);
    }
}

static void
bnet_input_free(struct SocketData *s)
{
    purple_input_remove(s->prpl_input_watcher);
    close(s->fd);
    if (s->inbuf != ((void *)0)) {
        g_free(s->inbuf);
    }
    s->inbuf = ((void *)0);
    s->inbuf_length = 0;
    s->inbuf_used = 0;
    s->fd = 0;
}

static void
bnet_channel_user_free(BnetChannelUser *bcu)
{
    if (bcu != ((void *)0)) {
        if (bcu->username != ((void *)0))
            g_free(bcu->username);
        if (bcu->stats_data != ((void *)0))
            g_free(bcu->stats_data);
        g_free(bcu);
    }
}

static void
bnet_friend_info_free(BnetFriendInfo *bfi)
{
    if (bfi != ((void *)0)) {
        if (bfi->account != ((void *)0))
            g_free(bfi->account);
        if (bfi->location_name != ((void *)0))
            g_free(bfi->location_name);
        if (bfi->away_stored_status != ((void *)0))
            g_free(bfi->away_stored_status);
        if (bfi->dnd_stored_status != ((void *)0))
            g_free(bfi->dnd_stored_status);
        g_free(bfi);
    }
}

static void
bnet_clan_member_free(BnetClanMember *member)
{
    if (member->name != ((void *)0)) {
        g_free(member->name);
    }
    if (member->location != ((void *)0)) {
        g_free(member->location);
    }
    g_free(member);
}

static void
bnet_user_free(BnetUser *bu)
{
    if (bu != ((void *)0)) {
        switch (bu->type) {
            case 0x01:
                bnet_channel_user_free((BnetChannelUser *)bu);
                break;
            case 0x02:
                bnet_friend_info_free((BnetFriendInfo *)bu);
                break;
            case 0x04:
                bnet_clan_member_free((BnetClanMember *)bu);
                break;
            default:
                g_free(bu);
                break;
        }
    }
}

static void
bnet_buddy_free(PurpleBuddy *buddy)
{
    bnet_user_free(buddy->proto_data);
}

static void
bnet_news_item_free(BnetNewsItem *item)
{
    if (item != ((void *)0)) {
        if (item->message != ((void *)0)) {
            g_free(item->message);
            item->message = ((void *)0);
        }
        g_free(item);
    }
}






static gchar *
bnet_tag_to_string(const BnetDwordTag tag)
{
    gchar *ret;
    union {
        gchar as_str[4];
        BnetDwordTag as_int;
    } data;
    int offset = 0;

    if (tag == 0) {
        return g_strdup("");
    } else {
        while (!((tag >> (offset << 3)) & 0xff)) {
            offset++;
        }
    }

    data.as_int = tag;
    ret = g_malloc0(5);
    do { memmove ((ret), (data.as_str + offset), (4 - offset)); } while (0);
    g_strreverse(ret);
    return ret;
}






static BnetDwordTag
bnet_string_to_tag(const gchar *tag_string)
{
    union {
        gchar as_str[5];
        BnetDwordTag as_int;
    } data;
    data.as_int = (BnetDwordTag)0;
    do { memmove ((data.as_str), (tag_string), ((((strlen(tag_string)) < (4)) ? (strlen(tag_string)) : (4)))); } while (0);
    return data.as_int;
}

static gboolean
bnet_clan_in_clan(const BnetConnectionData *bnet)
{
    return bnet->bncs.w3_clan.in_clan;
}

static gboolean
bnet_clan_is_clan_channel(const BnetConnectionData *bnet, const char *channel_name_a)
{
    gchar *tag_string = bnet_tag_to_string(bnet->bncs.w3_clan.my_clantag);
    gchar *channel_name_b = g_strdup_printf("clan %s", tag_string);
    gchar *channel_name_lower_a = g_ascii_strdown(channel_name_a, -1);
    gchar *channel_name_lower_b = g_ascii_strdown(channel_name_b, -1);

    gboolean is_equal = g_strcmp0(channel_name_lower_a, channel_name_lower_b) == 0;

    g_free(tag_string);
    g_free(channel_name_b);
    g_free(channel_name_lower_a);
    g_free(channel_name_lower_b);

    return is_equal;
}

static BnetClanMember *
bnet_clan_find_member(const BnetConnectionData *bnet, const gchar *name)
{
    GList *el = ((void *)0);
    el = g_list_first(bnet->bncs.w3_clan.my_clanmembers);
    while (el != ((void *)0)) {
        BnetClanMember *member = el->data;
        if (g_ascii_strcasecmp(name, member->name) == 0) {
            return member;
        }
        el = ((el) ? (((GList *)(el))->next) : ((void *)0));
    }
    return ((void *)0);
}

static const gchar *
bnet_clan_rank_to_string(const BnetClanMemberRank rank)
{
    switch (rank) {
        case BNET_CLAN_RANK_CHIEFTAIN:
            return "Chieftain";
        case BNET_CLAN_RANK_SHAMAN:
            return "Shaman";
        case BNET_CLAN_RANK_GRUNT:
            return "Grunt";
        case BNET_CLAN_RANK_PEON:
            return "Peon";
        case BNET_CLAN_RANK_INITIATE:
            return "Peon (7-day probation)";
        default:
            return "Unknown";
    }
}

static gboolean
bnet_packet_cookie_keyequal(gconstpointer a, gconstpointer b)
{
    const struct BnetPacketCookieKey *key_a = a;
    const struct BnetPacketCookieKey *key_b = b;
    return key_a->packet_id == key_b->packet_id &&
           key_a->cookie == key_b->cookie;
}

static guint32
bnet_packet_cookie_keyhash(gconstpointer data)
{
    const struct BnetPacketCookieKey *key = data;
    gint32 i32 = key->cookie ^ (key->packet_id << 24);
    return g_int_hash(&i32);
}

static void
bnet_packet_cookie_keyfree(gpointer data)
{
    g_free(data);
}

static guint32
bnet_packet_cookie_register(BnetConnectionData *bnet, const guint8 packet_id, gpointer data)
{
    static guint32 cookie = 1;

    struct BnetPacketCookieKey *key = ((void *)0);

    cookie++;

    key = (struct BnetPacketCookieKey *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (struct BnetPacketCookieKey); gpointer __p; if (__s == 1) __p = g_malloc (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc (__n * __s); else __p = g_malloc_n (__n, __s); __p; }));
    key->packet_id = packet_id;
    key->cookie = cookie;

    if (bnet->bncs.chat_env.packet_cookie_table == ((void *)0)) {
        bnet->bncs.chat_env.packet_cookie_table = g_hash_table_new_full(
                            (GHashFunc)bnet_packet_cookie_keyhash,
                            (GEqualFunc)bnet_packet_cookie_keyequal,
                            (GDestroyNotify)bnet_packet_cookie_keyfree,
                            ((void *)0));
    }

    g_hash_table_insert(bnet->bncs.chat_env.packet_cookie_table, key, data);
    return cookie;
}

static gpointer
bnet_packet_cookie_unregister(BnetConnectionData *bnet, const guint8 packet_id, const guint32 cookie)
{
    gpointer ret;
    struct BnetPacketCookieKey *key = ((void *)0);

    if (bnet->bncs.chat_env.packet_cookie_table == ((void *)0)) {
        return ((void *)0);
    }

    key = (struct BnetPacketCookieKey *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (struct BnetPacketCookieKey); gpointer __p; if (__s == 1) __p = g_malloc (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc (__n * __s); else __p = g_malloc_n (__n, __s); __p; }));
    key->packet_id = packet_id;
    key->cookie = cookie;

    ret = g_hash_table_lookup(bnet->bncs.chat_env.packet_cookie_table, key);
    if (ret != ((void *)0)) {
        g_hash_table_remove(bnet->bncs.chat_env.packet_cookie_table, key);
    }
    g_free(key);
    return ret;
}

static BnetClanMember *
bnet_clan_member_new(gchar *name, BnetClanMemberRank rank, BnetClanMemberStatus status, gchar *location)
{
    BnetClanMember *ret = (BnetClanMember *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetClanMember); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    ret->type = 0x04;
    ret->name = name;
    ret->rank = rank;
    ret->status = status;
    ret->location = location;
    return ret;
}

static gchar *
bnet_clan_member_get_name(const BnetClanMember *member)
{
    return member->name;
}

static gchar *
bnet_clan_member_get_location(const BnetClanMember *member)
{
    return member->location;
}

static void
bnet_clan_member_set_location(BnetClanMember *member, gchar *location)
{
    if (member->location != ((void *)0)) {
        g_free(member->location);
    }
    member->location = location;
}

static BnetClanMemberRank
bnet_clan_member_get_rank(const BnetClanMember *member)
{
    return member->rank;
}


static BnetClanMemberStatus
bnet_clan_member_get_status(const BnetClanMember *member)
{
    return member->status;
}

static void
bnet_clan_member_set_status(BnetClanMember *member, BnetClanMemberStatus status)
{
    member->status = status;
}

static guint64
bnet_clan_member_get_joindate(const BnetClanMember *member)
{
    return member->join_date;
}

static void
bnet_clan_member_set_joindate(BnetClanMember *member, guint64 joindate)
{
    member->join_date = joindate;
}

static const gchar *
bnet_get_d2_star(BnetConnectionData *bnet)
{
    if (bnet_is_d2(bnet)) {
        return "*";
    } else {
        return "";
    }
}

static BnetProductID
bnet_get_product(BnetConnectionData *bnet)
{
    return bnet_string_to_tag(purple_account_get_string(bnet->account,
                "product", "RATS"));
}

static gchar *
bnet_get_key_owner(BnetConnectionData *bnet)
{
    const gchar *key_owner_field = purple_account_get_string(bnet->account,
            "key_owner", "");
    if (key_owner_field == ((void *)0)) {
        return g_strdup(bnet->bncs.logon.username);
    } else {
        gchar *key_owner = g_strdup(key_owner_field);
        if (strlen(key_owner) == 0) {
            g_free(key_owner);
            key_owner = g_strdup(bnet->bncs.logon.username);
        }
        return key_owner;
    }
}

static gboolean
bnet_is_telnet(const BnetConnectionData *bnet)
{
    return bnet->bncs.versioning.product == (0x43484152);
}

static gboolean
bnet_is_d2(const BnetConnectionData *bnet)
{
    return (bnet->bncs.versioning.product == (0x44324456) ||
            bnet->bncs.versioning.product == (0x44325850));
}

static gboolean
bnet_is_w3(const BnetConnectionData *bnet)
{
    return (bnet->bncs.versioning.product == (0x57415233) ||
            bnet->bncs.versioning.product == (0x57335850));
}

static gboolean
bnet_is_scrt(const BnetConnectionData *bnet)
{
    return (bnet->bncs.versioning.product == (0x53544152) ||
            bnet->bncs.versioning.product == (0x53415850));
}

static BnetVersioningSystem
bnet_get_versioningsystem(const BnetConnectionData *bnet)
{
    switch (bnet->bncs.versioning.product) {
        case (0x53534852):
        case (0x4a535452):
            return 0x00;
        case (0x4452544c):
        case (0x44534852):
        case (0x5732424e):
            return 0x01;
        default:
            return 0x02;
    }
}

static int
bnet_get_key_count(const BnetConnectionData *bnet)
{
    switch (bnet->bncs.versioning.product) {
        default:
            return 0;
        case (0x53544152):
        case (0x53415850):
        case (0x5732424e):
        case (0x44324456):
        case (0x57415233):
            return 1;
        case (0x44325850):
        case (0x57335850):
            return 2;
    }
}

static void
bnet_connect(PurpleAccount *account, const gboolean do_register)
{

    PurpleConnection *gc = ((void *)0);
    BnetConnectionData *bnet = ((void *)0);
    char **userparts = ((void *)0);
    PurpleProxyConnectData *bnls_conn_data = ((void *)0);
    PurpleProxyConnectData *conn_data = ((void *)0);
    const char *username = purple_account_get_username(account);


    gc = purple_account_get_connection(account);
    gc->flags |= PURPLE_CONNECTION_NO_BGCOLOR;
    gc->flags |= PURPLE_CONNECTION_AUTO_RESP;
    gc->flags |= PURPLE_CONNECTION_NO_NEWLINES;
    gc->flags |= PURPLE_CONNECTION_NO_FONTSIZE;
    gc->flags |= PURPLE_CONNECTION_NO_URLDESC;
    gc->flags |= PURPLE_CONNECTION_NO_IMAGES;


    if (__extension__ ({ char __a0, __a1, __a2; (__builtin_constant_p (" \t\v\r\n") && ((size_t)(const void *)((" \t\v\r\n") + 1) - (size_t)(const void *)(" \t\v\r\n") == 1) ? ((__builtin_constant_p (username) && ((size_t)(const void *)((username) + 1) - (size_t)(const void *)(username) == 1)) ? __builtin_strpbrk (username, " \t\v\r\n") : ((__a0 = ((const char *) (" \t\v\r\n"))[0], __a0 == '\0') ? ((void) (username), (char *) ((void *)0)) : ((__a1 = ((const char *) (" \t\v\r\n"))[1], __a1 == '\0') ? __builtin_strchr (username, __a0) : ((__a2 = ((const char *) (" \t\v\r\n"))[2], __a2 == '\0') ? __strpbrk_c2 (username, __a0, __a1) : (((const char *) (" \t\v\r\n"))[3] == '\0' ? __strpbrk_c3 (username, __a0, __a1, __a2) : __builtin_strpbrk (username, " \t\v\r\n")))))) : __builtin_strpbrk (username, " \t\v\r\n")); }) != ((void *)0)) {
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
                "Battle.net username or server may not contain whitespace");
        return;
    }

    userparts = g_strsplit(username, "@", 2);


    gc->proto_data = bnet = (BnetConnectionData *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetConnectionData); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));

    bnet->magic = (0x626e6574);
    bnet->account = account;

    bnet->bncs.conn.port = purple_account_get_int(account,
            "port", 6112);
    bnet->bncs.conn.server = g_strdup(userparts[1]);

    bnet->bnls.conn.server = g_strdup(purple_account_get_string(account,
            "bnlsserver", "bnls.net"));
    bnet->bnls.conn.port = 9367;

    bnet->bncs.logon.type = 0x00;
    bnet->bncs.logon.username = g_strdup(userparts[0]);
    bnet->bncs.logon.create_account = do_register;

    bnet->bncs.versioning.product = bnet_get_product(bnet);
    bnet->bncs.versioning.type = bnet_get_versioningsystem(bnet);
    bnet->bncs.versioning.complete = (0);
    bnet->bncs.versioning.key_owner = bnet_get_key_owner(bnet);

    bnet->bncs.chat_env.is_online = (0);
    bnet->bncs.chat_env.sent_enter_channel = (0);
    bnet->bncs.chat_env.d2_star = bnet_get_d2_star(bnet);

    g_strfreev(userparts);

    if (bnet_is_telnet(bnet)) {

        purple_debug_info("bnet", "Connecting to (CHAT) %s:%d...\n",
                bnet->bncs.conn.server, bnet->bncs.conn.port);
        if (!bnet->bncs.logon.create_account) {
            purple_connection_update_progress(gc, "Connecting to Battle.net",
                    1, 5);
        }
        conn_data = purple_proxy_connect(gc, account, bnet->bncs.conn.server,
                bnet->bncs.conn.port, bnet_login_cb, gc);
        if (conn_data == ((void *)0)) {
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                    "Unable to connect");
            return;
        }
        bnet->bncs.conn.prpl_conn_data = conn_data;
    } else {

        purple_debug_info("bnet", "Connecting to BNLS %s:%d...\n",
                bnet->bnls.conn.server, bnet->bnls.conn.port);
        if (!bnet->bncs.logon.create_account) {
            purple_connection_update_progress(gc, "Connecting to BNLS",
                    0, 5);
        }
        bnls_conn_data = purple_proxy_connect(gc, account, bnet->bnls.conn.server,
                bnet->bnls.conn.port, bnet_bnls_login_cb, gc);
        if (bnls_conn_data == ((void *)0)) {
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                    "Unable to connect to the BNLS server");
            return;
        }
        bnet->bnls.conn.prpl_conn_data = bnls_conn_data;
    }
}

static void
bnet_login(PurpleAccount *account)
{
    bnet_connect(account, (0));
}

static void
bnet_bnls_login_cb(gpointer data, gint source, const gchar *error_message)
{
    PurpleConnection *gc = data;
    BnetConnectionData *bnet = gc->proto_data;

    if (source < 0) {
        gchar *tmp = g_strdup_printf("Unable to connect to BNLS: %s",
                error_message);
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
        g_free(tmp);
        return;
    }

    purple_debug_info("bnet", "BNLS connected!\n");

    bnet->bnls.conn.fd = source;

    if (bnet_bnls_send_REQUESTVERSIONBYTE(bnet)) {
        bnet->bnls.conn.prpl_input_watcher = purple_input_add(bnet->bnls.conn.fd, PURPLE_INPUT_READ, bnet_bnls_input_cb, gc);
    }
}
# 628 "src/bnet.c"
static int
bnet_bnls_send_LOGONCHALLENGE(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    const char *username = bnet->bncs.logon.username;
    const char *password = purple_account_get_password(bnet->account);

    pkt = bnet_packet_create(3);
    bnet_packet_insert(pkt, username, -1);
    bnet_packet_insert(pkt, password, -1);

    ret = bnet_packet_send_bnls(pkt, BNET_BNLS_LOGONCHALLENGE, bnet->bnls.conn.fd);

    return ret;
}
# 661 "src/bnet.c"
static int
bnet_bnls_send_VERSIONCHECKEX2(const BnetConnectionData *bnet,
        guint32 login_type, guint32 server_cookie, guint32 session_cookie,
        guint64 mpq_ft, char *mpq_fn, char *checksum_formula)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    guint32 bnls_flags = 0;

    pkt = bnet_packet_create(3);
    bnet_packet_insert(pkt, &bnet->bncs.versioning.game_type, 4);
    bnet_packet_insert(pkt, &bnls_flags, 4);
    bnet_packet_insert(pkt, &bnls_flags, 4);
    bnet_packet_insert(pkt, &mpq_ft, 8);
    bnet_packet_insert(pkt, mpq_fn, -1);
    bnet_packet_insert(pkt, checksum_formula, -1);

    ret = bnet_packet_send_bnls(pkt, BNET_BNLS_VERSIONCHECKEX2, bnet->bnls.conn.fd);

    return ret;
}

static int
bnet_bnls_send_REQUESTVERSIONBYTE(BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    BnetGameType game = 0;

    const BnetProductID product_id = bnet->bncs.versioning.product;

    switch (product_id) {
        default:
        case (0x53544152): game = BNET_GAME_TYPE_STAR; break;
        case (0x53415850): game = BNET_GAME_TYPE_SEXP; break;
        case (0x5732424e): game = BNET_GAME_TYPE_W2BN; break;
        case (0x44324456): game = BNET_GAME_TYPE_D2DV; break;
        case (0x44325850): game = BNET_GAME_TYPE_D2XP; break;
        case (0x4a535452): game = BNET_GAME_TYPE_JSTR; break;
        case (0x57415233): game = BNET_GAME_TYPE_WAR3; break;
        case (0x57335850): game = BNET_GAME_TYPE_W3XP; break;
        case (0x4452544c): game = BNET_GAME_TYPE_DRTL; break;
        case (0x44534852): game = BNET_GAME_TYPE_DSHR; break;
        case (0x53534852): game = BNET_GAME_TYPE_SSHR; break;
    }

    bnet->bncs.versioning.game_type = game;

    pkt = bnet_packet_create(3);
    bnet_packet_insert(pkt, &game, 4);

    ret = bnet_packet_send_bnls(pkt, BNET_BNLS_REQUESTVERSIONBYTE, bnet->bnls.conn.fd);

    return ret;
}

static void
bnet_bnls_input_cb(gpointer data, gint source, PurpleInputCondition cond)
{
    PurpleConnection *gc = data;
    BnetConnectionData *bnet = ((void *)0);
    int len = 0;

    do { if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (gc != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ; else g_assertion_message_expr (((gchar*) 0), "src/bnet.c", 725, ((const char*) (__PRETTY_FUNCTION__)), "gc != NULL"); } while (0);

    bnet = gc->proto_data;

    if (bnet->bnls.conn.inbuf_length < bnet->bnls.conn.inbuf_used + 512) {
        bnet->bnls.conn.inbuf_length += 512;
        bnet->bnls.conn.inbuf = g_realloc(bnet->bnls.conn.inbuf, bnet->bnls.conn.inbuf_length);
    }

    len = read(bnet->bnls.conn.fd, bnet->bnls.conn.inbuf + bnet->bnls.conn.inbuf_used, bnet->bnls.conn.inbuf_length - bnet->bnls.conn.inbuf_used);
    if (len < 0 && (*__errno_location ()) == 11) {
        return;
    } else if (len < 0) {
        gchar *tmp = ((void *)0);
        tmp = g_strdup_printf("Lost connection with BNLS server: %s\n",
                g_strerror((*__errno_location ())));
        if (bnet->bncs.versioning.complete == (0)) {
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
            if (bnet->bncs.conn.fd != 0) {
                bnet_input_free(&bnet->bncs.conn);
            }
        }
        purple_debug_info("bnet", tmp);
        g_free(tmp);
        if (bnet->bnls.conn.fd != 0) {
            bnet_input_free(&bnet->bnls.conn);
        }
        return;
    } else if (len == 0) {
        if (bnet->bncs.versioning.complete == (0)) {
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                    "BNLS server closed the connection\n");
            if (bnet->bncs.conn.fd != 0) {
                bnet_input_free(&bnet->bncs.conn);
            }
        }
        purple_debug_info("bnet", "BNLS disconnected.\n");
        if (bnet->bnls.conn.fd != 0) {
            bnet_input_free(&bnet->bnls.conn);
        }
        return;
    }

    bnet_bnls_read_input(bnet, len);
}

static void
bnet_bnls_read_input(BnetConnectionData *bnet, int len)
{
    gchar *this_start = ((void *)0);
    guint16 inbuftouse = 0;

    bnet->account->gc->last_received = time(((void *)0));
    bnet->bnls.conn.inbuf_used += len;

    this_start = bnet->bnls.conn.inbuf;

    while (this_start + 3 <= bnet->bnls.conn.inbuf + bnet->bnls.conn.inbuf_used)
    {
#pragma pack(push)
#pragma pack(1)
        struct {
            guint16 len;
            guint8 id;
        } *header = (void *)this_start;
#pragma pack(pop)
        inbuftouse += header->len;
        if (inbuftouse <= bnet->bnls.conn.inbuf_used) {
            bnet_bnls_parse_packet(bnet, header->id, this_start, header->len);
            if (bnet->bnls.conn.fd == 0) {

                return;
            }
            this_start += header->len;
        } else break;
    }

    if (this_start != bnet->bnls.conn.inbuf + bnet->bnls.conn.inbuf_used) {
        bnet->bnls.conn.inbuf_used -= (this_start - bnet->bnls.conn.inbuf);
        memmove(bnet->bnls.conn.inbuf, this_start, bnet->bnls.conn.inbuf_used);
    } else {
        bnet->bnls.conn.inbuf_used = 0;
    }
}

static void
bnet_bnls_recv_CHOOSENLSREVISION(const BnetConnectionData *bnet, BnetPacket *pkt)
{
    gboolean result = bnet_packet_read_dword(pkt);

    if (result) {
        bnet_bnls_send_LOGONCHALLENGE(bnet);
    }
}

static void
bnet_bnls_recv_LOGONCHALLENGE(const BnetConnectionData *bnet, BnetPacket *pkt)
{
    char *A = (char *)bnet_packet_read(pkt, 32);

    bnet_send_AUTH_ACCOUNTLOGON(bnet, A);

    g_free(A);
}

static void
bnet_bnls_recv_LOGONPROOF(const BnetConnectionData *bnet, BnetPacket *pkt)
{
    char *M1 = (char *)bnet_packet_read(pkt, 20);

    bnet_send_AUTH_ACCOUNTLOGONPROOF(bnet, M1);

    g_free(M1);
}

static void
bnet_bnls_recv_REQUESTVERSIONBYTE(BnetConnectionData *bnet, BnetPacket *pkt)
{

    BnetProductID product_id = bnet_packet_read_dword(pkt);
    PurpleAccount *account = bnet->account;
    PurpleConnection *gc = account->gc;
    PurpleProxyConnectData *conn_data = ((void *)0);

    if (product_id != 0) {
        guint32 version_code = bnet_packet_read_dword(pkt);
        bnet->bncs.versioning.version_code = version_code;
    }


    purple_debug_info("bnet", "Connecting to Battle.net %s:%d...\n", bnet->bncs.conn.server, bnet->bncs.conn.port);
    if (!bnet->bncs.logon.create_account) {
        purple_connection_update_progress(gc, "Connecting to Battle.net", 1, 5);
    }
    conn_data = purple_proxy_connect(gc, account, bnet->bncs.conn.server, bnet->bncs.conn.port,
            bnet_login_cb, gc);
    if (conn_data == ((void *)0)) {
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                "Unable to connect");
        return;
    }
    bnet->bncs.conn.prpl_conn_data = conn_data;
}

static void
bnet_bnls_recv_VERSIONCHECKEX2(BnetConnectionData *bnet, BnetPacket *pkt)
{

    guint32 success = bnet_packet_read_dword(pkt);
    guint32 exe_version = 0;
    guint32 exe_checksum = 0;

    guint32 version_code = 0;
    char *exe_info = ((void *)0);

    bnet->bncs.versioning.complete = (!(0));

    if (success == (!(0))) {
        exe_version = bnet_packet_read_dword(pkt);
        exe_checksum = bnet_packet_read_dword(pkt);
        exe_info = bnet_packet_read_cstring(pkt);
                     bnet_packet_read_dword(pkt);
        version_code = bnet_packet_read_dword(pkt);
        bnet->bncs.versioning.version_code = version_code;
        bnet->bncs.logon.client_cookie = g_random_int();
        if (bnet->bncs.versioning.type == 0x02) {
            bnet_send_AUTH_CHECK(bnet,
                    exe_version, exe_checksum, exe_info);
        } else {
            bnet_send_REPORTVERSION(bnet,
                    exe_version, exe_checksum, exe_info);
        }

        g_free(exe_info);
    } else {
        char *tmp = ((void *)0);
        tmp = g_strdup("The BNLS server could says version check failure");
        purple_connection_error_reason(bnet->account->gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                tmp);
        g_free(tmp);
    }
}

static void
bnet_bnls_recv_MESSAGE(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *message = bnet_packet_read_cstring(pkt);

    bnet_motd_free(bnet, 1);
    bnet->bncs.motds[1].name = ((void *)0);
    bnet->bncs.motds[1].subname = ((void *)0);
    bnet->bncs.motds[1].message = message;
}

static void
bnet_bnls_parse_packet(BnetConnectionData *bnet, const guint8 packet_id, const gchar *packet_start, const guint16 packet_len)
{
    BnetPacket *pkt = ((void *)0);

    purple_debug_misc("bnet", "BNLS S>C 0x%02x: length %d\n", packet_id, packet_len);

    pkt = bnet_packet_refer_bnls(packet_start, packet_len);

    switch (packet_id) {
        case BNET_BNLS_LOGONCHALLENGE:
            bnet_bnls_recv_LOGONCHALLENGE(bnet, pkt);
            break;
        case BNET_BNLS_LOGONPROOF:
            bnet_bnls_recv_LOGONPROOF(bnet, pkt);
            break;
        case BNET_BNLS_REQUESTVERSIONBYTE:
            bnet_bnls_recv_REQUESTVERSIONBYTE(bnet, pkt);
            break;
        case BNET_BNLS_VERSIONCHECKEX2:
            bnet_bnls_recv_VERSIONCHECKEX2(bnet, pkt);
            break;
        case BNET_BNLS_CHOOSENLSREVISION:
            bnet_bnls_recv_CHOOSENLSREVISION(bnet, pkt);
            break;
        case BNET_BNLS_MESSAGE:
            bnet_bnls_recv_MESSAGE(bnet, pkt);
            break;
        default:

            purple_debug_warning("bnet", "Received unhandled BNLS packet 0x%02x, length %d\n", packet_id, packet_len);
            break;
    }

    bnet_packet_free(pkt);
}

static void
bnet_realm_login_cb(gpointer data, gint source, const gchar *error_message)
{
    PurpleConnection *gc = data;
    BnetConnectionData *bnet = gc->proto_data;

    if (source < 0) {
        gchar *tmp = g_strdup_printf("Unable to connect to the D2 realm: %s",
                error_message);
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
        g_free(tmp);
        return;
    }

    purple_debug_info("bnet", "Realm connected!\n");

    bnet->d2mcp.conn.fd = source;

    if (bnet_realm_protocol_begin(bnet)) {
        bnet->d2mcp.conn.prpl_input_watcher = purple_input_add(bnet->d2mcp.conn.fd, PURPLE_INPUT_READ, bnet_realm_input_cb, gc);
    }
}

static gboolean
bnet_realm_protocol_begin(const BnetConnectionData *bnet)
{
    if (bnet_send_protocol_byte(0x01, bnet->d2mcp.conn.fd) < 0) {
        return (0);
    }

    if (bnet_realm_send_STARTUP(bnet) < 0) {
        return (0);
    }

    return (!(0));
}

static int
bnet_realm_send_STARTUP(const BnetConnectionData *bnet)
{
    BnetPacket *pkt;
    int ret = -1;

    int i;
    pkt = bnet_packet_create(3);
    for (i = 0; i < 16; i++) {
        bnet_packet_insert(pkt, &bnet->d2mcp.logon_data[i], 4);
    }
    bnet_packet_insert(pkt, bnet->bncs.chat_env.unique_name, -1);

    ret = bnet_packet_send_bnls(pkt, BNET_D2MCP_STARTUP, bnet->d2mcp.conn.fd);

    return ret;
}

static int
bnet_realm_send_CHARLOGON(const BnetConnectionData *bnet, const gchar *char_name)
{
    BnetPacket *pkt;
    int ret = -1;

    pkt = bnet_packet_create(3);
    bnet_packet_insert(pkt, char_name, -1);

    ret = bnet_packet_send_bnls(pkt, BNET_D2MCP_CHARLOGON, bnet->d2mcp.conn.fd);

    return ret;
}

static int
bnet_realm_send_MOTD(const BnetConnectionData *bnet)
{
    BnetPacket *pkt;
    int ret = -1;

    pkt = bnet_packet_create(3);

    ret = bnet_packet_send_bnls(pkt, BNET_D2MCP_MOTD, bnet->d2mcp.conn.fd);

    return ret;
}

static int
bnet_realm_send_CHARLIST2(const BnetConnectionData *bnet, guint32 char_count)
{
    BnetPacket *pkt;
    int ret = -1;

    pkt = bnet_packet_create(3);
    bnet_packet_insert(pkt, &char_count, 4);

    ret = bnet_packet_send_bnls(pkt, BNET_D2MCP_CHARLIST2, bnet->d2mcp.conn.fd);

    return ret;
}

static void
bnet_realm_input_cb(gpointer data, gint source, PurpleInputCondition cond)
{
    PurpleConnection *gc = data;
    BnetConnectionData *bnet = gc->proto_data;
    int len = 0;

    do { if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0) && bnet->magic == (0x626e6574)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ; else g_assertion_message_expr (((gchar*) 0), "src/bnet.c", 1064, ((const char*) (__PRETTY_FUNCTION__)), "bnet != NULL && bnet->magic == BNET_UDP_SIG"); } while (0);

    if (bnet->d2mcp.conn.inbuf_length < bnet->d2mcp.conn.inbuf_used + 512) {
        bnet->d2mcp.conn.inbuf_length += 512;
        bnet->d2mcp.conn.inbuf = g_realloc(bnet->d2mcp.conn.inbuf, bnet->d2mcp.conn.inbuf_length);
    }

    len = read(bnet->d2mcp.conn.fd, bnet->d2mcp.conn.inbuf + bnet->d2mcp.conn.inbuf_used, bnet->d2mcp.conn.inbuf_length - bnet->d2mcp.conn.inbuf_used);
    if (len < 0 && (*__errno_location ()) == 11) {
        return;
    } else if (len < 0) {
        gchar *tmp = ((void *)0);
        tmp = g_strdup_printf("Lost connection with realm server: %s\n",
                g_strerror((*__errno_location ())));
        if (!bnet->d2mcp.on_character) {


        }
        purple_debug_info("bnet", tmp);
        g_free(tmp);
        if (bnet->d2mcp.conn.fd != 0) {
            bnet_input_free(&bnet->d2mcp.conn);
        }
        return;
    } else if (len == 0) {
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                "Server closed the realm connection\n");
        purple_debug_info("bnet", "D2 realm disconnected.\n");
        if (bnet->d2mcp.conn.fd != 0) {
            bnet_input_free(&bnet->d2mcp.conn);
        }
        return;
    }

    bnet_realm_read_input(bnet, len);
}

static void
bnet_realm_read_input(BnetConnectionData *bnet, int len)
{
    gchar *this_start = ((void *)0);
    guint16 inbuftouse = 0;

    bnet->account->gc->last_received = time(((void *)0));
    bnet->d2mcp.conn.inbuf_used += len;

    this_start = bnet->d2mcp.conn.inbuf;

    while (this_start + 3 <= bnet->d2mcp.conn.inbuf + bnet->d2mcp.conn.inbuf_used)
    {
#pragma pack(push)
#pragma pack(1)
        struct {
            guint16 len;
            guint8 id;
        } *header = (void *)this_start;
#pragma pack(pop)
        inbuftouse += header->len;
        if (inbuftouse <= bnet->d2mcp.conn.inbuf_used) {
            bnet_realm_parse_packet(bnet, header->id, this_start, header->len);
            if (bnet->d2mcp.conn.fd == 0) {

                return;
            }
            this_start += header->len;
        } else break;
    }

    if (this_start != bnet->d2mcp.conn.inbuf + bnet->d2mcp.conn.inbuf_used) {
        bnet->d2mcp.conn.inbuf_used -= (this_start - bnet->d2mcp.conn.inbuf);
        memmove(bnet->d2mcp.conn.inbuf, this_start, bnet->d2mcp.conn.inbuf_used);
    } else {
        bnet->d2mcp.conn.inbuf_used = 0;
    }
}

static void
bnet_realm_recv_STARTUP(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *tmp;
    BnetRealmStatus status = bnet_packet_read_dword(pkt);
    switch (status) {
        case BNET_REALM_CONNECT_NOBNCS2:
        case BNET_REALM_CONNECT_NOBNCS10:
        case BNET_REALM_CONNECT_NOBNCS11:
        case BNET_REALM_CONNECT_NOBNCS12:
        case BNET_REALM_CONNECT_NOBNCS13:

            tmp = g_strdup_printf("The Diablo II realm server could not detect your Battle.net connection (0x%02x).", status);
            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), (tmp), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                          ;
            g_free(tmp);
            bnet_realm_logon_cb(bnet);
            break;
        case BNET_REALM_CONNECT_TEMPBAN:

            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), ("The Diablo II realm server has temporarily banned you from play."), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                          ;
            bnet_realm_logon_cb(bnet);
            break;
        case BNET_REALM_CONNECT_KEYBAN:

            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), ("The Diablo II realm server has permanently banned you from play."), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                          ;
            bnet_realm_logon_cb(bnet);
            break;
        default:
            tmp = g_strdup_printf("Diablo II realm logon failed (0x%02x).", status);
            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), (tmp), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                          ;
            g_free(tmp);
            bnet_realm_logon_cb(bnet);
            break;
        case BNET_REALM_SUCCESS:

            bnet_realm_send_CHARLIST2(bnet, 8);
            break;
    }
}

static void
bnet_realm_recv_CHARLOGON(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *tmp;
    BnetRealmStatus status = bnet_packet_read_dword(pkt);
    switch (status) {
        case BNET_REALM_CHAR_PDNE:

            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Character Logon Error"), ("The chosen character does not exist."), ("Unable to log on to your Diablo II character. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                               ;
            bnet_realm_logon_cb(bnet);
            break;
        case BNET_REALM_CHAR_FAILED:

            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Character Logon Error"), ("Character logon failed."), ("Unable to log on to your Diablo II character. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                               ;
            bnet_realm_logon_cb(bnet);
            break;
        case BNET_REALM_CHAR_EXPIRED:

            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Character Logon Error"), ("That character is expired."), ("Unable to log on to your Diablo II character. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                               ;
            bnet_realm_logon_cb(bnet);
            break;
        default:

            tmp = g_strdup_printf("Character logon failed (0x%02x).", status);
            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Character Logon Error"), (tmp), ("Unable to log on to your Diablo II character. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                               ;
            g_free(tmp);
            bnet_realm_logon_cb(bnet);
            break;
        case BNET_REALM_SUCCESS:

            bnet->d2mcp.on_character = (!(0));
            bnet_realm_send_MOTD(bnet);
            bnet_realm_logon_cb(bnet);
            break;
    }
}

static void
bnet_realm_recv_MOTD(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *message;

    bnet_packet_read_byte(pkt);
    message = bnet_packet_read_cstring(pkt);

    bnet_motd_free(bnet, 2);
    bnet->bncs.motds[2].name = g_strdup(bnet->d2mcp.realm.name);
    bnet->bncs.motds[2].subname = g_strdup(bnet->d2mcp.realm.descr);
    bnet->bncs.motds[2].message = message;
}

static void
bnet_realm_recv_CHARLIST2(BnetConnectionData *bnet, BnetPacket *pkt)
{


    guint16 num_ret;
    GList *char_list = ((void *)0);
    gboolean listing = (0);
    int i;
    gchar *auto_logon = g_strdup(purple_account_get_string(bnet->account, "d2realm_char", ""));
    gboolean do_auto_logon = (0);

                  bnet_packet_read_word(pkt);
                    bnet_packet_read_dword(pkt);
    num_ret = bnet_packet_read_word(pkt);
    if (auto_logon && strlen(auto_logon) > 0) {
        do_auto_logon = (!(0));
    } else if (num_ret == 0) {
        purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), ("There are no Diablo II characters on your account."), ("Unable to log on to your Diablo II character. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                           ;
        bnet_realm_logon_cb(bnet);
        g_free(auto_logon);
        return;
    } else if (num_ret == 1) {
        do_auto_logon = (!(0));
    } else {
        listing = (!(0));
        purple_debug_info("bnet", "MCP There are multiple characters on this account!\n");
    }
    do_auto_logon = (num_ret == 1);

    for (i = 0; i < num_ret; i++) {
        guint32 exp_date = bnet_packet_read_dword(pkt);
        gchar *char_name = bnet_packet_read_cstring(pkt);
        gchar *char_stats = bnet_packet_read_cstring(pkt);

        if (listing) {
            BnetD2RealmCharacter *character = (BnetD2RealmCharacter *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetD2RealmCharacter); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
            character->expires = exp_date;
            character->name = char_name;
            character->stats = char_stats;
            char_list = g_list_append(char_list, character);
        }

        if (do_auto_logon && strlen(auto_logon) == 0) {
            auto_logon = g_strdup(char_name);
        }

        if (g_ascii_strcasecmp(auto_logon, char_name) == 0) {
            bnet->d2mcp.character.expires = exp_date;
            bnet->d2mcp.character.name = g_strdup(char_name);
            bnet->d2mcp.character.stats = g_strdup(char_stats);
        }

        g_free(char_name);
        g_free(char_stats);
    }

    if (do_auto_logon) {
        bnet_realm_send_CHARLOGON(bnet, auto_logon);
    }
    if (listing) {
        bnet_realm_character_list(bnet, char_list);
    }

    g_free(auto_logon);
}

static void
bnet_realm_parse_packet(BnetConnectionData *bnet, const guint8 packet_id,
            const gchar *packet_start, const guint16 packet_len)
{
    BnetPacket *pkt = ((void *)0);

    purple_debug_misc("bnet", "Realm S>C 0x%02x: length %d\n", packet_id, packet_len);

    pkt = bnet_packet_refer_bnls(packet_start, packet_len);

    switch (packet_id) {
        case BNET_D2MCP_STARTUP:
            bnet_realm_recv_STARTUP(bnet, pkt);
            break;
        case BNET_D2MCP_CHARLOGON:
            bnet_realm_recv_CHARLOGON(bnet, pkt);
            break;
        case BNET_D2MCP_MOTD:
            bnet_realm_recv_MOTD(bnet, pkt);
            break;
        case BNET_D2MCP_CHARLIST2:
            bnet_realm_recv_CHARLIST2(bnet, pkt);
            break;
        default:

            purple_debug_warning("bnet", "Received unhandled realm packet 0x%02x, length %d\n", packet_id, packet_len);
            break;
    }

    bnet_packet_free(pkt);
}

static void
bnet_login_cb(gpointer data, gint source, const gchar *error_message)
{
    PurpleConnection *gc = data;
    BnetConnectionData *bnet = gc->proto_data;

    if (source < 0) {
        gchar *tmp = g_strdup_printf("Unable to connect: %s",
                error_message);
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
        g_free(tmp);
        return;
    }

    bnet->bncs.conn.fd = source;
    purple_debug_info("bnet", "BNCS connected!\n");

    if (bnet_is_telnet(bnet)) {
        purple_connection_update_progress(gc, "Authenticating", 3, 5);
        if (bnet_protocol_telnet_begin(bnet)) {
            bnet->bncs.conn.prpl_input_watcher = gc->inpa = purple_input_add(bnet->bncs.conn.fd, PURPLE_INPUT_READ, bnet_input_cb, gc);
        }
    } else {
        if (!bnet->bncs.logon.create_account) {
            purple_connection_update_progress(gc, "Checking product key and version", 2, 5);
        }

        if (bnet_protocol_begin(bnet)) {
            bnet->bncs.conn.prpl_input_watcher = gc->inpa = purple_input_add(bnet->bncs.conn.fd, PURPLE_INPUT_READ, bnet_input_cb, gc);
        }
    }
}

static gboolean
bnet_protocol_telnet_begin(const BnetConnectionData *bnet)
{
    const char *username = bnet->bncs.logon.username;
    const char *password = purple_account_get_password(bnet->account);

    if (bnet_send_protocol_byte(0x03, bnet->bncs.conn.fd) < 0) {
        return (0);
    }

    if (bnet_send_telnet_line(bnet, username) < 0) {
        return (0);
    }

    if (bnet_send_telnet_line(bnet, password) < 0) {
        return (0);
    }

    return (!(0));
}

static gboolean
bnet_protocol_begin(const BnetConnectionData *bnet)
{
    if (bnet_send_protocol_byte(0x01, bnet->bncs.conn.fd) < 0) {
        return (0);
    }

    switch (bnet->bncs.versioning.type) {
        default:
        case 0x02:
            if (bnet_send_AUTH_INFO(bnet) < 0) {
                return (0);
            }
            break;
        case 0x01:
            if (bnet_send_CLIENTID2(bnet) < 0) {
                return (0);
            }
            if (bnet_send_LOCALEINFO(bnet) < 0) {
                return (0);
            }
            if (bnet_send_STARTVERSIONING(bnet) < 0) {
                return (0);
            }
            break;
        case 0x00:
            if (bnet_send_CLIENTID(bnet) < 0) {
                return (0);
            }
            if (bnet_send_LOCALEINFO(bnet) < 0) {
                return (0);
            }
            if (bnet_send_SYSTEMINFO(bnet) < 0) {
                return (0);
            }
            if (bnet_send_STARTVERSIONING(bnet) < 0) {
                return (0);
            }
            break;
    }

    return (!(0));
}

static int
bnet_send_telnet_line(const BnetConnectionData *bnet, const char *line)
{
    gsize length = strlen(line);
    gchar tmp_buffer[length + 2];
    int ret = 0;

    do { memmove ((tmp_buffer), (line), (length)); } while (0);
    tmp_buffer[length] = '\r';
    tmp_buffer[length + 1] = '\n';

    ret = write(bnet->bncs.conn.fd, tmp_buffer, length + 2);

    purple_debug_misc("bnet", "TELNET C>S: %s\n", line);

    return ret;
}

static int
bnet_send_protocol_byte(int byte, int fd)
{
    int ret = write(fd, &byte, 1);

    return ret;
}

static int
bnet_send_NULL(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);

    ret = bnet_packet_send(pkt, BNET_SID_NULL, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_STARTVERSIONING(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    BnetDwordTag platform_id = (0x49583836);
    BnetProductID product_id = bnet->bncs.versioning.product;
    guint32 version_code = bnet->bncs.versioning.version_code;
    guint32 zero = 0;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &platform_id, 4);
    bnet_packet_insert(pkt, &product_id, 4);
    bnet_packet_insert(pkt, &version_code, 4);
    bnet_packet_insert(pkt, &zero, 4);

    ret = bnet_packet_send(pkt, BNET_SID_STARTVERSIONING, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_REPORTVERSION(const BnetConnectionData *bnet,
        guint32 exe_version, guint32 exe_checksum, char *exe_info)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    BnetDwordTag platform_id = (0x49583836);
    BnetProductID product_id = bnet->bncs.versioning.product;
    guint32 version_code = bnet->bncs.versioning.version_code;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &platform_id, 4);
    bnet_packet_insert(pkt, &product_id, 4);
    bnet_packet_insert(pkt, &version_code, 4);
    bnet_packet_insert(pkt, &exe_version, 4);
    bnet_packet_insert(pkt, &exe_checksum, 4);
    bnet_packet_insert(pkt, exe_info, -1);

    ret = bnet_packet_send(pkt, BNET_SID_REPORTVERSION, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_ENTERCHAT(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    guint8 zero = 0;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, bnet->bncs.logon.username, -1);
    bnet_packet_insert(pkt, &zero, 1);

    ret = bnet_packet_send(pkt, BNET_SID_ENTERCHAT, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_GETCHANNELLIST(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &bnet->bncs.versioning.product, 4);

    ret = bnet_packet_send(pkt, BNET_SID_GETCHANNELLIST, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_JOINCHANNEL(const BnetConnectionData *bnet,
        BnetChannelJoinFlags channel_flags, char *channel)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    guint32 chflags = (guint32)channel_flags;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &chflags, 4);
    bnet_packet_insert(pkt, channel, -1);

    ret = bnet_packet_send(pkt, BNET_SID_JOINCHANNEL, bnet->bncs.conn.fd);

    return ret;
}
# 1590 "src/bnet.c"
static int
bnet_send_CHATCOMMAND(const BnetConnectionData *bnet, const char *command)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, command, -1);

    ret = bnet_packet_send(pkt, BNET_SID_CHATCOMMAND, bnet->bncs.conn.fd);

    return ret;
}
# 1619 "src/bnet.c"
static int
bnet_send_CDKEY(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    guint32 key_spawn = 0;
    BnetKey *keys = ((void *)0);
    char key_normalized[14];
    gboolean keys_are_valid = (0);

    keys = (BnetKey *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetKey); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));

    keys_are_valid = bnet_key_decode_legacy_verify_only(key_normalized,
            bnet->bncs.logon.client_cookie, bnet->bncs.logon.server_cookie,
            purple_account_get_string(bnet->account, "key1", ""));

    if (!keys_are_valid) {
        char *tmp = ((void *)0);
        tmp = g_strdup("The provided CD-key could not be decoded.");
        purple_connection_error_reason(bnet->account->gc,
                PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
                tmp);
        g_free(tmp);
        return -1;
    }

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &key_spawn, 4);
    bnet_packet_insert(pkt, key_normalized, -1);
    bnet_packet_insert(pkt, bnet->bncs.versioning.key_owner, -1);

    g_free(keys);

    ret = bnet_packet_send(pkt, BNET_SID_CDKEY, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_W3PROFILE(const BnetConnectionData *bnet, const guint32 cookie, const gchar *username)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);
    bnet_packet_insert(pkt, username, -1);

    ret = bnet_packet_send(pkt, BNET_SID_W3PROFILE, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CDKEY2(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    guint32 key_spawn = 0;
    BnetKey *keys = ((void *)0);
    gboolean keys_are_valid = (0);

    keys = (BnetKey *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetKey); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));

    keys_are_valid = bnet_key_decode_legacy(keys,
            bnet->bncs.logon.client_cookie, bnet->bncs.logon.server_cookie,
            purple_account_get_string(bnet->account, "key1", ""));

    if (!keys_are_valid) {
        char *tmp = ((void *)0);
        tmp = g_strdup("The provided CD-key could not be decoded.");
        purple_connection_error_reason(bnet->account->gc,
                PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
                tmp);
        g_free(tmp);
        return -1;
    }

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &key_spawn, 4);
    bnet_packet_insert(pkt, &keys->length, 4);
    bnet_packet_insert(pkt, &keys->product_value, 4);
    bnet_packet_insert(pkt, &keys->public_value, 4);
    bnet_packet_insert(pkt, &bnet->bncs.logon.server_cookie, 4);
    bnet_packet_insert(pkt, &bnet->bncs.logon.client_cookie, 4);
    bnet_packet_insert(pkt, keys->key_hash, 20);
    do { if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet->bncs.versioning.key_owner != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ; else g_assertion_message_expr (((gchar*) 0), "src/bnet.c", 1705, ((const char*) (__PRETTY_FUNCTION__)), "bnet->bncs.versioning.key_owner != NULL"); } while (0);
    bnet_packet_insert(pkt, bnet->bncs.versioning.key_owner, -1);

    g_free(keys);

    ret = bnet_packet_send(pkt, BNET_SID_CDKEY2, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_LOGONRESPONSE2(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    sha1_context sha;
    guint8 h1[20], h2[20];
    const char *username = bnet->bncs.logon.username;
    const char *password = purple_account_get_password(bnet->account);

    sha.version = SHA1_TYPE_BROKEN;
    sha1_reset(&sha);
    sha1_input(&sha, (guint8 *)password, strlen(password));
    sha1_digest(&sha, h1);
    sha1_reset(&sha);
    sha1_input(&sha, (guint8 *)&bnet->bncs.logon.client_cookie, 4);
    sha1_input(&sha, (guint8 *)&bnet->bncs.logon.server_cookie, 4);
    sha1_input(&sha, h1, 20);
    sha1_digest(&sha, h2);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &bnet->bncs.logon.client_cookie, 4);
    bnet_packet_insert(pkt, &bnet->bncs.logon.server_cookie, 4);
    bnet_packet_insert(pkt, h2, 20);
    bnet_packet_insert(pkt, username, -1);

    ret = bnet_packet_send(pkt, BNET_SID_LOGONRESPONSE2, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CREATEACCOUNT2(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    sha1_context sha;
    guint8 h1[20];
    const char *username = bnet->bncs.logon.username;
    const char *password = purple_account_get_password(bnet->account);

    sha.version = SHA1_TYPE_BROKEN;
    sha1_reset(&sha);
    sha1_input(&sha, (const guint8 *)password, strlen(password));
    sha1_digest(&sha, h1);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, h1, 20);
    bnet_packet_insert(pkt, username, -1);

    ret = bnet_packet_send(pkt, BNET_SID_CREATEACCOUNT2, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_LOCALEINFO(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    guint32 tz_bias = 0;
    guint32 system_lang = 1033;
    guint32 product_lang = 1033;
    char *lang_abbr = "ENU";
    char *country_abbr = "USA";
    char *country = "United States";
    char *one = "1";
    time_t t_local, t_utc;
    struct tm *tm_utc = ((void *)0);
    guint64 ft_local, ft_utc;

    t_local = time(((void *)0));
    tm_utc = gmtime(&t_local);
    t_utc = mktime(tm_utc);

    tz_bias = (guint32)(difftime(t_utc, t_local) / 60.0f);
    ft_utc = bnet_get_filetime(t_utc);
    ft_local = bnet_get_filetime(t_local);

    purple_debug_info("bnet", "tz bias %d\n", tz_bias);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &ft_utc, 8);
    bnet_packet_insert(pkt, &ft_local, 8);
    bnet_packet_insert(pkt, &tz_bias, 4);
    bnet_packet_insert(pkt, &system_lang, 4);
    bnet_packet_insert(pkt, &product_lang, 4);
    bnet_packet_insert(pkt, &product_lang, 4);
    bnet_packet_insert(pkt, lang_abbr, -1);
    bnet_packet_insert(pkt, one, -1);
    bnet_packet_insert(pkt, country_abbr, -1);
    bnet_packet_insert(pkt, country, -1);
    ret = bnet_packet_send(pkt, BNET_SID_LOCALEINFO, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLIENTID2(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    int zero = 0;
    const gchar *user = g_get_user_name();
    const gchar *host = g_get_host_name();

    purple_debug_info("bnet", "user %s @ host %s\n", user, host);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, host, -1);
    bnet_packet_insert(pkt, user, -1);

    ret = bnet_packet_send(pkt, BNET_SID_CLIENTID2, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLIENTID(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    int zero = 0;
    const gchar *user = g_get_user_name();
    const gchar *host = g_get_host_name();

    purple_debug_info("bnet", "user %s @ host %s\n", user, host);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, &zero, 4);
    bnet_packet_insert(pkt, host, -1);
    bnet_packet_insert(pkt, user, -1);

    ret = bnet_packet_send(pkt, BNET_SID_CLIENTID, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_SYSTEMINFO(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    int zero = 0;
    int i;

    pkt = bnet_packet_create(4);
    for (i = 0; i < 7; i++) {
        bnet_packet_insert(pkt, &zero, 4);
    }

    ret = bnet_packet_send(pkt, BNET_SID_SYSTEMINFO, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_PING(const BnetConnectionData *bnet, guint32 cookie)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);

    ret = bnet_packet_send(pkt, BNET_SID_PING, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_READUSERDATA(const BnetConnectionData *bnet,
        int request_cookie, const char *username, char **keys)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    int account_count = 1;
    int key_count = g_strv_length(keys);
    int i = 0;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &account_count, 4);
    bnet_packet_insert(pkt, &key_count, 4);
    bnet_packet_insert(pkt, &request_cookie, 4);
    bnet_packet_insert(pkt, username, -1);
    for (i = 0; i < key_count; i++) {
        bnet_packet_insert(pkt, keys[i], -1);
    }

    ret = bnet_packet_send(pkt, BNET_SID_READUSERDATA, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_WRITEUSERDATA(const BnetConnectionData *bnet,
        const char *sex, const char *age, const char *location, const char *description)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    int account_count = 1;
    int key_count = 4;
    const char *k_sex = "profile\\sex";
    const char *k_age = "profile\\age";
    const char *k_location = "profile\\location";
    const char *k_description = "profile\\description";

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &account_count, 4);
    bnet_packet_insert(pkt, &key_count, 4);
    bnet_packet_insert(pkt, bnet->bncs.logon.username, -1);
    bnet_packet_insert(pkt, k_sex, -1);
    bnet_packet_insert(pkt, k_age, -1);
    bnet_packet_insert(pkt, k_location, -1);
    bnet_packet_insert(pkt, k_description, -1);
    bnet_packet_insert(pkt, sex, -1);
    bnet_packet_insert(pkt, age, -1);
    bnet_packet_insert(pkt, location, -1);
    bnet_packet_insert(pkt, description, -1);

    ret = bnet_packet_send(pkt, BNET_SID_WRITEUSERDATA, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_LOGONREALMEX(const BnetConnectionData *bnet, const guint32 client_cookie, const guint8 password_hash[20], const gchar *realm_name)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &client_cookie, 4);
    bnet_packet_insert(pkt, password_hash, 20);
    bnet_packet_insert(pkt, realm_name, -1);

    ret = bnet_packet_send(pkt, BNET_SID_LOGONREALMEX, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_QUERYREALMS2(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);

    ret = bnet_packet_send(pkt, BNET_SID_QUERYREALMS2, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_W3GENERAL_USERRECORD(const BnetConnectionData *bnet, guint32 cookie, const gchar *username, BnetProductID product)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    BnetW3GeneralSubcommand subcommand = BNET_WID_USERRECORD;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &subcommand, 1);
    bnet_packet_insert(pkt, &cookie, 4);
    bnet_packet_insert(pkt, username, -1);
    bnet_packet_insert(pkt, &product, 4);

    ret = bnet_packet_send(pkt, BNET_SID_W3GENERAL, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_W3GENERAL_CLANRECORD(const BnetConnectionData *bnet, guint32 cookie, BnetClanTag clan_tag, BnetProductID product)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    BnetW3GeneralSubcommand subcommand = BNET_WID_CLANRECORD;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &subcommand, 1);
    bnet_packet_insert(pkt, &cookie, 4);
    bnet_packet_insert(pkt, &clan_tag, 4);
    bnet_packet_insert(pkt, &product, 4);

    ret = bnet_packet_send(pkt, BNET_SID_W3GENERAL, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_NEWS_INFO(const BnetConnectionData *bnet, guint32 news_latest)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &news_latest, 4);

    ret = bnet_packet_send(pkt, BNET_SID_NEWS_INFO, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_AUTH_INFO(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    guint32 protocol_id = 0;
    BnetDwordTag platform_id = (0x49583836);
    BnetProductID product_id = bnet->bncs.versioning.product;
    guint32 version_code = bnet->bncs.versioning.version_code;
    BnetDwordTag product_lang = (0x656e5553);
    union {
        guint32 as_int32;
        guchar as_arr[4];
    } local_ip;
    guint32 tz_bias = 0;
    guint32 mpq_lang = 1033;
    guint32 system_lang = 1033;
    char *country_abbr = "USA";
    char *country = "United States";

    const char *c_local_ip = purple_network_get_local_system_ip(bnet->bncs.conn.fd);
    do { memmove ((local_ip.as_arr), (purple_network_ip_atoi(c_local_ip)), (4)); } while (0);

    tz_bias = (guint32)(bnet_get_tz_bias() / 60.0f);

    purple_debug_info("bnet", "local ip %s\n", c_local_ip);
    purple_debug_info("bnet", "tz bias %d\n", tz_bias);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &protocol_id, 4);
    bnet_packet_insert(pkt, &platform_id, 4);
    bnet_packet_insert(pkt, &product_id, 4);
    bnet_packet_insert(pkt, &version_code, 4);
    bnet_packet_insert(pkt, &product_lang, 4);
    bnet_packet_insert(pkt, &local_ip.as_int32, 4);
    bnet_packet_insert(pkt, &tz_bias, 4);
    bnet_packet_insert(pkt, &mpq_lang, 4);
    bnet_packet_insert(pkt, &system_lang, 4);
    bnet_packet_insert(pkt, country_abbr, -1);
    bnet_packet_insert(pkt, country, -1);



    ret = bnet_packet_send(pkt, BNET_SID_AUTH_INFO, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_AUTH_CHECK(const BnetConnectionData *bnet,
        guint32 exe_version, guint32 exe_checksum, char *exe_info)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    guint32 key_count = 0;
    guint32 key_spawn = 0;
    BnetKey *keys = ((void *)0);
    int i = 0;
    gboolean keys_are_valid = (0);

    purple_debug_info("bnet", "server cookie: %08x\n", bnet->bncs.logon.server_cookie);
    purple_debug_info("bnet", "client cookie: %08x\n", bnet->bncs.logon.client_cookie);

    key_count = bnet_get_key_count(bnet);

    keys = (BnetKey *) (__extension__ ({ gsize __n = (gsize) (2); gsize __s = sizeof (BnetKey); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));

    keys_are_valid = bnet_key_decode(keys, key_count,
            bnet->bncs.logon.client_cookie, bnet->bncs.logon.server_cookie,
            purple_account_get_string(bnet->account, "key1", ""),
            purple_account_get_string(bnet->account, "key2", ""));

    if (!keys_are_valid) {
        const char *exp = "";
        char *tmp = ((void *)0);
        if (keys[0].length > 0) {

            exp = "expansion ";
        }
        tmp = g_strdup_printf("The provided %sCD-key could not be decoded.", exp);
        purple_connection_error_reason(bnet->account->gc,
                PURPLE_CONNECTION_ERROR_INVALID_SETTINGS,
                tmp);
        g_free(tmp);
        return -1;
    }

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &bnet->bncs.logon.client_cookie, 4);
    bnet_packet_insert(pkt, &exe_version, 4);
    bnet_packet_insert(pkt, &exe_checksum, 4);
    bnet_packet_insert(pkt, &key_count, 4);
    bnet_packet_insert(pkt, &key_spawn, 4);
    for (; i < key_count; i++) {
        bnet_packet_insert(pkt, &keys[i], sizeof(BnetKey));
    }
    bnet_packet_insert(pkt, exe_info, -1);
    do { if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet->bncs.versioning.key_owner != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ; else g_assertion_message_expr (((gchar*) 0), "src/bnet.c", 2126, ((const char*) (__PRETTY_FUNCTION__)), "bnet->bncs.versioning.key_owner != NULL"); } while (0);
    bnet_packet_insert(pkt, bnet->bncs.versioning.key_owner, -1);

    g_free(keys);

    ret = bnet_packet_send(pkt, BNET_SID_AUTH_CHECK, bnet->bncs.conn.fd);

    return ret;
}


static int
bnet_send_AUTH_ACCOUNTCREATE(const BnetConnectionData *bnet, char *salt_and_v)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    const char *username = bnet->bncs.logon.username;

    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (username != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "username != NULL"); return (-1); }; }while (0);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, salt_and_v, 64);
    bnet_packet_insert(pkt, username, -1);

    ret = bnet_packet_send(pkt, BNET_SID_AUTH_ACCOUNTCREATE, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_AUTH_ACCOUNTLOGON(const BnetConnectionData *bnet, char *A)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    const char *username = bnet->bncs.logon.username;

    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (username != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "username != NULL"); return (-1); }; }while (0);

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, A, 32);
    bnet_packet_insert(pkt, username, -1);

    ret = bnet_packet_send(pkt, BNET_SID_AUTH_ACCOUNTLOGON, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_AUTH_ACCOUNTLOGONPROOF(const BnetConnectionData *bnet, char *M1)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, M1, 20);

    ret = bnet_packet_send(pkt, BNET_SID_AUTH_ACCOUNTLOGONPROOF, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_SETEMAIL(const BnetConnectionData *bnet, const char *email)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, email, -1);

    ret = bnet_packet_send(pkt, BNET_SID_SETEMAIL, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_FRIENDSLIST(const BnetConnectionData *bnet)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);

    ret = bnet_packet_send(pkt, BNET_SID_FRIENDSLIST, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLANCREATIONINVITATION(const BnetConnectionData *bnet, const int cookie,
        const BnetClanTag clan_tag, const gchar *inviter_name, gboolean accept)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    BnetClanResponseCode response = 0x04;
    if (accept) {
        response = 0x06;
    }

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);
    bnet_packet_insert(pkt, &clan_tag, 4);
    bnet_packet_insert(pkt, inviter_name, -1);
    bnet_packet_insert(pkt, &response, 1);

    ret = bnet_packet_send(pkt, BNET_SID_CLANCREATIONINVITATION, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLANINVITATIONRESPONSE(const BnetConnectionData *bnet, const int cookie,
        const BnetClanTag clan_tag, const gchar *inviter_name, gboolean accept)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;
    BnetClanResponseCode response = 0x04;
    if (accept) {
        response = 0x06;
    }

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);
    bnet_packet_insert(pkt, &clan_tag, 4);
    bnet_packet_insert(pkt, inviter_name, -1);
    bnet_packet_insert(pkt, &response, 1);

    ret = bnet_packet_send(pkt, BNET_SID_CLANINVITATIONRESPONSE, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLANSETMOTD(const BnetConnectionData *bnet, const int cookie, const gchar *motd)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);
    bnet_packet_insert(pkt, motd, -1);

    ret = bnet_packet_send(pkt, BNET_SID_CLANSETMOTD, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLANMOTD(const BnetConnectionData *bnet, const int cookie)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);

    ret = bnet_packet_send(pkt, BNET_SID_CLANMOTD, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLANMEMBERLIST(const BnetConnectionData *bnet, const int cookie)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);

    ret = bnet_packet_send(pkt, BNET_SID_CLANMEMBERLIST, bnet->bncs.conn.fd);

    return ret;
}

static int
bnet_send_CLANMEMBERINFO(const BnetConnectionData *bnet, const int cookie, const BnetClanTag tag, const gchar *username)
{
    BnetPacket *pkt = ((void *)0);
    int ret = -1;

    pkt = bnet_packet_create(4);
    bnet_packet_insert(pkt, &cookie, 4);
    bnet_packet_insert(pkt, &tag, 4);
    bnet_packet_insert(pkt, username, -1);

    ret = bnet_packet_send(pkt, BNET_SID_CLANMEMBERINFO, bnet->bncs.conn.fd);

    return ret;
}

static void
bnet_account_logon(BnetConnectionData *bnet)
{
    if (bnet->bncs.logon.type == 0) {
        if (bnet->bncs.logon.create_account) {
            bnet_send_CREATEACCOUNT2(bnet);
        } else {
            bnet_account_lockout_set(bnet);
            bnet_send_LOGONRESPONSE2(bnet);
        }
    } else {
        const char *username = bnet->bncs.logon.username;
        const char *password = purple_account_get_password(bnet->account);
        bnet->bncs.logon.auth_ctx = srp_init(username, password);
        if (bnet->bncs.logon.create_account) {
            gchar salt_and_v[64];
            srp_generate_salt_and_v(bnet->bncs.logon.auth_ctx, salt_and_v);
            bnet_send_AUTH_ACCOUNTCREATE(bnet, salt_and_v);
        } else {
            gchar A[32];
            srp_get_A(bnet->bncs.logon.auth_ctx, A);
            bnet_account_lockout_set(bnet);
            bnet_send_AUTH_ACCOUNTLOGON(bnet, A);
        }
    }
}

static void
bnet_enter_channel(const BnetConnectionData *bnet)
{
    bnet_send_JOINCHANNEL(bnet,
            (BnetChannelJoinFlags)
            (BNET_CHANNELJOIN_FIRSTJOIN |
             (bnet_is_d2(bnet) ? BNET_CHANNELJOIN_D2FIRST : 0)), "Lobby");
}

static void
bnet_realm_logon_cb(BnetConnectionData *bnet)
{
    bnet_send_GETCHANNELLIST(bnet);
    bnet_send_ENTERCHAT(bnet);
}

static void
bnet_enter_chat(BnetConnectionData *bnet)
{
    if (bnet_is_d2(bnet)) {
        if (purple_account_get_bool(bnet->account, "use_d2realm", (0))) {
            bnet->d2mcp.on_character = (0);
            bnet_send_QUERYREALMS2(bnet);
        } else {
            bnet_realm_logon_cb(bnet);
        }
    } else if (bnet_is_w3(bnet)) {

        bnet_send_GETCHANNELLIST(bnet);
        bnet_send_ENTERCHAT(bnet);
    } else {

        bnet_send_ENTERCHAT(bnet);
        bnet_send_GETCHANNELLIST(bnet);
        bnet->bncs.chat_env.sent_enter_channel = (!(0));
        bnet_enter_channel(bnet);
        bnet_news_load(bnet);
        bnet_send_NEWS_INFO(bnet, bnet->bncs.news.latest);
    }
    bnet_send_FRIENDSLIST(bnet);
}

static int
bnet_realm_logon(const BnetConnectionData *bnet, const guint32 client_cookie,
            const gchar *realm_name, const gchar *realm_pass)
{
    guint8 h1[20];
    guint8 h2[20];
    sha1_context sha;

    sha.version = SHA1_TYPE_BROKEN;
    sha1_reset(&sha);
    sha1_input(&sha, (guint8 *)realm_pass, strlen(realm_pass));
    sha1_digest(&sha, h1);
    sha1_reset(&sha);
    sha1_input(&sha, (guint8 *)&client_cookie, 4);
    sha1_input(&sha, (guint8 *)&bnet->bncs.logon.server_cookie, 4);
    sha1_input(&sha, h1, 20);
    sha1_digest(&sha, h2);

    purple_debug_info("bnet", "MCP Logging on to %s...\n", realm_name);

    return bnet_send_LOGONREALMEX(bnet, client_cookie, h2, realm_name);
}

static void
bnet_realm_connect(BnetConnectionData *bnet, struct sockaddr_in d2mcp_addr,
        const guint32 d2mcp_data[16], const gchar *bncs_unique_username)
{
    PurpleConnection *gc = bnet->account->gc;
    PurpleProxyConnectData *d2mcp_conn_data;
    char *addr_name = g_strdup(inet_ntoa(d2mcp_addr.sin_addr));
    int i;

    bnet->d2mcp.conn.server = addr_name;
    bnet->d2mcp.conn.port = d2mcp_addr.sin_port;
    for (i = 0; i < 16; i++) {
        bnet->d2mcp.logon_data[i] = d2mcp_data[i];
    }
    bnet->bncs.chat_env.unique_name = g_strdup(bncs_unique_username);
    purple_connection_set_display_name(gc, bnet->bncs.logon.username);

    purple_debug_info("bnet", "Connecting to MCP %s:%d...\n", addr_name,
            d2mcp_addr.sin_port);
    d2mcp_conn_data = purple_proxy_connect(gc, bnet->account, addr_name,
            d2mcp_addr.sin_port, bnet_realm_login_cb, gc);
    if (d2mcp_conn_data == ((void *)0)) {
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                "Unable to connect to the MCP server");
        return;
    }
    bnet->d2mcp.conn.prpl_conn_data = d2mcp_conn_data;
}

static void
bnet_request_cancel_realm_server_cb(gpointer data)
{
    BnetConnectionData *bnet;

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    bnet_realm_logon_cb(bnet);
}


static void
bnet_request_choose_realm_server_cb(gpointer data)
{
    BnetConnectionData *bnet;
    PurpleRequestFields *fields;
    GList *group_list; PurpleRequestFieldGroup *group;
    GList *field_list; PurpleRequestField *field;
    BnetD2RealmServer *server = ((void *)0);

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    fields = bnet->d2mcp.prpl_realmlist_fields_handle;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (fields != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "fields != NULL"); return; }; }while (0);
    group_list = g_list_first(purple_request_fields_get_groups(fields));
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group_list != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group_list != NULL"); return; }; }while (0);
    group = group_list->data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group != NULL"); return; }; }while (0);
    field_list = g_list_first(purple_request_field_group_get_fields(group));

    while (field_list != ((void *)0)) {
        field = field_list->data;
        if (field != ((void *)0)) {
            const gchar *name = purple_request_field_get_id(field);
            if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name) && __builtin_constant_p ("servers") && (__s1_len = strlen (name), __s2_len = strlen ("servers"), (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("servers") + 1) - (size_t)(const void *)("servers") == 1) || __s2_len >= 4)) ? __builtin_strcmp (name, "servers") : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s1_len = strlen (name), __s1_len < 4) ? (__builtin_constant_p ("servers") && ((size_t)(const void *)(("servers") + 1) - (size_t)(const void *)("servers") == 1) ? __builtin_strcmp (name, "servers") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("servers"); register int __result = (((const unsigned char *) (const char *) (name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("servers") && ((size_t)(const void *)(("servers") + 1) - (size_t)(const void *)("servers") == 1) && (__s2_len = strlen ("servers"), __s2_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (name, "servers") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("servers"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("servers"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("servers"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("servers"))[3]); } } __result; }))) : __builtin_strcmp (name, "servers")))); }) == 0) {
                GList *sel = purple_request_field_list_get_selected(field);
                if (sel != ((void *)0)) {
                    server = sel->data;
                }
            }
        }
        field_list = ((field_list) ? (((GList *)(field_list))->next) : ((void *)0));
    }
    if (server != ((void *)0)) {
        const gchar *d2realm_pass = purple_account_get_string(bnet->account, "d2realm_pass", "password");
        bnet_realm_logon(bnet, bnet->bncs.logon.client_cookie, server->name, d2realm_pass);
    } else {
        bnet_realm_logon_cb(bnet);
    }
}

static void
bnet_realm_server_list(BnetConnectionData *bnet, GList *server_list)
{
    GList *el;
    PurpleRequestField *field;
    PurpleRequestFields *fields = purple_request_fields_new();
    PurpleRequestFieldGroup *group = purple_request_field_group_new("Choose a realm to connect to.");

    field = purple_request_field_list_new("realms", "Realms");
    purple_request_field_group_add_field(group, field);
    purple_request_field_list_set_multi_select(field, (0));
    el = g_list_first(server_list);
    while (el != ((void *)0)) {
        BnetD2RealmServer *server = el->data;
        purple_request_field_list_add(field, server->name, server);
        el = ((el) ? (((GList *)(el))->next) : ((void *)0));
    }

    purple_request_fields_add_group(fields, group);

    bnet->d2mcp.prpl_realmlist_fields_handle = fields;

    purple_request_fields(bnet->account->gc, "Choose a Diablo II Realm Server",
            ((void *)0),
            "Select a realm to log in to, then click Choose.",
            fields,
            "_Choose", (GCallback)bnet_request_choose_realm_server_cb,
            "_Cancel", (GCallback)bnet_request_cancel_realm_server_cb,
            bnet->account,
            ((void *)0), ((void *)0),
            bnet);
}

static void
bnet_request_cancel_realm_character_cb(gpointer data)
{
    BnetConnectionData *bnet;

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    bnet_realm_logon_cb(bnet);
}

static void
bnet_request_choose_realm_character_cb(gpointer data)
{
    BnetConnectionData *bnet;
    PurpleRequestFields *fields;
    GList *group_list; PurpleRequestFieldGroup *group;
    GList *field_list; PurpleRequestField *field;
    BnetD2RealmCharacter *character = ((void *)0);

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    fields = bnet->d2mcp.prpl_charlist_fields_handle;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (fields != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "fields != NULL"); return; }; }while (0);
    group_list = g_list_first(purple_request_fields_get_groups(fields));
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group_list != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group_list != NULL"); return; }; }while (0);
    group = group_list->data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group != NULL"); return; }; }while (0);
    field_list = g_list_first(purple_request_field_group_get_fields(group));

    while (field_list != ((void *)0)) {
        field = field_list->data;
        if (field != ((void *)0)) {
            const gchar *name = purple_request_field_get_id(field);
            if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name) && __builtin_constant_p ("characters") && (__s1_len = strlen (name), __s2_len = strlen ("characters"), (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("characters") + 1) - (size_t)(const void *)("characters") == 1) || __s2_len >= 4)) ? __builtin_strcmp (name, "characters") : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s1_len = strlen (name), __s1_len < 4) ? (__builtin_constant_p ("characters") && ((size_t)(const void *)(("characters") + 1) - (size_t)(const void *)("characters") == 1) ? __builtin_strcmp (name, "characters") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("characters"); register int __result = (((const unsigned char *) (const char *) (name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("characters") && ((size_t)(const void *)(("characters") + 1) - (size_t)(const void *)("characters") == 1) && (__s2_len = strlen ("characters"), __s2_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (name, "characters") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("characters"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("characters"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("characters"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("characters"))[3]); } } __result; }))) : __builtin_strcmp (name, "characters")))); }) == 0) {
                GList *sel = purple_request_field_list_get_selected(field);
                if (sel != ((void *)0)) {
                    character = sel->data;
                }
            }
        }
        field_list = ((field_list) ? (((GList *)(field_list))->next) : ((void *)0));
    }
    if (character != ((void *)0)) {
        bnet_realm_send_CHARLOGON(bnet, character->name);
    } else {
        bnet_realm_logon_cb(bnet);
    }
}

static void
bnet_realm_character_list(BnetConnectionData *bnet, GList *char_list)
{
    GList *el;
    PurpleRequestField *field;
    PurpleRequestFields *fields = purple_request_fields_new();
    PurpleRequestFieldGroup *group = purple_request_field_group_new("Choose a character to log on as.");

    field = purple_request_field_list_new("characters", "Characters");
    purple_request_field_group_add_field(group, field);
    purple_request_field_list_set_multi_select(field, (0));
    el = g_list_first(char_list);
    while (el != ((void *)0)) {
        BnetD2RealmCharacter *character = el->data;
        purple_request_field_list_add(field, character->name, character);
        el = ((el) ? (((GList *)(el))->next) : ((void *)0));
    }

    purple_request_fields_add_group(fields, group);

    bnet->d2mcp.prpl_charlist_fields_handle = fields;

    purple_request_fields(bnet->account->gc, "Choose a Diablo II Character",
            ((void *)0),
            "Select a character to log in as, then click Choose.",
            fields,
            "_Choose", (GCallback)bnet_request_choose_realm_character_cb,
            "_Cancel", (GCallback)bnet_request_cancel_realm_character_cb,
            bnet->account,
            ((void *)0), ((void *)0),
            bnet);
}

static gboolean
bnet_updatelist_timer(BnetConnectionData *bnet)
{

    int tick = ++bnet->bncs.chat_env.updatelist_timer_tick;

    if (!bnet_is_telnet(bnet)) {
        if (bnet_is_w3(bnet) || bnet_is_scrt(bnet)) {

            if ((tick % 8) == 0) {
                bnet_send_FRIENDSLIST(bnet);
            }
        } else {

            if ((tick % 2) == 0) {
                bnet_send_FRIENDSLIST(bnet);
            }
        }

        if (bnet_clan_in_clan(bnet)) {

            if ((tick % 32) == 30) {
                int memblist_cookie = bnet_packet_cookie_register(bnet,
                        BNET_SID_CLANMEMBERLIST, ((void *)0));
                bnet_send_CLANMEMBERLIST(bnet, memblist_cookie);
            }


            if ((tick % 8) == 4) {
                int motd_cookie = bnet_packet_cookie_register(bnet,
                        BNET_SID_CLANMOTD, ((void *)0));
                bnet_send_CLANMOTD(bnet, motd_cookie);
            }
        }
    }

    return (!(0));
}

static void
bnet_keepalive(PurpleConnection *gc)
{
    BnetConnectionData *bnet = gc->proto_data;

    if (bnet_is_telnet(bnet)) {
        bnet_send_telnet_line(bnet, "");
    } else {
        bnet_send_NULL(bnet);
    }
}

static void
bnet_account_lockout_set(BnetConnectionData *bnet)
{
    bnet->bncs.logon.lockout_timer_handle =
        purple_timeout_add_seconds(10, (GSourceFunc)bnet_account_lockout_timer, bnet);
}

static void
bnet_account_lockout_cancel(BnetConnectionData *bnet)
{
    if (bnet->bncs.logon.lockout_timer_handle != 0) {
        purple_timeout_remove(bnet->bncs.logon.lockout_timer_handle);
        bnet->bncs.logon.lockout_timer_handle = 0;
    }
}

static gboolean
bnet_account_lockout_timer(BnetConnectionData *bnet)
{
    purple_connection_error_reason(bnet->account->gc,
            PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
            "Logging on is taking too long. You are likely locked out of this account. "
            "Try again in 30 minutes.");

    bnet->bncs.logon.lockout_timer_handle = 0;

    return (0);
}

static void
bnet_account_register(PurpleAccount *account)
{
    purple_debug_info("bnet", "REGISTER ACCOUNT REQUEST");
    bnet_connect(account, (!(0)));
}

static void
bnet_account_chpw(PurpleConnection *gc, const char *oldpass, const char *newpass)
{


    purple_debug_info("bnet", "CHANGE PASSWORD REQUEST");



}

static void
bnet_input_cb(gpointer data, gint source, PurpleInputCondition cond)
{
    PurpleConnection *gc = data;
    BnetConnectionData *bnet = gc->proto_data;
    int len = 0;

    do { if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0) && bnet->magic == (0x626e6574)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ; else g_assertion_message_expr (((gchar*) 0), "src/bnet.c", 2712, ((const char*) (__PRETTY_FUNCTION__)), "bnet != NULL && bnet->magic == BNET_UDP_SIG"); } while (0);

    if (bnet->bncs.conn.inbuf_length < bnet->bncs.conn.inbuf_used + 512) {
        purple_debug_info("bnet", "expanding recv buffer\n");
        bnet->bncs.conn.inbuf_length += 512;
        bnet->bncs.conn.inbuf = g_realloc(bnet->bncs.conn.inbuf, bnet->bncs.conn.inbuf_length);
    }

    len = read(bnet->bncs.conn.fd, bnet->bncs.conn.inbuf + bnet->bncs.conn.inbuf_used, bnet->bncs.conn.inbuf_length - bnet->bncs.conn.inbuf_used);
    if (len < 0 && (*__errno_location ()) == 11) {
        return;
    } else if (len < 0) {
        gchar *tmp = ((void *)0);
        tmp = g_strdup_printf("Lost connection with server: %s\n",
                g_strerror((*__errno_location ())));
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR, tmp);
        purple_debug_info("bnet", tmp);
        g_free(tmp);
        if (bnet->bncs.conn.fd != 0) {
            bnet_input_free(&bnet->bncs.conn);
        }
        return;
    } else if (len == 0) {
        purple_connection_error_reason(gc,
                PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
                "Server closed the connection\n");
        purple_debug_info("bnet", "BNCS disconnected.\n");
        if (bnet->bncs.conn.fd != 0) {
            bnet_input_free(&bnet->bncs.conn);
        }
        return;
    }

    if (bnet_is_telnet(bnet)) {
        bnet_read_telnet_input(bnet, len);
    } else {
        bnet_read_input(bnet, len);
    }
}

static void
bnet_read_telnet_input(BnetConnectionData *bnet, int len)
{
    gchar *this_start = ((void *)0);
    gchar *this_end = ((void *)0);
    guint16 this_len = len;

    bnet->account->gc->last_received = time(((void *)0));
    bnet->bncs.conn.inbuf_used += len;

    this_start = bnet->bncs.conn.inbuf;
    do { if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (this_start != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ; else g_assertion_message_expr (((gchar*) 0), "src/bnet.c", 2764, ((const char*) (__PRETTY_FUNCTION__)), "this_start != NULL"); } while (0);
    this_len = len;
    while (this_start + 2 <= bnet->bncs.conn.inbuf + bnet->bncs.conn.inbuf_used) {
        this_end = g_strstr_len(this_start, this_len, "\r\n");
        if (this_end != ((void *)0)) {
            this_len = this_end - this_start;
            *this_end = '\0';
            bnet_parse_telnet_line(bnet, this_start);
            if (bnet->bncs.conn.fd == 0) {

                return;
            }
            this_start += this_len + 2;
            this_len = len - this_len - 2;
        } else break;
    }

    if (this_start == bnet->bncs.conn.inbuf) {

    } else if (this_start != bnet->bncs.conn.inbuf + bnet->bncs.conn.inbuf_used) {

        bnet->bncs.conn.inbuf_used -= (this_start - bnet->bncs.conn.inbuf);
        memmove(bnet->bncs.conn.inbuf, this_start, bnet->bncs.conn.inbuf_used);
    } else {

        bnet->bncs.conn.inbuf_used = 0;
    }
}

static void
bnet_read_input(BnetConnectionData *bnet, int len)
{
    gchar *this_start = ((void *)0);
    guint16 inbuftouse = 0;

    bnet->account->gc->last_received = time(((void *)0));
    bnet->bncs.conn.inbuf_used += len;

    this_start = bnet->bncs.conn.inbuf;

    while (this_start + 4 <= bnet->bncs.conn.inbuf + bnet->bncs.conn.inbuf_used) {
#pragma pack(push)
#pragma pack(1)
        struct {
            guint8 flag;
            guint8 id;
            guint16 len;
        } *header = (void *)this_start;
#pragma pack(pop)
        inbuftouse += header->len;
        do { if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (header->len != 0xFF) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) ; else g_assertion_message_expr (((gchar*) 0), "src/bnet.c", 2814, ((const char*) (__PRETTY_FUNCTION__)), "header->len != BNET_IDENT_FLAG"); } while (0);
        if (inbuftouse <= bnet->bncs.conn.inbuf_used) {
            bnet_parse_packet(bnet, header->id, this_start, header->len);
            if (bnet->bncs.conn.fd == 0) {

                return;
            }
            this_start += header->len;
        } else break;
    }

    if (this_start == bnet->bncs.conn.inbuf) {

    } else if (this_start != bnet->bncs.conn.inbuf + bnet->bncs.conn.inbuf_used) {

        bnet->bncs.conn.inbuf_used -= (this_start - bnet->bncs.conn.inbuf);
        memmove(bnet->bncs.conn.inbuf, this_start, bnet->bncs.conn.inbuf_used);
    } else {

        bnet->bncs.conn.inbuf_used = 0;
    }
}







static void
bnet_recv_STARTVERSIONING(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint64 mpq_ft = bnet_packet_read_qword(pkt);
    char* mpq_fn = bnet_packet_read_cstring(pkt);
    char* checksum_formula = bnet_packet_read_cstring(pkt);

    bnet_bnls_send_VERSIONCHECKEX2(bnet,
            bnet->bncs.logon.type, bnet->bncs.logon.server_cookie, bnet->bncs.logon.session_cookie, mpq_ft, mpq_fn, checksum_formula);

    g_free(mpq_fn);
    g_free(checksum_formula);
}

static void
bnet_recv_REPORTVERSION(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 result = bnet_packet_read_dword(pkt);
    char *extra_info = bnet_packet_read_cstring(pkt);

    PurpleConnection *gc = bnet->account->gc;

    char *tmp = ((void *)0);
    char *tmpe = ((void *)0);
    char *tmpf = ((void *)0);

    PurpleConnectionError conn_error = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;

    switch (result) {
        case 0x02:
            {
                int key_count = bnet_get_key_count(bnet);

                bnet->bncs.versioning.complete = (!(0));
                purple_debug_info("bnet", "Version check passed!\n");

                if (key_count > 0) {
                    switch (bnet->bncs.versioning.type) {
                        case 0x00:
                            bnet_send_CDKEY(bnet);
                            break;
                        case 0x01:
                            bnet_send_CDKEY2(bnet);
                            break;
                        default:
                            purple_debug_fatal("bnet", "Received SID_REPORTVERSION during AUTH logon sequence. Key required for this product. Unknown next packet. Logging on to account instead.");

                            if (!bnet->bncs.logon.create_account) {
                                purple_connection_update_progress(gc, "Authenticating", 3, 5);
                            }

                            bnet_account_logon(bnet);
                            break;
                    }
                } else {
                    if (!bnet->bncs.logon.create_account) {
                        purple_connection_update_progress(gc, "Authenticating", 3, 5);
                    }

                    bnet_account_logon(bnet);
                }
                g_free(extra_info);
                return;
            }
        case 0x00:
            tmp = "Version check failed%s.";
            break;
        case 0x01:
            tmp = "Old version%s.";
            break;
        case 0x03:
            tmp = "Version invalid%s.";
            break;
        default:
            tmp = "Version check failed%s.";
            break;
    }

    tmpe = g_strdup_printf(" (%s)", extra_info);
    tmpf = g_strdup_printf(tmp, strlen(extra_info) > 0 ? tmpe : "");
    purple_connection_error_reason(gc, conn_error, tmpf);

    g_free(tmpe);
    g_free(tmpf);

    g_free(extra_info);
}

static void
bnet_recv_ENTERCHAT(BnetConnectionData *bnet, BnetPacket *pkt)
{
    char *unique_username = bnet_packet_read_cstring(pkt);
    char *statstring = bnet_packet_read_cstring(pkt);
    char *account = bnet_packet_read_cstring(pkt);

    bnet->bncs.chat_env.stats = statstring;
    bnet->bncs.chat_env.unique_name = unique_username;
    purple_connection_set_display_name(bnet->account->gc, bnet->bncs.logon.username);
    g_free(account);

    if (bnet_is_d2(bnet) || bnet_is_w3(bnet)) {

        bnet_news_load(bnet);
        bnet_send_NEWS_INFO(bnet, bnet->bncs.news.latest);
    }
}

static void
bnet_recv_GETCHANNELLIST(BnetConnectionData *bnet, BnetPacket *pkt)
{
    char *channel = ((void *)0);

    while ((!(0))) {
        channel = bnet_packet_read_cstring(pkt);
        if (channel == ((void *)0)) {
            break;
        } else if (strlen(channel) == 0) {
            g_free(channel);
            break;
        }
        bnet->bncs.chat_env.channel_list = g_list_prepend(bnet->bncs.chat_env.channel_list, channel);
    }

    bnet->bncs.chat_env.channel_list = g_list_reverse(bnet->bncs.chat_env.channel_list);
}

static char *
bnet_standardize_newlines(const char *input)
{
    char *i = g_strdup(input);
    char *i_line = ((void *)0);
    i_line = g_strstr_len(i, -1, "\n");
    while (i_line != ((void *)0)) {
        char *tmp1;
        char *tmp2;
        int len1, len2;
        if (i_line == i || *(i_line - 1) != '\r') {
            *i_line = '\0';
            len1 = strlen(i);
            len2 = strlen(i_line + 1);
            tmp1 = g_malloc0(len1 + len2 + 3);
            tmp2 = g_strdup(i_line + 1);
            do { memmove ((tmp1), (i), (len1)); } while (0);
            tmp1[len1 + 0] = '\r';
            tmp1[len1 + 1] = '\n';
            g_strlcat(tmp1, tmp2, len1 + len2 + 3);
            g_free(i);
            g_free(tmp2);
            i = tmp1;
            i_line = i + len1 + 1;
        }
        i_line = g_strstr_len(i_line + 1, -1, "\n");
    }
    return i;
}

static char *
bnet_to_utf8_crlf(const char *input)
{
    if (input == ((void *)0)) return g_strdup("");

    if (g_utf8_validate(input, -1, ((void *)0))) {
        return bnet_standardize_newlines(input);
    } else {
        gchar *tmp = purple_utf8_try_convert(input);
        gchar *std = bnet_standardize_newlines(tmp);
        g_free(tmp);
        return std;
    }
}

static char *
bnet_utf8_to_iso88591(const char *input)
{
    GError *err = ((void *)0);
    char *output = g_convert_with_fallback(input, -1, "ISO-8859-1", "UTF-8", ((void *)0), ((void *)0), ((void *)0), &err);
    if (err != ((void *)0)) {
        purple_debug_error("bnet", "Unable to convert to ISO-8859-1 from UTF-8: %s\n", err->message);
        if (output == ((void *)0)) {
            output = g_strdup(err->message);
        }
        g_error_free(err);
        return output;
    }

    return output;
}

static void
bnet_recv_event_SHOWUSER(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    PurpleConnection *gc = bnet->account->gc;
    GList *li = ((void *)0);

    li = g_list_find_custom(bnet->bncs.channel.user_list, name, bnet_channel_user_compare);
    if (li != ((void *)0)) {

        BnetChannelUser *bcu = li->data;

        bcu->flags = flags;
        bcu->ping = ping;
        if (strlen(text) > 0) {
            g_free(bcu->stats_data);
            bcu->stats_data = g_strdup(text);
        }
        if (chat != ((void *)0)) {
            purple_conv_chat_user_set_flags(chat, name,
                    bnet_channel_flags_to_prpl_flags(flags));
        }
    } else {

        gchar *name_normal = ((void *)0);
        gchar *my_unique_username = ((void *)0);
        BnetChannelUser *bcu = (BnetChannelUser *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetChannelUser); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));

        bcu->type = 0x01;
        bcu->username = g_strdup(name);
        bcu->stats_data = g_strdup(text);
        bcu->flags = flags;
        bcu->ping = ping;
        bcu->hidden = (0);
        bnet->bncs.channel.user_list = g_list_append(bnet->bncs.channel.user_list, bcu);
        if (bnet->bncs.channel.seen_self) {
            if (chat != ((void *)0)) {
                gchar *channel_message = bnet_channel_message_parse(bcu->stats_data, flags, ping);
                purple_conv_chat_add_user(chat, name,
                        channel_message,
                        bnet_channel_flags_to_prpl_flags(flags), (0));
            }
        }

        name_normal = g_strdup(bnet_normalize(bnet->account, name));
        my_unique_username = g_strdup(bnet_normalize(bnet->account, bnet->bncs.chat_env.unique_name));
        if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name_normal) && __builtin_constant_p (my_unique_username) && (__s1_len = strlen (name_normal), __s2_len = strlen (my_unique_username), (!((size_t)(const void *)((name_normal) + 1) - (size_t)(const void *)(name_normal) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((my_unique_username) + 1) - (size_t)(const void *)(my_unique_username) == 1) || __s2_len >= 4)) ? __builtin_strcmp (name_normal, my_unique_username) : (__builtin_constant_p (name_normal) && ((size_t)(const void *)((name_normal) + 1) - (size_t)(const void *)(name_normal) == 1) && (__s1_len = strlen (name_normal), __s1_len < 4) ? (__builtin_constant_p (my_unique_username) && ((size_t)(const void *)((my_unique_username) + 1) - (size_t)(const void *)(my_unique_username) == 1) ? __builtin_strcmp (name_normal, my_unique_username) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (my_unique_username); register int __result = (((const unsigned char *) (const char *) (name_normal))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name_normal))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name_normal))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name_normal))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (my_unique_username) && ((size_t)(const void *)((my_unique_username) + 1) - (size_t)(const void *)(my_unique_username) == 1) && (__s2_len = strlen (my_unique_username), __s2_len < 4) ? (__builtin_constant_p (name_normal) && ((size_t)(const void *)((name_normal) + 1) - (size_t)(const void *)(name_normal) == 1) ? __builtin_strcmp (name_normal, my_unique_username) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name_normal); register int __result = __s1[0] - ((const unsigned char *) (const char *) (my_unique_username))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (my_unique_username))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (my_unique_username))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (my_unique_username))[3]); } } __result; }))) : __builtin_strcmp (name_normal, my_unique_username)))); }) == 0 && !bnet->bncs.channel.seen_self) {

            GList *users = ((void *)0);
            GList *extras = ((void *)0);
            GList *flags = ((void *)0);
            GList *el = g_list_first(bnet->bncs.channel.user_list);

            bnet->bncs.channel.seen_self = (!(0));

            while (el != ((void *)0)) {
                BnetChannelUser *bcuel = el->data;
                int bcuelflags = bnet_channel_flags_to_prpl_flags(bcuel->flags);

                users = g_list_prepend(users, bcuel->username);
                extras = g_list_prepend(extras, bnet_channel_message_parse(bcuel->stats_data, bcuel->flags, bcuel->ping));
                flags = g_list_prepend(flags, ((gpointer) (glong) (bcuelflags)));


                el = ((el) ? (((GList *)(el))->next) : ((void *)0));
            }
            if (bnet->bncs.chat_env.first_join) {
                bnet->bncs.chat_env.first_join = (0);
            } else {
                PurpleConversation *conv;

                conv = serv_got_joined_chat(gc, bnet->bncs.channel.prpl_chat_id, bnet->bncs.channel.name);
                if (conv != ((void *)0)) {
                    chat = purple_conversation_get_chat_data(conv);
                }
                if (chat != ((void *)0)) {
                    if (bnet_clan_in_clan(bnet)) {
                        if (bnet_clan_is_clan_channel(bnet, bnet->bncs.channel.name)) {
                            gchar *motd = bnet->bncs.motds[3].message;
                            purple_conv_chat_set_topic(chat, "(clan leader)", motd);
                        }
                    }
                    purple_conv_chat_add_users(chat, users, extras, flags, (0));
                }
            }
            g_list_free(users);
            _g_list_free_full(extras, g_free);
            g_list_free(flags);
        }
        g_free(name_normal);
        g_free(my_unique_username);
    }
}

static void
bnet_recv_event_JOIN(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    BnetChannelUser *bcu = ((void *)0);

    bcu = (BnetChannelUser *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetChannelUser); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    bcu->type = 0x01;
    bcu->username = g_strdup(name);
    bcu->stats_data = g_strdup(text);
    bcu->flags = flags;
    bcu->ping = ping;
    bcu->hidden = (0);
    bnet->bncs.channel.user_list = g_list_append(bnet->bncs.channel.user_list, bcu);

    if (chat != ((void *)0)) {
        gchar *channel_message = bnet_channel_message_parse(bcu->stats_data, flags, ping);
        purple_conv_chat_add_user(chat, name,
                channel_message,
                bnet_channel_flags_to_prpl_flags(flags), (!(0)));
        g_free(channel_message);
    }
}

static void
bnet_recv_event_LEAVE(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    GList *li;

    li = g_list_find_custom(bnet->bncs.channel.user_list, name, bnet_channel_user_compare);
    if (li != ((void *)0)) {
        bnet->bncs.channel.user_list = g_list_delete_link(bnet->bncs.channel.user_list, li);
    }
    if (chat != ((void *)0)) {
        purple_conv_chat_remove_user(chat, name, ((void *)0));
    }
}

static gchar *
bnet_escape_text(const gchar *text, int length, gboolean replace_linebreaks)
{
    gchar *tmp1 = purple_markup_escape_text(text, length);

    if (g_str_has_suffix(tmp1, "\n")) {
        tmp1[strlen(tmp1) - 1] = '\0';
    }

    if (replace_linebreaks) {
        gchar *tmp2 = purple_strdup_withhtml(tmp1);
        g_free(tmp1);

        return tmp2;
    } else {
        return tmp1;
    }
}

static void
bnet_recv_event_WHISPER(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    PurpleConnection *gc = bnet->account->gc;
    gboolean prpl_level_ignore = (0);

    if (strlen(text) > 0) {
        GError *err = ((void *)0);
        GMatchInfo *mi = ((void *)0);
        GRegex *regex = ((void *)0);
        const char *name_gateway_normalize = bnet_gateway_normalize(bnet->account, name);



        char *regex_str = g_strdup_printf("Your friend %s (?:has entered Battle\\.net|has exited Battle\\.net|entered a (?:.+) game called (?:.+))\\.",
                g_regex_escape_string(name_gateway_normalize, -1));

        regex = g_regex_new(regex_str, 0, 0, &err);

        if (err != ((void *)0)) {
            purple_debug_warning("bnet", "regex create failed: %s\n", err->message);
            g_error_free(err);
        } else if (g_regex_match(regex, text, 0, &mi) &&
                !purple_account_get_bool(bnet->account, "showmutual", (0))) {
            prpl_level_ignore = (!(0));
        }
        g_match_info_free(mi);
        g_regex_unref(regex);
    }

    if (!prpl_level_ignore) {
        gchar *esc_text;
        esc_text = bnet_escape_text(text, -1, (0));
        serv_got_im(gc, name, esc_text, PURPLE_MESSAGE_RECV, time(((void *)0)));
        g_free(esc_text);
    }
# 3229 "src/bnet.c"
}

static void
bnet_recv_event_TALK(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    PurpleConnection *gc = bnet->account->gc;
    gchar *esc_text;

    esc_text = bnet_escape_text(text, -1, (0));
    serv_got_chat_in(gc, bnet->bncs.channel.prpl_chat_id, name, PURPLE_MESSAGE_RECV, esc_text, time(((void *)0)));
    g_free(esc_text);
}

static void
bnet_recv_event_BROADCAST(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    if (chat != ((void *)0)) {
        gchar *esc_text;
        esc_text = bnet_escape_text(text, -1, (0));
        purple_conv_chat_write(chat, name, esc_text, PURPLE_MESSAGE_SYSTEM, time(((void *)0)));
        g_free(esc_text);
    }
}

static void
bnet_recv_event_CHANNEL(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    PurpleConnection *gc = bnet->account->gc;
    const gchar *text_normalized;
    int chat_id;
    const char *norm = ((void *)0);
    int trying_chat_id = 0;

    bnet->bncs.channel.seen_self = (0);


    if (!bnet->bncs.chat_env.first_join && bnet->bncs.channel.prpl_chat_id != 0) {
        if (chat != ((void *)0)) {
            purple_conv_chat_write(chat, "Battle.net",
                    "You have left this chat channel. Battle.net only allows being in one channel at any time.", PURPLE_MESSAGE_SYSTEM, time(((void *)0)));
        }
        serv_got_chat_left(gc, bnet->bncs.channel.prpl_chat_id);
    }


    if (bnet->bncs.channel.user_list != ((void *)0)) {
        _g_list_free_full(bnet->bncs.channel.user_list, (GDestroyNotify)bnet_channel_user_free);
        bnet->bncs.channel.user_list = ((void *)0);
    }


    text_normalized = bnet_normalize(bnet->account, text);
    chat_id = g_str_hash(text_normalized);
# 3297 "src/bnet.c"
    if (bnet->bncs.channel.name_pending != ((void *)0)) {
        norm = bnet_normalize(bnet->account, bnet->bncs.channel.name_pending);
        trying_chat_id = g_str_hash(norm);
        if (trying_chat_id == chat_id) {
            bnet->bncs.chat_env.first_join = (0);
            g_free(bnet->bncs.channel.name_pending);
            bnet->bncs.channel.name_pending = ((void *)0);
        }
    }


    g_free(bnet->bncs.channel.name);
    bnet->bncs.channel.prpl_chat_id = chat_id;
    bnet->bncs.channel.name = g_strdup(text);
    bnet->bncs.channel.flags = flags;






    if (bnet_clan_in_clan(bnet) &&
            bnet_clan_is_clan_channel(bnet, bnet->bncs.channel.name)) {
        bnet->bncs.channel.got_motd = (0);
    }


    if ((bnet->bncs.channel.flags & BNET_CHAN_FLAG_SILENT) == BNET_CHAN_FLAG_SILENT) {
        bnet->bncs.chat_env.first_join = (0);
        g_free(bnet->bncs.channel.name_pending);
        bnet->bncs.channel.name_pending = ((void *)0);
        serv_got_joined_chat(gc, chat_id, text);
    }
}


static void
bnet_recv_event_USERFLAGS(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    if (chat != ((void *)0)) {
        GList *li = g_list_find_custom(bnet->bncs.channel.user_list, name, bnet_channel_user_compare);
        if (li != ((void *)0)) {
            BnetChannelUser *bcu = li->data;
            bcu->flags = flags;
            bcu->ping = ping;
            if (strlen(text) > 0) {
                g_free(bcu->stats_data);
                bcu->stats_data = g_strdup(text);
            }
        }

        purple_conv_chat_user_set_flags(chat, name,
                bnet_channel_flags_to_prpl_flags(flags));
    }
}

static void
bnet_recv_event_WHISPERSENT(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    if (bnet->bncs.whisper.last_sent_to != ((void *)0)) {
        bnet->bncs.whisper.awaiting_confirm = (0);
    }
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name) && __builtin_constant_p ("your friends") && (__s1_len = strlen (name), __s2_len = strlen ("your friends"), (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("your friends") + 1) - (size_t)(const void *)("your friends") == 1) || __s2_len >= 4)) ? __builtin_strcmp (name, "your friends") : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s1_len = strlen (name), __s1_len < 4) ? (__builtin_constant_p ("your friends") && ((size_t)(const void *)(("your friends") + 1) - (size_t)(const void *)("your friends") == 1) ? __builtin_strcmp (name, "your friends") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("your friends"); register int __result = (((const unsigned char *) (const char *) (name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("your friends") && ((size_t)(const void *)(("your friends") + 1) - (size_t)(const void *)("your friends") == 1) && (__s2_len = strlen ("your friends"), __s2_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (name, "your friends") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("your friends"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("your friends"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("your friends"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("your friends"))[3]); } } __result; }))) : __builtin_strcmp (name, "your friends")))); }) == 0) {
        PurpleConnection *gc = bnet->account->gc;
        gchar *esc_text = bnet_escape_text(text, -1, (0));
        serv_got_chat_in(gc, bnet->bncs.channel.prpl_chat_id, name, PURPLE_MESSAGE_RECV | PURPLE_MESSAGE_WHISPER, esc_text, time(((void *)0)));
        g_free(esc_text);
    }
}

static void
bnet_recv_event_CHANNELFULL(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{

    purple_debug_info("bnet", "CHANNEL IS FULL %s %x %dms: %s\n",
            name, flags, ping, text);


}

static void
bnet_recv_event_CHANNELDOESNOTEXIST(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{

    purple_debug_info("bnet", "CHANNEL DOES NOT EXIST %s %x %dms: %s\n",
            name, flags, ping, text);


}

static void
bnet_recv_event_CHANNELRESTRICTED(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{

    purple_debug_info("bnet", "CHANNEL IS RESTRICTED %s %x %dms: %s\n",
            name, flags, ping, text);


}

static gboolean
bnet_recv_event_INFO_whois(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    gboolean handled = (0);
    PurpleBuddy *b;

    gchar *whois_user = g_match_info_fetch(mi, 1);
    gchar *whois_product = g_match_info_fetch(mi, 2);
    gchar *whois_location = g_match_info_fetch(mi, 3);
    const gchar *whois_user_n = ((void *)0);
    const gchar *whois_user_c = ((void *)0);
    const gchar *whois_user_r = ((void *)0);

    whois_user_n = bnet_d2_normalize(bnet->account, whois_user);
    whois_user_c = bnet_d2_get_character(bnet->account, whois_user);
    whois_user_r = bnet_d2_get_realm(bnet->account, whois_user);

    b = purple_find_buddy(bnet->account, whois_user_n);
    if (b != ((void *)0)) {
        BnetUser *bfi = purple_buddy_get_protocol_data(b);
        if (bfi != ((void *)0)) {
            if (bfi->type == 0x02) {
                if (((BnetFriendInfo *)bfi)->automated_lookup) {
                    handled = (!(0));
                }
            }
        }
    }

    if (!handled && (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_WHOIS)) {
        handled = (!(0));

        bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_LOCPROD;
        bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_WHOIS;



        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {
            if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
            } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
            }
            bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;

            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Current location", whois_location);
            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Current product", whois_product);

            if (whois_user_c != ((void *)0)) {
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Diablo II character", whois_user_c);
                if (whois_user_r != ((void *)0)) {
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Diablo II realm", whois_user_r);
                } else if (bnet->d2mcp.realm.name != ((void *)0)) {
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Diablo II realm", bnet->d2mcp.realm.name);
                }
            }


            if (bnet->bncs.lookup_info.name != ((void *)0)) {
                g_free(bnet->bncs.lookup_info.name);
            }
            bnet->bncs.lookup_info.name = g_strdup(whois_user_n);

            if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                        bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
            }

            purple_debug_info("bnet", "Lookup complete: WHOIS(%s) [allowing WHOIS_STATUSES_*]\n", bnet->bncs.lookup_info.name);
        } else {
            purple_debug_info("bnet", "Lookup complete: WHOIS([freed]) [allowing WHOIS_STATUSES_*]\n");
        }

    }

    g_free(whois_user);
    g_free(whois_product);
    g_free(whois_location);

    return handled;
}

static gboolean
bnet_recv_event_INFO_away_response(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    PurpleConnection *gc = bnet->account->gc;
    gboolean handled = (0);
    PurpleBuddy *b;

    gchar *away_user = g_match_info_fetch(mi, 1);
    gchar *away_msg = g_match_info_fetch(mi, 2);
    const gchar *away_user_n = ((void *)0);

    if (strlen(away_user) == 0) {
        g_free(away_user);
        away_user = g_strdup(bnet->bncs.chat_env.unique_name);
    }

    away_user_n = bnet_d2_normalize(bnet->account, away_user);

    b = purple_find_buddy(bnet->account, away_user_n);
    if (b != ((void *)0)) {
        BnetUser *bfi = purple_buddy_get_protocol_data(b);
        if (bfi != ((void *)0)) {
            if (bfi->type == 0x02) {
                ((BnetFriendInfo *)bfi)->away_stored_status = g_strdup(away_msg);
                if (((BnetFriendInfo *)bfi)->automated_lookup & BNET_FRIEND_STATUS_AWAY) {
                    handled = (!(0));
                    ((BnetFriendInfo *)bfi)->automated_lookup &= ~BNET_FRIEND_STATUS_AWAY;
                }
            }
        }

        purple_debug_info("bnet", "purple_prpl_got_user_status for %s\n", away_user_n);
        purple_prpl_got_user_status(bnet->account, away_user_n,
                "Away", "message", g_strdup(away_msg), ((void *)0));
    }

    if (!handled && (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_WHOIS_STATUSES_AWAY)) {
        handled = (!(0));

        bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_WHOIS_STATUSES_AWAY;
        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {
            if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
            } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
            }
            bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;

            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Away", away_msg);





            purple_debug_info("bnet", "Lookup complete: WHOIS_STATUSES_AWAY(%s)\n", bnet->bncs.lookup_info.name);
        } else {
            purple_debug_info("bnet", "Lookup complete: WHOIS_STATUSES_AWAY([freed])\n");
        }
    }

    if (!handled && bnet->bncs.whisper.last_sent_to != ((void *)0)) {
        PurpleConversation *conv =
            purple_find_conversation_with_account(
                    PURPLE_CONV_TYPE_IM, bnet->bncs.whisper.last_sent_to, bnet->account);
        if (conv) {
            PurpleConvIm *im = purple_conversation_get_im_data(conv);
            if (im) {
                char *tmp = g_strdup_printf("Away (%s)", away_msg);
                handled = (!(0));

                serv_got_im(gc, away_user_n, tmp,
                        PURPLE_MESSAGE_AUTO_RESP, time(((void *)0)));
                g_free(tmp);
            }
        }

        bnet->bncs.whisper.awaiting_confirm = (0);
    }

    g_free(away_user);
    g_free(away_msg);

    return handled;
}

static gboolean
bnet_recv_event_INFO_dnd_response(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    gboolean handled = (0);
    PurpleBuddy *b;

    gchar *dnd_user = g_match_info_fetch(mi, 1);
    gchar *dnd_msg = g_match_info_fetch(mi, 2);
    const gchar *dnd_user_n = ((void *)0);

    if (strlen(dnd_user) == 0) {
        g_free(dnd_user);
        dnd_user = g_strdup(bnet->bncs.chat_env.unique_name);
    }

    dnd_user_n = bnet_d2_normalize(bnet->account, dnd_user);

    b = purple_find_buddy(bnet->account, dnd_user_n);
    if (b != ((void *)0)) {
        BnetUser *bfi = purple_buddy_get_protocol_data(b);
        if (bfi != ((void *)0)) {
            if (bfi->type == 0x02) {
                ((BnetFriendInfo *)bfi)->dnd_stored_status = g_strdup(dnd_msg);
                if (((BnetFriendInfo *)bfi)->automated_lookup & BNET_FRIEND_STATUS_DND) {
                    handled = (!(0));
                    ((BnetFriendInfo *)bfi)->automated_lookup &= ~BNET_FRIEND_STATUS_DND;
                }
            }
        }

        purple_debug_info("bnet", "purple_prpl_got_user_status for %s\n", dnd_user_n);
        purple_prpl_got_user_status(bnet->account, dnd_user_n,
                "Do not disturb", "message", g_strdup(dnd_msg), ((void *)0));
    }

    if (!handled && (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_WHOIS_STATUSES_DND)) {
        handled = (!(0));

        bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_WHOIS_STATUSES_DND;
        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {
            if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
            } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
            }
            bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;

            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Do Not Disturb", dnd_msg);





            purple_debug_info("bnet", "Lookup complete: WHOIS_STATUSES_DND(%s)\n", bnet->bncs.lookup_info.name);
        } else {
            purple_debug_info("bnet", "Lookup complete: WHOIS_STATUSES_DND([freed])\n");
        }
    }

    g_free(dnd_user);
    g_free(dnd_msg);

    return handled;
}

static gboolean
bnet_recv_event_INFO_away_state(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    gboolean handled = (0);

    gchar *away_state_string = g_match_info_fetch(mi, 1);

    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (away_state_string) && __builtin_constant_p ("still") && (__s1_len = strlen (away_state_string), __s2_len = strlen ("still"), (!((size_t)(const void *)((away_state_string) + 1) - (size_t)(const void *)(away_state_string) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("still") + 1) - (size_t)(const void *)("still") == 1) || __s2_len >= 4)) ? __builtin_strcmp (away_state_string, "still") : (__builtin_constant_p (away_state_string) && ((size_t)(const void *)((away_state_string) + 1) - (size_t)(const void *)(away_state_string) == 1) && (__s1_len = strlen (away_state_string), __s1_len < 4) ? (__builtin_constant_p ("still") && ((size_t)(const void *)(("still") + 1) - (size_t)(const void *)("still") == 1) ? __builtin_strcmp (away_state_string, "still") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("still"); register int __result = (((const unsigned char *) (const char *) (away_state_string))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (away_state_string))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (away_state_string))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (away_state_string))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("still") && ((size_t)(const void *)(("still") + 1) - (size_t)(const void *)("still") == 1) && (__s2_len = strlen ("still"), __s2_len < 4) ? (__builtin_constant_p (away_state_string) && ((size_t)(const void *)((away_state_string) + 1) - (size_t)(const void *)(away_state_string) == 1) ? __builtin_strcmp (away_state_string, "still") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (away_state_string); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("still"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("still"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("still"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("still"))[3]); } } __result; }))) : __builtin_strcmp (away_state_string, "still")))); }) == 0) {
        if (bnet->bncs.whisper.last_sent_to != ((void *)0)) {
            PurpleConversation *conv =
                purple_find_conversation_with_account(
                        PURPLE_CONV_TYPE_IM, bnet->bncs.whisper.last_sent_to, bnet->account);
            if (conv) {
                PurpleConvIm *im = purple_conversation_get_im_data(conv);
                if (im) {
                    handled = (!(0));
                    purple_conv_im_write(im, "Battle.net", text, PURPLE_MESSAGE_SYSTEM, time(((void *)0)));
                }
            }
        }
    } else {
        if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (away_state_string) && __builtin_constant_p ("now") && (__s1_len = strlen (away_state_string), __s2_len = strlen ("now"), (!((size_t)(const void *)((away_state_string) + 1) - (size_t)(const void *)(away_state_string) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) || __s2_len >= 4)) ? __builtin_strcmp (away_state_string, "now") : (__builtin_constant_p (away_state_string) && ((size_t)(const void *)((away_state_string) + 1) - (size_t)(const void *)(away_state_string) == 1) && (__s1_len = strlen (away_state_string), __s1_len < 4) ? (__builtin_constant_p ("now") && ((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) ? __builtin_strcmp (away_state_string, "now") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("now"); register int __result = (((const unsigned char *) (const char *) (away_state_string))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (away_state_string))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (away_state_string))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (away_state_string))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("now") && ((size_t)(const void *)(("now") + 1) - (size_t)(const void *)("now") == 1) && (__s2_len = strlen ("now"), __s2_len < 4) ? (__builtin_constant_p (away_state_string) && ((size_t)(const void *)((away_state_string) + 1) - (size_t)(const void *)(away_state_string) == 1) ? __builtin_strcmp (away_state_string, "now") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (away_state_string); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("now"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("now"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("now"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("now"))[3]); } } __result; }))) : __builtin_strcmp (away_state_string, "now")))); }) == 0) {
            bnet->bncs.status.status |= BNET_FRIEND_STATUS_AWAY;
        }

        if (bnet->bncs.status.status_pending & BNET_FRIEND_STATUS_AWAY) {
            handled = (!(0));
            bnet->bncs.status.status_pending &= ~BNET_FRIEND_STATUS_AWAY;
        }
    }

    g_free(away_state_string);

    return handled;
}

static gboolean
bnet_recv_event_INFO_dnd_state(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    gboolean handled = (0);

    gchar *dnd_state_string = g_match_info_fetch(mi, 1);
    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (dnd_state_string) && __builtin_constant_p ("engaged") && (__s1_len = strlen (dnd_state_string), __s2_len = strlen ("engaged"), (!((size_t)(const void *)((dnd_state_string) + 1) - (size_t)(const void *)(dnd_state_string) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("engaged") + 1) - (size_t)(const void *)("engaged") == 1) || __s2_len >= 4)) ? __builtin_strcmp (dnd_state_string, "engaged") : (__builtin_constant_p (dnd_state_string) && ((size_t)(const void *)((dnd_state_string) + 1) - (size_t)(const void *)(dnd_state_string) == 1) && (__s1_len = strlen (dnd_state_string), __s1_len < 4) ? (__builtin_constant_p ("engaged") && ((size_t)(const void *)(("engaged") + 1) - (size_t)(const void *)("engaged") == 1) ? __builtin_strcmp (dnd_state_string, "engaged") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("engaged"); register int __result = (((const unsigned char *) (const char *) (dnd_state_string))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (dnd_state_string))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (dnd_state_string))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (dnd_state_string))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("engaged") && ((size_t)(const void *)(("engaged") + 1) - (size_t)(const void *)("engaged") == 1) && (__s2_len = strlen ("engaged"), __s2_len < 4) ? (__builtin_constant_p (dnd_state_string) && ((size_t)(const void *)((dnd_state_string) + 1) - (size_t)(const void *)(dnd_state_string) == 1) ? __builtin_strcmp (dnd_state_string, "engaged") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (dnd_state_string); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("engaged"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("engaged"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("engaged"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("engaged"))[3]); } } __result; }))) : __builtin_strcmp (dnd_state_string, "engaged")))); }) == 0) {
        bnet->bncs.status.status |= BNET_FRIEND_STATUS_DND;
    }

    if (bnet->bncs.status.status_pending & BNET_FRIEND_STATUS_DND) {
        handled = (!(0));
        bnet->bncs.status.status_pending &= ~BNET_FRIEND_STATUS_DND;
    }

    g_free(dnd_state_string);

    return handled;
}

static gboolean
bnet_recv_event_INFO_dnd_error(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    PurpleConnection *gc = bnet->account->gc;
    gboolean handled = (0);

    if (bnet->bncs.whisper.last_sent_to != ((void *)0)) {
        handled = (!(0));
        if (!purple_conv_present_error(bnet->bncs.whisper.last_sent_to, bnet->account, text)) {
            gchar *tmp = g_strdup_printf("%s did not receive your whisper.", bnet->bncs.whisper.last_sent_to);
            purple_notify_message((gc), PURPLE_NOTIFY_MSG_ERROR, ("Do Not Disturb"), (text), (tmp), ((void *)0), ((void *)0));
            g_free(tmp);
        }

        bnet->bncs.whisper.awaiting_confirm = (0);
    }

    return handled;
}

static gboolean
bnet_recv_event_INFO_ban(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    gboolean handled = (0);

    if (!purple_account_get_bool(bnet->account, "showbans", (0))) {

        handled = (!(0));
    }

    return handled;
}

static void
bnet_recv_event_INFO(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    PurpleConnection *gc = bnet->account->gc;
    gboolean regex_matched = (0);
    gboolean show_in_chat = (!(0));

    if (strlen(text) > 0) {
        int i = 0;

        if (bnet_clan_in_clan(bnet) &&
                bnet_clan_is_clan_channel(bnet, bnet->bncs.channel.name) &&
                bnet->bncs.motds[3].message != ((void *)0) &&
                __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (text) && __builtin_constant_p (bnet->bncs.motds[3].message) && (__s1_len = strlen (text), __s2_len = strlen (bnet->bncs.motds[3].message), (!((size_t)(const void *)((text) + 1) - (size_t)(const void *)(text) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((bnet->bncs.motds[3].message) + 1) - (size_t)(const void *)(bnet->bncs.motds[3].message) == 1) || __s2_len >= 4)) ? __builtin_strcmp (text, bnet->bncs.motds[3].message) : (__builtin_constant_p (text) && ((size_t)(const void *)((text) + 1) - (size_t)(const void *)(text) == 1) && (__s1_len = strlen (text), __s1_len < 4) ? (__builtin_constant_p (bnet->bncs.motds[3].message) && ((size_t)(const void *)((bnet->bncs.motds[3].message) + 1) - (size_t)(const void *)(bnet->bncs.motds[3].message) == 1) ? __builtin_strcmp (text, bnet->bncs.motds[3].message) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (bnet->bncs.motds[3].message); register int __result = (((const unsigned char *) (const char *) (text))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (text))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (text))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (text))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (bnet->bncs.motds[3].message) && ((size_t)(const void *)((bnet->bncs.motds[3].message) + 1) - (size_t)(const void *)(bnet->bncs.motds[3].message) == 1) && (__s2_len = strlen (bnet->bncs.motds[3].message), __s2_len < 4) ? (__builtin_constant_p (text) && ((size_t)(const void *)((text) + 1) - (size_t)(const void *)(text) == 1) ? __builtin_strcmp (text, bnet->bncs.motds[3].message) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (text); register int __result = __s1[0] - ((const unsigned char *) (const char *) (bnet->bncs.motds[3].message))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (bnet->bncs.motds[3].message))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (bnet->bncs.motds[3].message))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (bnet->bncs.motds[3].message))[3]); } } __result; }))) : __builtin_strcmp (text, bnet->bncs.motds[3].message)))); }) == 0 &&
                !bnet->bncs.channel.got_motd) {
            regex_matched = (!(0));
            bnet->bncs.channel.got_motd = (!(0));
        }

        while (bnet_regex_store[i].regex != ((void *)0)) {
            GRegex *regex = bnet_regex_store[i].regex;
            GMatchInfo *mi = ((void *)0);

            if (regex_matched) {
                break;
            }

            if (bnet_regex_store[i].event_id == BNET_EID_INFO) {
                if (g_regex_match(regex, text, 0, &mi)) {
                    show_in_chat = !bnet_regex_store[i].fn(bnet, regex, text, mi);
                    regex_matched = (!(0));
                }
                if (mi != ((void *)0)) {
                    g_match_info_free(mi);
                    mi = ((void *)0);
                }
            }

            i++;
        }

        if (show_in_chat) {
            gchar *esc_text = bnet_escape_text(text, -1, (0));
            if (bnet->bncs.chat_env.prpl_last_cmd_conv_handle != ((void *)0)) {
                PurpleConversation *conv = bnet->bncs.chat_env.prpl_last_cmd_conv_handle;
                PurpleConvIm *im = purple_conversation_get_im_data(conv);
                if (im) {
                    purple_conv_im_write(im, "Battle.net", esc_text, PURPLE_MESSAGE_SYSTEM, time(((void *)0)));
                } else if (chat) {
                    purple_conv_chat_write(chat, "Battle.net", esc_text, PURPLE_MESSAGE_SYSTEM, time(((void *)0)));
                } else {
                    purple_notify_message((gc), PURPLE_NOTIFY_MSG_INFO, ("Information"), (text), (((void *)0)), ((void *)0), ((void *)0));
                }
            } else if (chat) {
                purple_conv_chat_write(chat, "Battle.net", esc_text, PURPLE_MESSAGE_SYSTEM, time(((void *)0)));
            } else {

            }
        }
    }
}

static void
bnet_recv_event_ERROR(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    PurpleConnection *gc = bnet->account->gc;
    gboolean handled = (0);



    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (text) && __builtin_constant_p ("That user is not logged on.") && (__s1_len = strlen (text), __s2_len = strlen ("That user is not logged on."), (!((size_t)(const void *)((text) + 1) - (size_t)(const void *)(text) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("That user is not logged on.") + 1) - (size_t)(const void *)("That user is not logged on.") == 1) || __s2_len >= 4)) ? __builtin_strcmp (text, "That user is not logged on.") : (__builtin_constant_p (text) && ((size_t)(const void *)((text) + 1) - (size_t)(const void *)(text) == 1) && (__s1_len = strlen (text), __s1_len < 4) ? (__builtin_constant_p ("That user is not logged on.") && ((size_t)(const void *)(("That user is not logged on.") + 1) - (size_t)(const void *)("That user is not logged on.") == 1) ? __builtin_strcmp (text, "That user is not logged on.") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("That user is not logged on."); register int __result = (((const unsigned char *) (const char *) (text))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (text))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (text))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (text))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("That user is not logged on.") && ((size_t)(const void *)(("That user is not logged on.") + 1) - (size_t)(const void *)("That user is not logged on.") == 1) && (__s2_len = strlen ("That user is not logged on."), __s2_len < 4) ? (__builtin_constant_p (text) && ((size_t)(const void *)((text) + 1) - (size_t)(const void *)(text) == 1) ? __builtin_strcmp (text, "That user is not logged on.") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (text); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("That user is not logged on."))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("That user is not logged on."))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("That user is not logged on."))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("That user is not logged on."))[3]); } } __result; }))) : __builtin_strcmp (text, "That user is not logged on.")))); }) == 0) {
        if (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_WHOIS) {
            handled = (!(0));

            bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_WHOIS;
            if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {
                if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                    bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
                } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                    purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                }
                bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;

                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Current location", "Offline");

                bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_LOCPROD;

                if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                    purple_notify_userinfo(gc, bnet->bncs.lookup_info.name,
                            bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
                }
                purple_debug_info("bnet", "Lookup complete: WHOIS(%s)\n", bnet->bncs.lookup_info.name);
            } else {
                purple_debug_info("bnet", "Lookup complete: WHOIS([freed])\n");
            }
        }

        if (!handled && bnet->bncs.whisper.last_sent_to != ((void *)0)) {
            handled = (!(0));
            if (!purple_conv_present_error(bnet->bncs.whisper.last_sent_to, bnet->account, text)) {
                purple_notify_message((gc), PURPLE_NOTIFY_MSG_ERROR, ("Not logged in"), (text), (g_strdup_printf("%s did not receive your whisper.", bnet->bncs.whisper.last_sent_to)), ((void *)0), ((void *)0))
                                                                                                             ;
            }

            bnet->bncs.whisper.awaiting_confirm = (0);
        }
    }




    if (!handled) {
        gchar *esc_text = bnet_escape_text(text, -1, (0));
        if (bnet->bncs.chat_env.prpl_last_cmd_conv_handle) {
            PurpleConversation *conv = bnet->bncs.chat_env.prpl_last_cmd_conv_handle;
            PurpleConvIm *im = purple_conversation_get_im_data(conv);
            if (im) {
                purple_conv_im_write(im, "Battle.net", esc_text, PURPLE_MESSAGE_ERROR, time(((void *)0)));
            } else if (chat) {
                purple_conv_chat_write(chat, "Battle.net", esc_text, PURPLE_MESSAGE_ERROR, time(((void *)0)));
            } else {
                purple_notify_message((gc), PURPLE_NOTIFY_MSG_INFO, ("Error"), (text), (((void *)0)), ((void *)0), ((void *)0));
            }
        } else if (chat) {
            purple_conv_chat_write(chat, "Battle.net", esc_text, PURPLE_MESSAGE_ERROR, time(((void *)0)));
        } else {
            purple_notify_message((gc), PURPLE_NOTIFY_MSG_ERROR, ("Error"), (text), (((void *)0)), ((void *)0), ((void *)0));
        }
    }
}

static void
bnet_recv_event_EMOTE(BnetConnectionData *bnet, PurpleConvChat *chat,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    PurpleConnection *gc = bnet->account->gc;
    gchar *esc_text;
    gchar *emote_text;

    if (strlen(text) == 0) {
        emote_text = g_strdup("/me ");
    } else {
        esc_text = bnet_escape_text(text, -1, (0));
        emote_text = g_strdup_printf("/me %s", esc_text);
        g_free(esc_text);
    }

    serv_got_chat_in(gc, bnet->bncs.channel.prpl_chat_id, name,
            ((__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (bnet->bncs.chat_env.unique_name) && __builtin_constant_p (name) && (__s1_len = strlen (bnet->bncs.chat_env.unique_name), __s2_len = strlen (name), (!((size_t)(const void *)((bnet->bncs.chat_env.unique_name) + 1) - (size_t)(const void *)(bnet->bncs.chat_env.unique_name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s2_len >= 4)) ? __builtin_strcmp (bnet->bncs.chat_env.unique_name, name) : (__builtin_constant_p (bnet->bncs.chat_env.unique_name) && ((size_t)(const void *)((bnet->bncs.chat_env.unique_name) + 1) - (size_t)(const void *)(bnet->bncs.chat_env.unique_name) == 1) && (__s1_len = strlen (bnet->bncs.chat_env.unique_name), __s1_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (bnet->bncs.chat_env.unique_name, name) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (name); register int __result = (((const unsigned char *) (const char *) (bnet->bncs.chat_env.unique_name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (bnet->bncs.chat_env.unique_name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (bnet->bncs.chat_env.unique_name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (bnet->bncs.chat_env.unique_name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s2_len = strlen (name), __s2_len < 4) ? (__builtin_constant_p (bnet->bncs.chat_env.unique_name) && ((size_t)(const void *)((bnet->bncs.chat_env.unique_name) + 1) - (size_t)(const void *)(bnet->bncs.chat_env.unique_name) == 1) ? __builtin_strcmp (bnet->bncs.chat_env.unique_name, name) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (bnet->bncs.chat_env.unique_name); register int __result = __s1[0] - ((const unsigned char *) (const char *) (name))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (name))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (name))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (name))[3]); } } __result; }))) : __builtin_strcmp (bnet->bncs.chat_env.unique_name, name)))); }) == 0) ?
             PURPLE_MESSAGE_SEND : PURPLE_MESSAGE_RECV),
            emote_text, time(((void *)0)));
    g_free(emote_text);
}

static void
bnet_recv_event(BnetConnectionData *bnet, PurpleConvChat *chat, BnetChatEventID event_id,
        const gchar *name, const gchar *text, BnetChatEventFlags flags, gint32 ping)
{
    if (event_id < BNET_EID_SHOWUSER || event_id > BNET_EID_EMOTE || bnet_events[event_id].id == 0) {
        purple_debug_warning("bnet", "Received unhandled event 0x%02x: \"%s\" 0x%04x %dms: %s \n", event_id, name, flags, ping, text);
    } else {
        struct BnetChatEvent ev = bnet_events[event_id];

        if (!bnet_is_telnet(bnet) && !ev.text_is_statstring) {
            gchar *text_utf8;
            text_utf8 = bnet_to_utf8_crlf(text);
            ev.fn(bnet, chat, name, text_utf8, flags, ping);
            g_free(text_utf8);
        } else {
            ev.fn(bnet, chat, name, text, flags, ping);
        }
    }
}

static void
bnet_entered_chat(BnetConnectionData *bnet)
{
    PurpleConnection *gc = bnet->account->gc;
    PurplePresence *pres = ((void *)0);
    PurpleStatus *status = ((void *)0);

    bnet->bncs.chat_env.is_online = (!(0));
    bnet->bncs.chat_env.first_join = (!(0));
    bnet->bncs.channel.seen_self = (0);

    bnet->bncs.chat_env.updatelist_timer_handle = purple_timeout_add_seconds(30, (GSourceFunc)bnet_updatelist_timer, bnet);

    purple_connection_set_state(gc, PURPLE_CONNECTED);

    pres = purple_account_get_presence(bnet->account);
    status = purple_presence_get_active_status(pres);
    bnet_set_status(bnet->account, status);
}

static void
bnet_recv_CHATEVENT(BnetConnectionData *bnet, BnetPacket *pkt)
{
    BnetChatEventID id = 0;
    BnetChatEventFlags flags = 0;
    gint32 ping = 0;
    char *name = ((void *)0);
    char *text = ((void *)0);

    PurpleConnection *gc = bnet->account->gc;
    PurpleConversation *conv = ((void *)0);
    PurpleConvChat *chat = ((void *)0);
    char *name_d2n = ((void *)0);

    if (!bnet->bncs.chat_env.is_online) {
        bnet_entered_chat(bnet);
    }
    if (!bnet->bncs.chat_env.first_join && bnet->bncs.channel.prpl_chat_id != 0) {
        conv = purple_find_chat(gc, bnet->bncs.channel.prpl_chat_id);
    }
    if (conv != ((void *)0)) {
        chat = purple_conversation_get_chat_data(conv);
    }

    id = bnet_packet_read_dword(pkt);
    flags = bnet_packet_read_dword(pkt);
    ping = bnet_packet_read_dword(pkt);
    bnet_packet_read_dword(pkt);
    bnet_packet_read_dword(pkt);
    bnet_packet_read_dword(pkt);
    name = bnet_packet_read_cstring(pkt);
    text = bnet_packet_read_cstring(pkt);


    name_d2n = g_strdup(bnet_d2_normalize(bnet->account, name));

    bnet_recv_event(bnet, chat, id, name_d2n, text, flags, ping);

    g_free(name);
    g_free(name_d2n);
    g_free(text);
}

static void
bnet_recv_MESSAGEBOX(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 style = bnet_packet_read_dword(pkt);
    char *text = bnet_packet_read_cstring(pkt);
    char *caption = bnet_packet_read_cstring(pkt);
    char *title = ((void *)0);
    const char *title_type = ((void *)0);



    if (style & 0x00000010L) {
        title_type = "error";
    } else if (style & 0x00000030L) {
        title_type = "warning";
    } else {
        title_type = "info";
    }

    title = g_strdup_printf("Battle.net %s: %s", title_type, caption);
    purple_notify_message((bnet), PURPLE_NOTIFY_MSG_ERROR, (title), (text), (((void *)0)), ((void *)0), ((void *)0));
    g_free(title);
    g_free(caption);
    g_free(text);
}

static void
bnet_recv_LOGONCHALLENGEEX(BnetConnectionData *bnet, BnetPacket *pkt)
{
    bnet->bncs.logon.session_cookie = bnet_packet_read_dword(pkt);
    bnet->bncs.logon.server_cookie = bnet_packet_read_dword(pkt);
}

static void
bnet_recv_PING(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 cookie = bnet_packet_read_dword(pkt);


    bnet_send_PING(bnet, cookie);
}

static void
bnet_recv_READUSERDATA(BnetConnectionData *bnet, BnetPacket *pkt)
{

    guint32 key_count, request_cookie ;
    int i, j;
                        bnet_packet_read_dword(pkt);
    key_count = bnet_packet_read_dword(pkt);
    request_cookie = bnet_packet_read_dword(pkt);

    for (i = 0; i < g_list_length(bnet->bncs.user_data.requests); i++) {
        BnetUserDataRequest *req = g_list_nth_data(bnet->bncs.user_data.requests, i);
        if (bnet_userdata_request_get_cookie(req) == request_cookie) {
            GHashTable *userdata = g_hash_table_new_full(g_str_hash, g_str_equal, ((void *)0), g_free);
            gboolean showing_lookup_dialog = (0);
            BnetUserDataRequestType request_type = bnet_userdata_request_get_type(req);
            char *pstr = ((void *)0);

            for (j = 0; j < key_count; j++) {
                g_hash_table_insert(userdata,
                        bnet_userdata_request_get_key_by_index(req, j),
                        bnet_packet_read_cstring(pkt));
            }

            if (!bnet->bncs.user_data.writing_profile &&
                    bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_USER_DATA) {
                bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_USER_DATA;
                if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {
                    showing_lookup_dialog = (!(0));

                    if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                        bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
                    } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                        purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                    }
                    bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;
                    purple_debug_info("bnet", "Lookup complete: USER_DATA(%s)\n", bnet->bncs.lookup_info.name);
                } else {
                    purple_debug_info("bnet", "Lookup complete: USER_DATA([freed])\n");
                }
            }

            if (request_type & BNET_READUSERDATA_REQUEST_PROFILE) {
                if (bnet->bncs.user_data.writing_profile) {
                    gchar *psex = bnet_to_utf8_crlf(g_hash_table_lookup(userdata, "profile\\sex"));
                    gchar *page = bnet_to_utf8_crlf(g_hash_table_lookup(userdata, "profile\\age"));
                    gchar *ploc = bnet_to_utf8_crlf(g_hash_table_lookup(userdata, "profile\\location"));
                    gchar *pdescr = bnet_to_utf8_crlf(g_hash_table_lookup(userdata, "profile\\description"));
                    purple_debug_info("bnet", "Current values: sex=%s age=%s loc=%s desc=%s\n", psex, page, ploc, pdescr);
                    bnet_profile_show_write_dialog(bnet, psex, page, ploc, pdescr);
                    g_free(psex);
                    g_free(page);
                    g_free(ploc);
                    g_free(pdescr);
                } else if (showing_lookup_dialog) {
                    gchar *pstr_utf8 = ((void *)0);
                    int section_count = 0;


                    pstr = g_hash_table_lookup(userdata, "profile\\sex");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        pstr_utf8 = bnet_to_utf8_crlf(pstr);
                        purple_notify_user_info_add_pair(bnet->bncs.lookup_info.prpl_notify_handle, "Profile sex", pstr_utf8);
                        g_free(pstr_utf8);
                        section_count++;
                    }


                    pstr = g_hash_table_lookup(userdata, "profile\\age");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        pstr_utf8 = bnet_to_utf8_crlf(pstr);
                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Profile age", pstr_utf8);
                        g_free(pstr_utf8);
                        section_count++;
                    }


                    pstr = g_hash_table_lookup(userdata, "profile\\location");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        pstr_utf8 = bnet_to_utf8_crlf(pstr);
                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Profile location", pstr_utf8);
                        g_free(pstr_utf8);
                        section_count++;
                    }


                    pstr = g_hash_table_lookup(userdata, "profile\\description");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        gchar *tmp;
                        pstr_utf8 = bnet_to_utf8_crlf(pstr);
                        tmp = g_strdup_printf("\r\n%s", pstr_utf8);
                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Profile description", tmp);
                        g_free(pstr_utf8);
                        g_free(tmp);
                        section_count++;
                    }

                    if (section_count == 0) {
                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Profile",
                                "No information is stored in this user's profile.");
                    }
                }
            }

            if (request_type & BNET_READUSERDATA_REQUEST_SYSTEM) {
                if (showing_lookup_dialog) {
                    gboolean is_section = (0);


                    pstr = g_hash_table_lookup(userdata, "System\\Time Logged");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        gchar *str_sec = bnet_format_strsec(pstr);
                        if (!is_section) {
                            purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                            is_section = (!(0));
                        }

                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Account time logged", str_sec);
                        g_free(str_sec);
                    }


                    pstr = g_hash_table_lookup(userdata, "System\\Account Created");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        gchar *str_time = bnet_format_filetime_string(pstr);
                        if (!is_section) {
                            purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                            is_section = (!(0));
                        }

                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Account creation time", str_time);
                        g_free(str_time);
                    }


                    pstr = g_hash_table_lookup(userdata, "System\\Account Expires");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        gchar *str_time = bnet_format_filetime_string(pstr);
                        if (!is_section) {
                            purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                            is_section = (!(0));
                        }

                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Account expires time", str_time);
                        g_free(str_time);
                    }


                    pstr = g_hash_table_lookup(userdata, "System\\Last Logoff");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        gchar *str_time = bnet_format_filetime_string(pstr);
                        if (!is_section) {
                            purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                            is_section = (!(0));
                        }

                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Account last logged off", str_time);
                        g_free(str_time);
                    }


                    pstr = g_hash_table_lookup(userdata, "System\\Last Logon");
                    if (pstr != ((void *)0) && strlen(pstr) > 0) {
                        gchar *str_time = bnet_format_filetime_string(pstr);
                        if (!is_section) {
                            purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                            is_section = (!(0));
                        }

                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Account last logged on", str_time);
                        g_free(str_time);
                    }
                }
            }

            if (request_type & BNET_READUSERDATA_REQUEST_RECORD) {
                if (showing_lookup_dialog) {
                    gboolean is_section = (0);

                    for (j = 0; j < 4; j++) {
                        char *zero = "0";
                        char *key; char *prpl_key; char *prpl_val;
                        char *wins; char *losses; char *discs; char *lgame; char *lgameres;
                        char *rating; char *hrating; char *rank; char *hrank;
                        char *header_text = ((void *)0);
                        char *product_id = bnet_get_product_id_str(bnet_userdata_request_get_product(req));
                        char *product = bnet_get_product_name(bnet_userdata_request_get_product(req));

                        switch (j) {
                            case 0: header_text = "Normal"; break;
                            case 1: header_text = "Ladder"; break;
                            case 3: header_text = "IronMan"; break;
                        }

                        key = g_strdup_printf("Record\\%s\\%d\\wins", product_id, j);
                        wins = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, wins);
                        g_free(key);
                        key = g_strdup_printf("Record\\%s\\%d\\losses", product_id, j);
                        losses = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, losses);
                        g_free(key);
                        key = g_strdup_printf("Record\\%s\\%d\\disconnects", product_id, j);
                        discs = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, discs);
                        g_free(key);
                        key = g_strdup_printf("Record\\%s\\%d\\last game", product_id, j);
                        lgame = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, lgame);
                        g_free(key);
                        key = g_strdup_printf("Record\\%s\\%d\\last game result", product_id, j);
                        lgameres = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, lgameres);
                        g_free(key);

                        if (wins != ((void *)0) && losses != ((void *)0) && discs != ((void *)0) &&
                                lgame != ((void *)0) && lgameres != ((void *)0)) {
                            if (!is_section) {
                                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                                is_section = (!(0));
                            }

                            if (strlen(wins) == 0) wins = zero;
                            if (strlen(losses) == 0) losses = zero;
                            if (strlen(discs) == 0) discs = zero;
                            if (strlen(lgame) == 0 || __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (lgameres) && __builtin_constant_p ("NONE") && (__s1_len = strlen (lgameres), __s2_len = strlen ("NONE"), (!((size_t)(const void *)((lgameres) + 1) - (size_t)(const void *)(lgameres) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("NONE") + 1) - (size_t)(const void *)("NONE") == 1) || __s2_len >= 4)) ? __builtin_strcmp (lgameres, "NONE") : (__builtin_constant_p (lgameres) && ((size_t)(const void *)((lgameres) + 1) - (size_t)(const void *)(lgameres) == 1) && (__s1_len = strlen (lgameres), __s1_len < 4) ? (__builtin_constant_p ("NONE") && ((size_t)(const void *)(("NONE") + 1) - (size_t)(const void *)("NONE") == 1) ? __builtin_strcmp (lgameres, "NONE") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("NONE"); register int __result = (((const unsigned char *) (const char *) (lgameres))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (lgameres))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (lgameres))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (lgameres))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("NONE") && ((size_t)(const void *)(("NONE") + 1) - (size_t)(const void *)("NONE") == 1) && (__s2_len = strlen ("NONE"), __s2_len < 4) ? (__builtin_constant_p (lgameres) && ((size_t)(const void *)((lgameres) + 1) - (size_t)(const void *)(lgameres) == 1) ? __builtin_strcmp (lgameres, "NONE") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (lgameres); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("NONE"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("NONE"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("NONE"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("NONE"))[3]); } } __result; }))) : __builtin_strcmp (lgameres, "NONE")))); }) == 0) {
                                lgame = "never";
                            } else {
                                char *tmp = bnet_format_filetime_string(lgame);
                                lgame = g_strdup_printf("%s on %s", lgameres, tmp);
                                g_free(tmp);
                            }

                            prpl_key = g_strdup_printf("%s record for %s", header_text, product);
                            prpl_val = g_strdup_printf("%s-%s-%s", wins, losses, discs);
                            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                            g_free(prpl_key);
                            g_free(prpl_val);

                            prpl_key = g_strdup_printf("Last %s game", header_text);
                            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, lgame);
                            g_free(prpl_key);
                        }

                        key = g_strdup_printf("Record\\%s\\%d\\rating", product_id, j);
                        rating = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, rating);
                        g_free(key);
                        key = g_strdup_printf("Record\\%s\\%d\\high rating", product_id, j);
                        hrating = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, hrating);
                        g_free(key);
                        key = g_strdup_printf("DynKey\\%s\\%d\\rank", product_id, j);
                        rank = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, rank);
                        g_free(key);
                        key = g_strdup_printf("Record\\%s\\%d\\high rank", product_id, j);
                        hrank = g_hash_table_lookup(userdata, key);
                        purple_debug_info("bnet", "key: %s  value: %s\n", key, hrank);
                        g_free(key);

                        if (rating != ((void *)0) && hrating != ((void *)0) &&
                                rank != ((void *)0) && hrank != ((void *)0)) {

                            if (!is_section) {
                                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
                                is_section = (!(0));
                            }

                            if (strlen(rating) == 0) rating = zero;
                            if (strlen(hrating) == 0) hrating = zero;
                            if (strlen(rank) == 0) rank = zero;
                            if (strlen(hrank) == 0) hrank = zero;

                            prpl_key = g_strdup_printf("%s rating", header_text);
                            prpl_val = g_strdup_printf("%s (high: %s)", rating, hrating);
                            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                            g_free(prpl_key);
                            g_free(prpl_val);

                            prpl_key = g_strdup_printf("%s rank", header_text);
                            prpl_val = g_strdup_printf("%s (high: %s)", rank, hrank);
                            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                            g_free(prpl_key);
                            g_free(prpl_val);
                        }
                    }
                }
            }

            if (showing_lookup_dialog) {
                if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                    purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                            bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
                }
            }

            bnet->bncs.user_data.requests = g_list_remove(bnet->bncs.user_data.requests, req);

            g_hash_table_destroy(userdata);

            bnet_userdata_request_free(req);
        }
    }
}

static void
bnet_recv_LOGONCHALLENGE(BnetConnectionData *bnet, BnetPacket *pkt)
{
    bnet->bncs.logon.server_cookie = bnet_packet_read_dword(pkt);
}

static void
bnet_recv_CDKEY(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 result = bnet_packet_read_dword(pkt);
    char *extra_info = bnet_packet_read_cstring(pkt);
    char *extra_info_utf8 = bnet_to_utf8_crlf(extra_info);

    PurpleConnection *gc = bnet->account->gc;

    char *tmp = ((void *)0);
    char *tmpe = ((void *)0);
    char *tmpf = ((void *)0);

    PurpleConnectionError conn_error = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;

    switch (result) {
        case 0x01:
            {
                bnet->bncs.versioning.complete = (!(0));

                purple_debug_info("bnet", "Key check passed!\n");

                if (!bnet->bncs.logon.create_account) {
                    purple_connection_update_progress(gc, "Authenticating", 3, 5);
                }

                bnet_account_logon(bnet);

                g_free(extra_info);
                return;
            }
        case 0x02:
            tmp = "CD-key invalid%s.";
            break;
        case 0x03:
            tmp = "CD-key is for another game%s.";
            break;
        case 0x04:
            tmp = "CD-key is banned%s.";
            break;
        case 0x05:
            tmp = "CD-key is in use%s.";
            break;
        default:
            tmp = "CD-key invalid%s.";
            break;
    }

    tmpe = g_strdup_printf(" (%s)", extra_info_utf8);
    tmpf = g_strdup_printf(tmp, strlen(extra_info_utf8) > 0 ? tmpe : "");
    purple_connection_error_reason(gc, conn_error, tmpf);

    g_free(tmpe);
    g_free(tmpf);

    g_free(extra_info);
    g_free(extra_info_utf8);
}

static void
bnet_recv_W3PROFILE(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 cookie;
    BnetClanResponseCode status;
    BnetClanTag tag = (BnetClanTag) 0;
    gchar *s_clan = ((void *)0);
    gchar *username = ((void *)0);
    gchar *tmp;

    cookie = bnet_packet_read_dword(pkt);
    status = bnet_packet_read_byte(pkt);
    username = bnet_packet_cookie_unregister(bnet, BNET_SID_W3PROFILE, cookie);

    if (username == ((void *)0)) {
        username = (__extension__ (__builtin_constant_p ("") && ((size_t)(const void *)(("") + 1) - (size_t)(const void *)("") == 1) ? (((const char *) (""))[0] == '\0' ? (char *) calloc ((size_t) 1, (size_t) 1) : ({ size_t __len = strlen ("") + 1; char *__retval = (char *) malloc (__len); if (__retval != ((void *)0)) __retval = (char *) memcpy (__retval, "", __len); __retval; })) : __strdup ("")));
    }

    switch (status) {
        case 0x00:
                            bnet_packet_read_cstring(pkt);
                               bnet_packet_read_cstring(pkt);
            tag = bnet_packet_read_dword(pkt);
            bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_W3_CLAN;
            break;
        default:
            tmp = g_strdup_printf("Could not retrieve user information for %s (status code 0x%02x).", username, status);
            purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Warcraft III Profile Error"), (tmp), ("Unable to get the clan tag for this user. Assuming that this user is not in a clan."), ((void *)0), ((void *)0))
                                                                                                          ;
            g_free(tmp);
            purple_debug_warning("bnet", "Error retrieving profile for %s: status code 0x%02x\n", username, status);
            break;
    }

    s_clan = bnet_tag_to_string(tag);

    if (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_W3_USER_PROFILE) {
        bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_W3_USER_PROFILE;
        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {

            purple_debug_info("bnet", "Lookup complete: W3_USER_PROFILE(%s)\n", bnet->bncs.lookup_info.name);


            bnet_lookup_info_user_data(bnet);

            bnet_lookup_info_w3_user_stats(bnet);
            if (tag != (BnetClanTag) 0) {
                bnet->bncs.lookup_info.w3_tag = tag;

                bnet_lookup_info_w3_clan_stats(bnet);

                bnet_lookup_info_w3_clan_mi(bnet);
            }
            if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                        bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
            }
        } else {
            purple_debug_info("bnet", "Lookup complete: W3_USER_PROFILE([freed])\n");
        }
    } else {
        purple_debug_warning("bnet", "Not waiting for 0x35 SID_W3PROFILE\n");
    }

    g_free(s_clan);
    g_free(username);
}

static void
bnet_recv_CDKEY2(BnetConnectionData *bnet, BnetPacket *pkt)
{
    bnet_recv_CDKEY(bnet, pkt);
}

static const gchar *
bnet_get_w3record_type_string(BnetW3RecordType type)
{
    switch (type) {
        case (0x534f4c4f):
            return "Solo";
        case (0x5445414d):
            return "Team";
        case (0x46464120):
            return "FFA";
        case (0x32565332):
            return "Arranged 2 vs 2";
        case (0x33565333):
            return "Arranged 3 vs 3";
        case (0x34565534):
            return "Arranged 4 vs 4";
        case (0x434c4e53):
            return "Clan Solo";
        case (0x434c4e32):
            return "Clan 2 vs 2";
        case (0x434c4e33):
            return "Clan 3 vs 3";
        case (0x434c4e34):
            return "Clan 4 vs 4";
        case 0:
            return "Random";
        case 1:
            return "Human";
        case 2:
            return "Orc";
        case 3:
            return "Undead";
        case 4:
            return "Night Elf";
        case 5:
            return "Tournament";
        default:
            return "Unknown";
    }
}

static void
bnet_recv_LOGONREALMEX(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 d2mcp_cookie;
    BnetRealmStatus d2mcp_status;

    d2mcp_cookie = bnet_packet_read_dword(pkt);
    d2mcp_status = bnet_packet_read_dword(pkt);
    if (bnet_packet_can_read(pkt, 65)) {
        guint32 d2mcp_ip;
        guint32 d2mcp_port;
        guint32 d2mcp_data[16];
        gchar *bncs_unique_username;

        struct sockaddr_in d2mcp_addr;
        int i;

        d2mcp_data[0] = d2mcp_cookie;
        d2mcp_data[1] = d2mcp_status;
        d2mcp_data[2] = bnet_packet_read_dword(pkt);
        d2mcp_data[3] = bnet_packet_read_dword(pkt);
        d2mcp_ip = bnet_packet_read_dword(pkt);
        d2mcp_port = bnet_packet_read_dword(pkt);
        for (i = 4; i < 16; i++) {
            d2mcp_data[i] = bnet_packet_read_dword(pkt);
        }
        bncs_unique_username = bnet_packet_read_cstring(pkt);

        d2mcp_addr.sin_addr.s_addr = d2mcp_ip;
        d2mcp_addr.sin_port = (__extension__ ({ register unsigned short int __v, __x = (unsigned short int) (d2mcp_port); if (__builtin_constant_p (__x)) __v = ((unsigned short int) ((((__x) >> 8) & 0xff) | (((__x) & 0xff) << 8))); else __asm__ ("rorw $8, %w0" : "=r" (__v) : "0" (__x) : "cc"); __v; }));

        purple_debug_info("bnet", "MCP realm logon succeeded. Connect to %s:%d\n", inet_ntoa(d2mcp_addr.sin_addr), d2mcp_addr.sin_port);
        bnet_realm_connect(bnet, d2mcp_addr, d2mcp_data, bncs_unique_username);

        g_free(bncs_unique_username);
    } else {
        gchar *tmp;
        purple_debug_warning("bnet", "MCP realm logon failed. 0x%08x\n", d2mcp_status);
        switch (d2mcp_status) {
            case BNET_REALM_LOGON_UNAVAIL:
                purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), ("The Diablo II realm is unavailable."), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                              ;
                break;
            case BNET_REALM_LOGON_BADPW:
                purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), ("Diablo II realm password is incorrect."), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                              ;
                break;
            default:
                tmp = g_strdup_printf("Diablo II realm logon failed (0x%02x).", d2mcp_status);
                purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), (tmp), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                              ;
                g_free(tmp);
                break;
        }
        bnet_realm_logon_cb(bnet);
    }
}

static void
bnet_recv_QUERYREALMS2(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 count;
    gboolean auto_join = (0);
    gchar *d2realm_join;
    int i;
    GList *realm_list = ((void *)0);
    gboolean listing = (0);

                   bnet_packet_read_dword(pkt);
    count = bnet_packet_read_dword(pkt);

    d2realm_join = g_strdup(purple_account_get_string(bnet->account, "d2realm_name", ""));
    if (d2realm_join && strlen(d2realm_join) > 0) {
        auto_join = (!(0));
    } else if (count == 0) {
        purple_notify_message((bnet->account->gc), PURPLE_NOTIFY_MSG_ERROR, ("Realm Logon Error"), ("There are no Diablo II realms on this server."), ("Unable to log on to the Diablo II realm. Continuing channel log on."), ((void *)0), ((void *)0))
                                                                                      ;
        bnet_realm_logon_cb(bnet);
        g_free(d2realm_join);
        return;
    } else if (count == 1) {

        auto_join = (!(0));
    } else {
        listing = (!(0));
        purple_debug_info("bnet", "MCP There are multiple realms on this server!\n");
    }

    for (i = 0; i < count; i++) {
        guint32 d2realm_up;
        gchar *d2realm_name;
        gchar *d2realm_descr;

        d2realm_up = bnet_packet_read_dword(pkt);
        d2realm_name = bnet_packet_read_cstring(pkt);
        d2realm_descr = bnet_packet_read_cstring(pkt);

        if (listing) {
            BnetD2RealmServer *server = (BnetD2RealmServer *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetD2RealmServer); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
            server->up = d2realm_up;
            server->name = g_strdup(d2realm_name);
            server->descr = g_strdup(d2realm_descr);
            realm_list = g_list_append(realm_list, server);
        }

        if (auto_join && strlen(d2realm_join) == 0) {
            g_free(d2realm_join);
            d2realm_join = g_strdup(d2realm_name);
        }

        if (g_ascii_strcasecmp(d2realm_join, d2realm_name) == 0) {
            bnet->d2mcp.realm.name = g_strdup(d2realm_join);
            bnet->d2mcp.realm.descr = g_strdup(d2realm_descr);
        }

        g_free(d2realm_name);
        g_free(d2realm_descr);
    }

    if (auto_join) {
        const gchar *d2realm_pass = purple_account_get_string(bnet->account, "d2realm_pass", "password");
        bnet_realm_logon(bnet, bnet->bncs.logon.client_cookie, d2realm_join, d2realm_pass);
        auto_join = (0);
    }
    if (listing) {
        bnet_realm_server_list(bnet, realm_list);
    }
}

static void
bnet_recv_W3GENERAL_USERRECORD(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 cookie;

    guint8 ladder_record_count;
    guint8 race_record_count;
    guint8 team_record_count;
    guint16 visible_record_count = 0;
    int i, j;

    gchar *username;
    gchar *s_icon = ((void *)0);
    const gchar *s_type = ((void *)0);
    gchar *prpl_key = ((void *)0);
    gchar *prpl_val = ((void *)0);

    cookie = bnet_packet_read_dword(pkt);
                  bnet_packet_read_dword(pkt);

    username = bnet_packet_cookie_unregister(bnet, BNET_SID_W3GENERAL, cookie);

    if (username == ((void *)0)) {
        return;
    }



    if (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_W3_USER_STATS) {
        bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_W3_USER_STATS;
        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {

            if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
            } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
            }
            bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;






            ladder_record_count = bnet_packet_read_byte(pkt);

            for (i = 0; i < ladder_record_count; i++) {
                BnetW3RecordType type;
                guint16 wins;
                guint16 losses;
                guint8 level;
                guint16 exp;
                guint32 rank;

                gchar *s_rank = ((void *)0);

                type = bnet_packet_read_dword(pkt);
                wins = bnet_packet_read_word(pkt);
                losses = bnet_packet_read_word(pkt);
                level = bnet_packet_read_byte(pkt);
                                       bnet_packet_read_byte(pkt);
                exp = bnet_packet_read_word(pkt);
                rank = bnet_packet_read_dword(pkt);

                s_type = bnet_get_w3record_type_string(type);

                if (rank != 0) {
                    s_rank = g_strdup_printf(", rank: %d", rank);
                } else {
                    s_rank = g_strdup("");
                }
                prpl_key = g_strdup_printf("%s record for %s", s_type, bnet_get_product_name(bnet->bncs.versioning.product));
                prpl_val = g_strdup_printf("%d-%d (level: %d, exp: %d%s)", wins, losses, level, exp, s_rank);
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                g_free(prpl_key);
                g_free(prpl_val);
                g_free(s_rank);

                visible_record_count++;
            }


            race_record_count = bnet_packet_read_byte(pkt);

            for (i = 0; i < race_record_count; i++) {
                guint16 wins;
                guint16 losses;

                wins = bnet_packet_read_word(pkt);
                losses = bnet_packet_read_word(pkt);

                s_type = bnet_get_w3record_type_string(i);

                if (wins != 0 || losses != 0) {
                    prpl_key = g_strdup_printf("%s record for %s", s_type, bnet_get_product_name(bnet->bncs.versioning.product));
                    prpl_val = g_strdup_printf("%d-%d", wins, losses);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                    g_free(prpl_key);
                    g_free(prpl_val);

                    visible_record_count++;
                }
            }


            team_record_count = bnet_packet_read_byte(pkt);

            for (i = 0; i < team_record_count; i++) {
                BnetW3RecordType type;
                guint16 wins;
                guint16 losses;
                guint8 level;
                guint16 exp;
                guint32 rank;
                guint64 last_game;
                guint8 partner_count;

                gchar *partner_list = ((void *)0);
                gchar *s_last_game = ((void *)0);
                gchar *s_rank = ((void *)0);

                type = bnet_packet_read_dword(pkt);
                wins = bnet_packet_read_word(pkt);
                losses = bnet_packet_read_word(pkt);
                level = bnet_packet_read_byte(pkt);
                                       bnet_packet_read_byte(pkt);
                exp = bnet_packet_read_word(pkt);
                rank = bnet_packet_read_dword(pkt);
                last_game = bnet_packet_read_qword(pkt);
                partner_count = bnet_packet_read_byte(pkt);

                for (j = 0; j < partner_count; j++) {
                    if (partner_list == ((void *)0)) {
                        partner_list = bnet_packet_read_cstring(pkt);
                    } else {
                        gchar *new_p = bnet_packet_read_cstring(pkt);
                        gchar *new_l = g_strdup_printf("%s, %s", partner_list, new_p);
                        g_free(partner_list);
                        g_free(new_p);
                        partner_list = new_l;
                    }
                }

                s_type = bnet_get_w3record_type_string(type);

                s_last_game = bnet_format_filetime(last_game);
                if (rank != 0) {
                    s_rank = g_strdup_printf(", rank: %d", rank);
                } else {
                    s_rank = g_strdup("");
                }
                prpl_key = g_strdup_printf("%s record for %s with %s", s_type, bnet_get_product_name(bnet->bncs.versioning.product), partner_list);
                prpl_val = g_strdup_printf("%d-%d (level: %d, exp: %d%s, last played: %s)", wins, losses, level, exp, s_rank, s_last_game);
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                g_free(prpl_key);
                g_free(prpl_val);
                g_free(s_last_game);
                g_free(s_rank);
                if (partner_list != ((void *)0)) {
                    g_free(partner_list);
                }

                visible_record_count++;
            }

            if (visible_record_count == 0) {
                prpl_key = g_strdup_printf("Record for %s", bnet_get_product_name(bnet->bncs.versioning.product));
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key,
                        "No game statistics are stored in this user's record.");
                g_free(prpl_key);
            }

            if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                        bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
            }

            purple_debug_info("bnet", "Lookup complete: W3_USER_STATS(%s)\n", bnet->bncs.lookup_info.name);
        } else {
            purple_debug_info("bnet", "Lookup complete: W3_USER_STATS([freed])\n");
        }
    } else {
        purple_debug_warning("bnet", "Not waiting for 0x44 SID_W3GENERAL.WID_USERRECORD\n");
    }

    g_free(s_icon);
    g_free(username);
}

static void
bnet_recv_W3GENERAL_CLANRECORD(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 cookie;
    guint8 ladder_record_count;
    guint8 race_record_count;
    guint16 visible_record_count = 0;
    int i;

    gchar *s_clan;
    const gchar *s_type = ((void *)0);
    gchar *prpl_key = ((void *)0);
    gchar *prpl_val = ((void *)0);

    cookie = bnet_packet_read_dword(pkt);

    s_clan = bnet_packet_cookie_unregister(bnet, BNET_SID_W3GENERAL, cookie);

    if (s_clan == ((void *)0)) {
        return;
    }

    if (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_W3_CLAN_STATS) {
        bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_W3_CLAN_STATS;
        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {
            purple_debug_info("bnet", "Lookup complete: W3_CLAN_STATS(Clan %s)\n", s_clan);

            if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
            } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
            }
            bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;


            ladder_record_count = bnet_packet_read_byte(pkt);

            for (i = 0; i < ladder_record_count; i++) {
                BnetW3RecordType type;
                guint32 wins;
                guint32 losses;
                guint8 level;
                guint32 exp;
                guint32 rank;

                gchar *s_rank = ((void *)0);

                type = bnet_packet_read_dword(pkt);
                wins = bnet_packet_read_dword(pkt);
                losses = bnet_packet_read_dword(pkt);
                level = bnet_packet_read_byte(pkt);
                                       bnet_packet_read_byte(pkt);
                exp = bnet_packet_read_dword(pkt);
                rank = bnet_packet_read_dword(pkt);

                s_type = bnet_get_w3record_type_string(type);

                if (rank != 0) {
                    s_rank = g_strdup_printf(", rank: %d", rank);
                } else {
                    s_rank = g_strdup("");
                }
                prpl_key = g_strdup_printf("Clan %s %s record for %s", s_clan, s_type, bnet_get_product_name(bnet->bncs.versioning.product));
                prpl_val = g_strdup_printf("%d-%d (level: %d, exp: %d%s)", wins, losses, level, exp, s_rank);
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                g_free(prpl_key);
                g_free(prpl_val);
                g_free(s_rank);

                visible_record_count++;
            }


            race_record_count = bnet_packet_read_byte(pkt);

            for (i = 0; i < race_record_count; i++) {
                guint32 wins;
                guint32 losses;

                wins = bnet_packet_read_dword(pkt);
                losses = bnet_packet_read_dword(pkt);

                s_type = bnet_get_w3record_type_string(i);

                if (wins != 0 || losses != 0) {
                    prpl_key = g_strdup_printf("Clan %s %s record for %s", s_clan, s_type, bnet_get_product_name(bnet->bncs.versioning.product));
                    prpl_val = g_strdup_printf("%d-%d", wins, losses);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key, prpl_val);
                    g_free(prpl_key);
                    g_free(prpl_val);

                    visible_record_count++;
                }
            }

            if (visible_record_count == 0) {
                prpl_key = g_strdup_printf("Clan %s record for %s", s_clan, bnet_get_product_name(bnet->bncs.versioning.product));
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, prpl_key,
                        "No game statistics are stored in this user's clan's record.");
                g_free(prpl_key);
            }

            if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                        bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
            }
        } else {
            purple_debug_info("bnet", "Lookup complete: W3_CLAN_STATS([freed])\n");
        }
    } else {
        purple_debug_warning("bnet", "Not waiting for 0x44 SID_W3GENERAL.WID_USERRECORD\n");
    }

    g_free(s_clan);
}

static void
bnet_recv_W3GENERAL(BnetConnectionData *bnet, BnetPacket *pkt)
{
    BnetW3GeneralSubcommand subcommand = bnet_packet_read_byte(pkt);
    switch (subcommand) {
        case BNET_WID_USERRECORD:
            bnet_recv_W3GENERAL_USERRECORD(bnet, pkt);
            break;
        case BNET_WID_CLANRECORD:
            bnet_recv_W3GENERAL_CLANRECORD(bnet, pkt);
            break;
        default:

            purple_debug_warning("bnet", "Received unhandled SID_W3GENERAL packet command 0x%02x\n", subcommand);
            break;
    }
}

static void
bnet_recv_NEWS_INFO(BnetConnectionData *bnet, BnetPacket *pkt)
{
    int i;
    guint8 number_of_entries = bnet_packet_read_byte(pkt);
                                       bnet_packet_read_dword(pkt);
                         bnet_packet_read_dword(pkt);
                         bnet_packet_read_dword(pkt);

    for (i = 0; i < number_of_entries; i++) {
        guint32 timestamp = bnet_packet_read_dword(pkt);
        gchar *message = bnet_packet_read_cstring(pkt);

        if (timestamp == 0) {
            bnet_motd_free(bnet, 0);
            bnet->bncs.motds[0].name = ((void *)0);
            bnet->bncs.motds[0].subname = ((void *)0);
            bnet->bncs.motds[0].message = message;

            if (!bnet->bncs.chat_env.sent_enter_channel) {
                bnet->bncs.news.item_list = g_list_sort(bnet->bncs.news.item_list, bnet_news_item_sort);
                bnet_news_save(bnet);
                bnet->bncs.chat_env.sent_enter_channel = (!(0));
                bnet_enter_channel(bnet);
            }

            purple_debug_info("bnet", "News items: %d\n", bnet->bncs.news.item_count);
        } else {
            gboolean add_it = (!(0));
            GList *el2 = g_list_first(bnet->bncs.news.item_list);
            BnetNewsItem *item = (BnetNewsItem *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetNewsItem); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));

            while (el2 != ((void *)0)) {
                if (((BnetNewsItem *)el2->data)->timestamp == timestamp) {
                    purple_debug_warning("bnet", "duplicate in bnet_recv_NEWS_INFO\n");
                    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (((BnetNewsItem *)el2->data)->message) && __builtin_constant_p (message) && (__s1_len = strlen (((BnetNewsItem *)el2->data)->message), __s2_len = strlen (message), (!((size_t)(const void *)((((BnetNewsItem *)el2->data)->message) + 1) - (size_t)(const void *)(((BnetNewsItem *)el2->data)->message) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((message) + 1) - (size_t)(const void *)(message) == 1) || __s2_len >= 4)) ? __builtin_strcmp (((BnetNewsItem *)el2->data)->message, message) : (__builtin_constant_p (((BnetNewsItem *)el2->data)->message) && ((size_t)(const void *)((((BnetNewsItem *)el2->data)->message) + 1) - (size_t)(const void *)(((BnetNewsItem *)el2->data)->message) == 1) && (__s1_len = strlen (((BnetNewsItem *)el2->data)->message), __s1_len < 4) ? (__builtin_constant_p (message) && ((size_t)(const void *)((message) + 1) - (size_t)(const void *)(message) == 1) ? __builtin_strcmp (((BnetNewsItem *)el2->data)->message, message) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (message); register int __result = (((const unsigned char *) (const char *) (((BnetNewsItem *)el2->data)->message))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (((BnetNewsItem *)el2->data)->message))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (((BnetNewsItem *)el2->data)->message))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (((BnetNewsItem *)el2->data)->message))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (message) && ((size_t)(const void *)((message) + 1) - (size_t)(const void *)(message) == 1) && (__s2_len = strlen (message), __s2_len < 4) ? (__builtin_constant_p (((BnetNewsItem *)el2->data)->message) && ((size_t)(const void *)((((BnetNewsItem *)el2->data)->message) + 1) - (size_t)(const void *)(((BnetNewsItem *)el2->data)->message) == 1) ? __builtin_strcmp (((BnetNewsItem *)el2->data)->message, message) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (((BnetNewsItem *)el2->data)->message); register int __result = __s1[0] - ((const unsigned char *) (const char *) (message))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (message))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (message))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (message))[3]); } } __result; }))) : __builtin_strcmp (((BnetNewsItem *)el2->data)->message, message)))); }) == 0) {
                        add_it = (0);
                    }
                }
                el2 = ((el2) ? (((GList *)(el2))->next) : ((void *)0));
            }

            item->timestamp = timestamp;
            item->message = message;

            if (add_it) {
                bnet->bncs.news.item_list = g_list_append(bnet->bncs.news.item_list, item);
                bnet->bncs.news.item_count++;
                if (item->timestamp > bnet->bncs.news.latest) {
                    bnet->bncs.news.latest = item->timestamp;
                }
            } else {
                g_free(item);
                g_free(message);
            }
        }
    }
}

static void
bnet_recv_AUTH_INFO(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 logon_system = bnet_packet_read_dword(pkt);
    guint32 server_cookie = bnet_packet_read_dword(pkt);
    guint32 session_cookie = bnet_packet_read_dword(pkt);
    guint64 mpq_ft = bnet_packet_read_qword(pkt);
    char* mpq_fn = bnet_packet_read_cstring(pkt);
    char* checksum_formula = bnet_packet_read_cstring(pkt);



    bnet->bncs.logon.type = logon_system;
    bnet->bncs.logon.server_cookie = server_cookie;
    bnet->bncs.logon.session_cookie = session_cookie;

    if (bnet_is_w3(bnet)) {
        gchar *signature;
        union {
            struct sockaddr_in as_in;
            struct sockaddr as_generic;
        } sa;
        socklen_t sa_len = sizeof(sa);

        signature = (gchar *)bnet_packet_read(pkt, 128);
        if (signature == ((void *)0)) {
            purple_debug_warning("bnet", "WarCraft III: No server signature for the current Battle.net server IP provided. This may be a private server.\n");
        } else if (getpeername(bnet->bncs.conn.fd, &sa.as_generic, &sa_len) == 0) {
            struct in_addr addr = sa.as_in.sin_addr;
            purple_debug_info("bnet", "Server IP: %s\n", inet_ntoa(addr));
            if (srp_check_signature(addr.s_addr, signature) == (0)) {
                purple_debug_warning("bnet", "WarCraft III: Server sent an incorrect server signature for the current Battle.net server IP. You are connecting through a proxy or this may be a malicious server.\n");
            } else {
                purple_debug_info("bnet", "WarCraft III: Validated Battle.net server signature. This is an official Battle.net server.\n");
            }
            g_free(signature);
        } else {
            purple_debug_warning("bnet", "WarCraft III: Unable to verify server signature for the current Battle.net server IP. Error getting peer IP: %s\n", strerror((*__errno_location ())));
            g_free(signature);
        }
    }

    bnet_bnls_send_VERSIONCHECKEX2(bnet,
            logon_system, server_cookie, session_cookie, mpq_ft, mpq_fn, checksum_formula);

    g_free(mpq_fn);
    g_free(checksum_formula);
}

static void
bnet_recv_AUTH_CHECK(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 result = bnet_packet_read_dword(pkt);
    char *extra_info = bnet_packet_read_cstring(pkt);
    char *extra_info_utf8 = bnet_to_utf8_crlf(extra_info);

    PurpleConnection *gc = bnet->account->gc;

    char *tmp = ((void *)0);
    char *tmpe = ((void *)0);
    char *tmpf = ((void *)0);
    char *tmpkn = ((void *)0);

    PurpleConnectionError conn_error = PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED;

    if (result == 0x0000) {
        bnet->bncs.versioning.complete = (!(0));

        purple_debug_info("bnet", "Version and key check passed!\n");

        if (!bnet->bncs.logon.create_account) {
            purple_connection_update_progress(gc, "Authenticating", 3, 5);
        }

        bnet_account_logon(bnet);

        g_free(extra_info);

        return;
    } else if (result & 0x0100) {
        switch (result & 0x000F) {
            case 0x0001:
                tmp = "Version invalid%s.";
                break;
            case 0x0000:
                tmp = "Old version%s.";
                break;
            case 0x0002:
                tmp = "New version%s.";
                break;
            default:
                tmp = "Version invalid%s.";
                break;
        }
    } else if (result & 0x0200) {
        guint32 keynum = (result & 0x00F0) >> 4;
        switch (result & 0x000F) {
            case 0x0000:
                tmp = "CD-key invalid%s.";
                break;
            case 0x0001:
                tmp = "CD-key is in use%s.";
                if (strlen(extra_info) > 0) {
                    if (g_ascii_strcasecmp(extra_info, bnet->bncs.versioning.key_owner) == 0) {
                        tmp = "CD-key is in use%s. Battle.net may not have discovered that you disconnected yet. Try again in five minutes.";
                        conn_error = PURPLE_CONNECTION_ERROR_NETWORK_ERROR;
                    }
                }
                break;
            case 0x0002:
                tmp = "CD-key is banned%s.";
                break;
            case 0x0003:
                tmp = "CD-key is for another game%s.";
                break;
            default:
                tmp = "CD-key invalid%s.";
                break;
        }
        tmpkn = g_strdup_printf("%s%s", (keynum == 1) ? "Expansion " : "", tmp);
        tmp = tmpkn;
    } else if (result & 0x00FF) {
        tmp = "Version code invalid%s.";
    } else {
        tmp = "Authorization failed%s.";
    }

    tmpe = g_strdup_printf(" (%s)", extra_info_utf8);
    tmpf = g_strdup_printf(tmp, strlen(extra_info) > 0 ? tmpe : "");
    purple_connection_error_reason(gc, conn_error, tmpf);

    g_free(tmpe);
    g_free(tmpf);
    if (tmpkn) g_free(tmpkn);

    g_free(extra_info);
    g_free(extra_info_utf8);
}

static void
bnet_recv_AUTH_ACCOUNTCREATE(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *tmp;
    PurpleConnection *gc = bnet->account->gc;
    guint32 result = bnet_packet_read_dword(pkt);

    switch (result) {
        case 0x0000:
            purple_debug_info("bnet", "Account created!\n");
            bnet->bncs.logon.create_account = (0);
            bnet_close(gc);
            return;
        case 0x04:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
                    "Account name in use.");
            break;
        case 0x07:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_INVALID_USERNAME,
                    "Account name is too short.");
            break;
        case 0x08:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_INVALID_USERNAME,
                    "Account name contains an illegal character.");
            break;
        case 0x09:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_INVALID_USERNAME,
                    "Account name contains a banned word.");
            break;
        case 0x0A:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_INVALID_USERNAME,
                    "Account name does not contain enough alphanumeric characters.");
            break;
        case 0x0B:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_INVALID_USERNAME,
                    "Account name contains adjacent punctuation characters.");
            break;
        case 0x0C:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_INVALID_USERNAME,
                    "Account name contains too many punctuation characters.");
            break;
        default:
            tmp = g_strdup_printf("Account creation failure (0x%02x).", result);
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
                    tmp);
            g_free(tmp);
            break;
    }

    if (bnet->bncs.logon.auth_ctx != ((void *)0)) {
        srp_free(bnet->bncs.logon.auth_ctx);
        bnet->bncs.logon.auth_ctx = ((void *)0);
    }
}


static void
bnet_recv_AUTH_ACCOUNTLOGON(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *tmp;
    PurpleConnection *gc = bnet->account->gc;
    guint32 result = bnet_packet_read_dword(pkt);

    bnet_account_lockout_cancel(bnet);

    switch (result) {
        case 0x0000:
            {
                gchar M1[20];
                gchar *salt = (gchar *)bnet_packet_read(pkt, 32);
                gchar *B = (gchar *)bnet_packet_read(pkt, 32);
                srp_get_M1(bnet->bncs.logon.auth_ctx, M1, B, salt);
                bnet_send_AUTH_ACCOUNTLOGONPROOF(bnet, M1);
                g_free(salt);
                g_free(B);
                return;
            }
        case 0x01:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
                    "Account does not exist.");
            break;
        case 0x05:
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
                    "Account requires upgrade.");
            break;
        default:
            tmp = g_strdup_printf("Account logon failure (0x%02x).", result);
            purple_connection_error_reason(gc,
                    PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
                    tmp);
            g_free(tmp);
            break;
    }

    if (bnet->bncs.logon.auth_ctx != ((void *)0)) {
        srp_free(bnet->bncs.logon.auth_ctx);
        bnet->bncs.logon.auth_ctx = ((void *)0);
    }
}

static void
bnet_recv_AUTH_ACCOUNTLOGONPROOF(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *tmp;
    gchar *tmp_result;
    gchar *tmp_error;
    PurpleConnection *gc = bnet->account->gc;
    guint32 result = bnet_packet_read_dword(pkt);
    gchar *M2 = (gchar *)bnet_packet_read(pkt, 20);
    gchar *additional_info = bnet_packet_read_cstring(pkt);

    switch (result) {
        case 0x0000:
            if (srp_check_M2(bnet->bncs.logon.auth_ctx, M2) == (0)) {
                purple_notify_message((gc), PURPLE_NOTIFY_MSG_ERROR, ("SRP Account Verification"), ("The server may not actually know your password!"), ("It sent an invalid M[2] response."), ((void *)0), ((void *)0))
                                                            ;
            } else {
                purple_debug_info("bnet", "SRP: Validated M[2] value.\n");
            }

            purple_debug_info("bnet", "Logged in!\n");
            purple_connection_update_progress(gc, "Entering chat", 4, 5);

            bnet_enter_chat(bnet);
            return;
        case 0x02:
            tmp_result = g_strdup("Password incorrect%s.");
            break;
        case 0x06:
            tmp_result = g_strdup("Account closed%s.");
            break;
        case 0x0E:
            bnet_request_set_email(bnet, (0));
            purple_debug_info("bnet", "Logged in!\n");
            purple_connection_update_progress(gc, "Entering chat", 4, 5);
            bnet_enter_chat(bnet);
            return;
        case 0x0F:
            tmp_result = g_strdup("Account logon failure%s.");
            break;
        default:
            tmp_result = g_strdup_printf("Account logon failure%%s (0x%02x)", result);
            break;
    }

    if (additional_info != ((void *)0) && strlen(additional_info) > 0) {
        tmp = g_strdup_printf(tmp_result, " (%s)");
        tmp_error = g_strdup_printf(tmp, additional_info);
        g_free(tmp_result);
        g_free(tmp);
    } else {
        tmp_error = g_strdup_printf(tmp_result, "");
    }

    purple_connection_error_reason(gc,
            PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
            tmp_error);

    g_free(M2);
    g_free(additional_info);
    g_free(tmp_error);
}

static void
bnet_recv_SETEMAIL(BnetConnectionData *bnet, BnetPacket *pkt)
{
    bnet_request_set_email(bnet, (0));
}

static void
bnet_recv_LOGONRESPONSE2(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *tmp;
    gchar *tmp_result;
    gchar *tmp_error;
    PurpleConnection *gc = bnet->account->gc;
    guint32 result = bnet_packet_read_dword(pkt);
    gchar *additional_info = ((void *)0);
    if (bnet_packet_can_read(pkt, 1)) {
        additional_info = bnet_packet_read_cstring(pkt);
    }

    bnet_account_lockout_cancel(bnet);

    switch (result) {
        case 0x0000:
            purple_debug_info("bnet", "Logged in!\n");
            purple_connection_update_progress(gc, "Entering chat", 4, 5);

            bnet_enter_chat(bnet);
            return;
        case 0x01:
            tmp_result = g_strdup("Account does not exist%s.");
            break;
        case 0x02:
            tmp_result = g_strdup("Password incorrect%s.");
            break;
        case 0x06:
            tmp_result = g_strdup("Account closed%s.");
            break;
        default:
            tmp_result = g_strdup_printf("Account logon failure%%s (0x%02x)", result);
            break;
    }

    if (additional_info != ((void *)0) && strlen(additional_info) > 0) {
        tmp = g_strdup_printf(tmp_result, " (%s)");
        tmp_error = g_strdup_printf(tmp, additional_info);
        g_free(tmp_result);
        g_free(tmp);
    } else {
        tmp_error = g_strdup_printf(tmp_result, "");
    }

    purple_connection_error_reason(gc,
            PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
            tmp_error);

    g_free(additional_info);
    g_free(tmp_error);
}

static void
bnet_recv_CREATEACCOUNT2(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gchar *tmp;
    gchar *tmp_result;
    gchar *tmp_error;
    PurpleConnection *gc = bnet->account->gc;
    guint32 result = bnet_packet_read_dword(pkt);
    gchar *suggested_name = bnet_packet_read_cstring(pkt);

    switch (result) {
        case 0x0000:
            purple_debug_info("bnet", "Account created!\n");
            bnet->bncs.logon.create_account = (0);
            bnet_close(gc);
            return;
        case 0x02:
            tmp_result = g_strdup("Account name contains an illegal character");
            break;
        case 0x03:
            tmp_result = g_strdup("Account name contains a banned word");
            break;
        case 0x04:
            tmp_result = g_strdup("Account name in use");
            break;
        case 0x06:
            tmp_result = g_strdup("Account name does not contain enough alphanumeric characters%s.");
            break;
        default:
            tmp_result = g_strdup_printf("Account create failure%%s (0x%02x).", result);
            break;
    }

    if (suggested_name != ((void *)0) && strlen(suggested_name) > 0) {
        tmp = g_strdup_printf(tmp_result, " (suggested name: %s)");
        tmp_error = g_strdup_printf(tmp, suggested_name);
        g_free(tmp_result);
        g_free(tmp);
    } else {
        tmp_error = g_strdup_printf(tmp_result, "");
    }

    purple_connection_error_reason(gc,
            PURPLE_CONNECTION_ERROR_INVALID_USERNAME,
            tmp_error);

    g_free(suggested_name);
    g_free(tmp_error);
}

static void
bnet_recv_FRIENDSLIST(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint8 fcount = bnet_packet_read_byte(pkt);
    guint8 idx = 0;
    GList *old_friends_list = bnet->bncs.friends.list;
    GList *el = ((void *)0);

    bnet->bncs.friends.list = ((void *)0);
    purple_debug_info("bnet", "%d friends on list\n", fcount);

    if (fcount > 0) {
        while (idx < fcount) {
            BnetFriendInfo *bfi = ((void *)0);
            BnetFriendInfo *old_bfi = ((void *)0);

            gchar *account_name = bnet_packet_read_cstring(pkt);
            BnetFriendStatus status = bnet_packet_read_byte(pkt);
            BnetFriendLocation location = bnet_packet_read_byte(pkt);
            BnetProductID product_id = bnet_packet_read_dword(pkt);
            gchar *location_name = bnet_packet_read_cstring(pkt);

            el = g_list_first(old_friends_list);
            while (el != ((void *)0)) {
                if (el->data != ((void *)0)) {
                    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (((BnetFriendInfo *)el->data)->account) && __builtin_constant_p (account_name) && (__s1_len = strlen (((BnetFriendInfo *)el->data)->account), __s2_len = strlen (account_name), (!((size_t)(const void *)((((BnetFriendInfo *)el->data)->account) + 1) - (size_t)(const void *)(((BnetFriendInfo *)el->data)->account) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((account_name) + 1) - (size_t)(const void *)(account_name) == 1) || __s2_len >= 4)) ? __builtin_strcmp (((BnetFriendInfo *)el->data)->account, account_name) : (__builtin_constant_p (((BnetFriendInfo *)el->data)->account) && ((size_t)(const void *)((((BnetFriendInfo *)el->data)->account) + 1) - (size_t)(const void *)(((BnetFriendInfo *)el->data)->account) == 1) && (__s1_len = strlen (((BnetFriendInfo *)el->data)->account), __s1_len < 4) ? (__builtin_constant_p (account_name) && ((size_t)(const void *)((account_name) + 1) - (size_t)(const void *)(account_name) == 1) ? __builtin_strcmp (((BnetFriendInfo *)el->data)->account, account_name) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (account_name); register int __result = (((const unsigned char *) (const char *) (((BnetFriendInfo *)el->data)->account))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (((BnetFriendInfo *)el->data)->account))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (((BnetFriendInfo *)el->data)->account))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (((BnetFriendInfo *)el->data)->account))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (account_name) && ((size_t)(const void *)((account_name) + 1) - (size_t)(const void *)(account_name) == 1) && (__s2_len = strlen (account_name), __s2_len < 4) ? (__builtin_constant_p (((BnetFriendInfo *)el->data)->account) && ((size_t)(const void *)((((BnetFriendInfo *)el->data)->account) + 1) - (size_t)(const void *)(((BnetFriendInfo *)el->data)->account) == 1) ? __builtin_strcmp (((BnetFriendInfo *)el->data)->account, account_name) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (((BnetFriendInfo *)el->data)->account); register int __result = __s1[0] - ((const unsigned char *) (const char *) (account_name))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (account_name))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (account_name))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (account_name))[3]); } } __result; }))) : __builtin_strcmp (((BnetFriendInfo *)el->data)->account, account_name)))); }) == 0) {
                        old_bfi = el->data;
                    }
                }
                el = ((el) ? (((GList *)(el))->next) : ((void *)0));
            }

            if (old_bfi == ((void *)0)) {
                bfi = (BnetFriendInfo *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetFriendInfo); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
                bfi->type = 0x02;
                bfi->account = account_name;
                bfi->status = -1;
                bfi->location = -1;
                bfi->product = -1;
                bfi->location_name = g_strdup("");
                purple_debug_info("bnet", "Friend diff: %s added\n", bfi->account);
            } else {
                bfi = old_bfi;

            }
            bfi->on_list = (!(0));

            bnet->bncs.friends.list = g_list_append(bnet->bncs.friends.list, bfi);

            bnet_friend_update(bnet, idx, bfi, status, location, product_id, location_name);

            g_free(location_name);

            idx++;
        }
    }

    el = g_list_first(old_friends_list);
    while (el != ((void *)0)) {
        if (el->data != ((void *)0)) {
            if (!((BnetFriendInfo *)el->data)->on_list) {
                PurpleBuddy *buddy;
                BnetFriendInfo *old_bfi = ((void *)0);

                old_bfi = el->data;
                purple_debug_info("bnet", "Friend diff: %s no longer on list\n", old_bfi->account);

                buddy = purple_find_buddy(bnet->account, old_bfi->account);

                bnet_friend_info_free(old_bfi);

                if (buddy) {

                    purple_buddy_set_protocol_data(buddy, ((void *)0));

                    purple_blist_remove_buddy(buddy);
                }
            }
        }
        el = ((el) ? (((GList *)(el))->next) : ((void *)0));
    }

    g_list_free(old_friends_list);

    el = g_list_first(bnet->bncs.friends.list);
    while (el != ((void *)0)) {
        ((BnetFriendInfo *)el->data)->on_list = (0);
        el = ((el) ? (((GList *)(el))->next) : ((void *)0));
    }

    bnet_find_detached_buddies(bnet);
}

static void
bnet_recv_FRIENDSUPDATE(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint8 index = bnet_packet_read_byte(pkt);
    BnetFriendInfo *bfi = g_list_nth_data(bnet->bncs.friends.list, index);

    BnetFriendStatus status = bnet_packet_read_byte(pkt);
    BnetFriendLocation location = bnet_packet_read_byte(pkt);
    BnetProductID product_id = bnet_packet_read_dword(pkt);
    gchar *location_name = bnet_packet_read_cstring(pkt);

    bnet_friend_update(bnet, index, bfi, status, location, product_id, location_name);

    g_free(location_name);
}

static void
bnet_recv_FRIENDSADD(BnetConnectionData *bnet, BnetPacket *pkt)
{
    BnetFriendInfo *bfi = (BnetFriendInfo *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetFriendInfo); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    guint8 index = g_list_length(bnet->bncs.friends.list);

    gchar *account_name = bnet_packet_read_cstring(pkt);

    BnetFriendStatus status = bnet_packet_read_byte(pkt);
    BnetFriendLocation location = bnet_packet_read_byte(pkt);
    BnetProductID product_id = bnet_packet_read_dword(pkt);
    gchar *location_name = bnet_packet_read_cstring(pkt);

    bfi->type = 0x02;
    bfi->account = account_name;
    bfi->status = -1;
    bfi->location = -1;
    bfi->product = -1;
    bfi->location_name = g_strdup("");

    bnet->bncs.friends.list = g_list_append(bnet->bncs.friends.list, bfi);

    bnet_friend_update(bnet, index, bfi, status, location, product_id, location_name);

    g_free(location_name);


}

static void
bnet_recv_FRIENDSREMOVE(BnetConnectionData *bnet, BnetPacket *pkt)
{
    PurpleBuddy *buddy = ((void *)0);
    BnetFriendInfo *bfi = ((void *)0);
    guint8 index = bnet_packet_read_byte(pkt);
    GList *el = g_list_nth(bnet->bncs.friends.list, index);

    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (el != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "el != NULL"); return; }; }while (0);

    bfi = (BnetFriendInfo *) el->data;

    if (bfi == ((void *)0)) {

        bnet->bncs.friends.list = g_list_remove_link(bnet->bncs.friends.list, el);
        g_list_free_1(el);
    } else {

        buddy = purple_find_buddy(bnet->account, bfi->account);

        if (buddy) {

            purple_buddy_set_protocol_data(buddy, ((void *)0));

            purple_blist_remove_buddy(buddy);

            bnet_friend_info_free(el->data);
        }

        bnet->bncs.friends.list = g_list_remove_link(bnet->bncs.friends.list, el);
        g_list_free_1(el);
    }
}

static void
bnet_recv_FRIENDSPOSITION(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint8 old_index = bnet_packet_read_byte(pkt);
    guint8 new_index = bnet_packet_read_byte(pkt);
    GList *bfi_link = g_list_nth(bnet->bncs.friends.list, old_index);

    bnet->bncs.friends.list = g_list_remove_link(bnet->bncs.friends.list, bfi_link);
    bnet->bncs.friends.list = g_list_insert(bnet->bncs.friends.list, bfi_link->data, new_index);
}

static void
bnet_recv_CLANFINDCANDIDATES(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANINVITEMULTIPLE(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANCREATIONINVITATION(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gint32 cookie = bnet_packet_read_dword(pkt);
    BnetClanTag clan_tag = bnet_packet_read_dword(pkt);
    gchar *clan_name = bnet_packet_read_cstring(pkt);
    gchar *inviter_name = bnet_packet_read_cstring(pkt);
    char invitees_buf[200];
    guint8 invitees_count = bnet_packet_read_byte(pkt);
    int i;
    int pos = 0;
    gchar *clan_tag_string = bnet_tag_to_string(clan_tag);
    BnetClanInvitationCallbackData *callback_data = ((void *)0);
    gchar *inv_text;

    for (i = 0; i < invitees_count && i < 10; i++) {
        gchar *user = bnet_packet_read_cstring(pkt);
        if (pos < 199 && pos > 0) {
            invitees_buf[pos] = ',';
            invitees_buf[pos + 1] = ' ';
            pos += 2;
        }
        if (pos < 200 - strlen(user)) {
            memmove(invitees_buf + pos, user, strlen(user));
            pos += strlen(user);
        }
        g_free(user);
    }
    invitees_buf[pos] = '\0';
    inv_text = g_strdup_printf("You have been invited by %s to help create Clan %s, %s with %d other users:",
                inviter_name, clan_tag_string, clan_name, invitees_count),

    callback_data = (BnetClanInvitationCallbackData *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetClanInvitationCallbackData); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    callback_data->bnet = bnet;
    callback_data->packet_id = BNET_SID_CLANCREATIONINVITATION;
    callback_data->cookie = cookie;
    callback_data->clan_tag = clan_tag;
    callback_data->inviter = g_strdup(inviter_name);
    callback_data->clan_name = g_strdup(clan_name);

    purple_request_action(bnet->account->gc, "Clan Creation Invitation",
            inv_text,
            invitees_buf,
            0,
            bnet->account,
            ((void *)0), ((void *)0),
            callback_data,
            2,
            "_Decline", bnet_clan_invite_decline_cb,
            "_Accept", bnet_clan_invite_accept_cb);

    g_free(inv_text);
    g_free(clan_name);
    g_free(inviter_name);
    g_free(clan_tag_string);
}

static void
bnet_recv_CLANDISBAND(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANMAKECHIEFTAIN(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANINFO(BnetConnectionData *bnet, BnetPacket *pkt)
{
    BnetClanTag clan_tag;
    BnetClanMemberRank rank;
    int motd_cookie, memblist_cookie, selfinfo_cookie;
    const gchar *acct_norm = bnet->bncs.logon.username;

    bnet_packet_read_byte(pkt);
    clan_tag = (BnetClanTag) bnet_packet_read_dword(pkt);
    rank = (BnetClanMemberRank) bnet_packet_read_byte(pkt);
    bnet->bncs.w3_clan.in_clan = (!(0));
    bnet->bncs.w3_clan.my_clantag = clan_tag;
    bnet->bncs.w3_clan.my_rank = rank;

    memblist_cookie = bnet_packet_cookie_register(bnet, BNET_SID_CLANMEMBERLIST, ((void *)0));
    bnet_send_CLANMEMBERLIST(bnet, memblist_cookie);

    selfinfo_cookie = bnet_packet_cookie_register(bnet, BNET_SID_CLANMEMBERINFO, ((void *)0));
    bnet->bncs.lookup_info.w3_tag = clan_tag;
    bnet_send_CLANMEMBERINFO(bnet, selfinfo_cookie, clan_tag, acct_norm);

    motd_cookie = bnet_packet_cookie_register(bnet, BNET_SID_CLANMOTD, ((void *)0));
    bnet_send_CLANMOTD(bnet, motd_cookie);
}

static void
bnet_recv_CLANQUITNOTIFY(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANINVITATION(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANREMOVEMEMBER(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANINVITATIONRESPONSE(BnetConnectionData *bnet, BnetPacket *pkt)
{
    gint32 cookie = bnet_packet_read_dword(pkt);
    BnetClanTag clan_tag = bnet_packet_read_dword(pkt);
    gchar *clan_name = bnet_packet_read_cstring(pkt);
    gchar *inviter_name = bnet_packet_read_cstring(pkt);

    gchar *clan_tag_string = bnet_tag_to_string(clan_tag);
    BnetClanInvitationCallbackData *callback_data = ((void *)0);
    gchar *inv_text = g_strdup_printf("You have been inviteby %s to join Clan %s, %s!",
                inviter_name, clan_tag_string, clan_name);

    callback_data = (BnetClanInvitationCallbackData *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetClanInvitationCallbackData); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    callback_data->bnet = bnet;
    callback_data->packet_id = BNET_SID_CLANINVITATIONRESPONSE;
    callback_data->cookie = cookie;
    callback_data->clan_tag = clan_tag;
    callback_data->inviter = g_strdup(inviter_name);
    callback_data->clan_name = g_strdup(clan_name);

    purple_request_action(bnet->account->gc, "Clan Invitation",
            inv_text,
            ((void *)0),
            0,
            bnet->account,
            ((void *)0), ((void *)0),
            callback_data,
            2,
            "_Decline", bnet_clan_invite_decline_cb,
            "_Accept", bnet_clan_invite_accept_cb);

    g_free(inv_text);
    g_free(clan_name);
    g_free(inviter_name);
    g_free(clan_tag_string);
}

static void
bnet_recv_CLANRANKCHANGE(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANMOTD(BnetConnectionData *bnet, BnetPacket *pkt)
{
    PurpleConversation *conv = ((void *)0);
    PurpleConvChat *chat = ((void *)0);
    guint32 cookie;
    gchar *motd;
    gchar *s_tag;
    const gchar *s_name;

    cookie = bnet_packet_read_dword(pkt);
    bnet_packet_read_dword(pkt);
    motd = bnet_packet_read_cstring(pkt);

    bnet_packet_cookie_unregister(bnet, BNET_SID_CLANMOTD, cookie);
    s_tag = bnet_tag_to_string(bnet->bncs.w3_clan.my_clantag);
    s_name = bnet->bncs.w3_clan.my_clanname;
    bnet_motd_free(bnet, 3);
    bnet->bncs.motds[3].name = g_strdup_printf("Clan %s", s_tag);
    if (s_name != ((void *)0)) {
        bnet->bncs.motds[3].subname = g_strdup(s_name);
    }
    bnet->bncs.motds[3].message = g_strdup(motd);
    if (!bnet->bncs.chat_env.first_join && bnet->bncs.channel.prpl_chat_id != 0) {
        conv = purple_find_chat(bnet->account->gc, bnet->bncs.channel.prpl_chat_id);
    }
    if (conv != ((void *)0)) {
        chat = purple_conversation_get_chat_data(conv);
    }
    if (chat != ((void *)0) && bnet_clan_is_clan_channel(bnet, bnet->bncs.channel.name)) {
        purple_conv_chat_set_topic(chat, "(clan leader)", motd);
    }
    g_free(s_tag);
    g_free(motd);
}

static void
bnet_recv_CLANMEMBERLIST(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 cookie;
    guint8 number_of_members;
    GList *members = ((void *)0);
    const gchar *group_name_setting;
    gchar *group_name;
    PurpleGroup *group;
    BnetClanTag clan_tag;
    gchar *clan_tag_text;
    int i;
    gboolean do_not_free = (0);

    cookie = bnet_packet_read_dword(pkt);
    bnet_packet_cookie_unregister(bnet, BNET_SID_CLANMEMBERLIST, cookie);

    clan_tag = bnet->bncs.w3_clan.my_clantag;
    clan_tag_text = bnet_tag_to_string(clan_tag);

    number_of_members = bnet_packet_read_byte(pkt);

    purple_debug_info("bnet", "Clan members: %d\n", number_of_members);

    group_name_setting = purple_account_get_string(bnet->account, "grpclan", "Clan %T members");
    group_name = g_strdup_printf(group_name_setting, clan_tag_text);
    group = purple_group_new(group_name);

    for (i = 0; i < number_of_members; i++) {
        gchar *name = bnet_packet_read_cstring(pkt);
        BnetClanMemberRank rank = bnet_packet_read_byte(pkt);
        BnetClanMemberStatus status = bnet_packet_read_byte(pkt);
        gchar *location = bnet_packet_read_cstring(pkt);

        BnetClanMember *member = bnet_clan_member_new(name, rank, status, location);
        members = g_list_append(members, member);
    }

    if (purple_account_get_bool(bnet->account, "showgrpclan", (0))) {
        GList *el = g_list_first(members);
        for (i = 0; i < number_of_members; i++) {
            BnetClanMember *member = el->data;
            gchar *name = bnet_clan_member_get_name(member);
            const gchar *prpl_status = ((void *)0);
            GSList *buddies;
            PurpleBuddy *buddy = ((void *)0);
            BnetUser *current_member = ((void *)0);
            gboolean found_mergable;

            bnet->bncs.w3_clan.clan_members_in_blist = (!(0));

            switch (bnet_clan_member_get_status(member)) {
                case BNET_CLAN_STATUS_OFFLINE:
                    prpl_status = "Offline";
                    break;
                case BNET_CLAN_STATUS_ONLINE:
                default:
                    prpl_status = "Online";
                    break;
            }

            buddies = purple_find_buddies(bnet->account, name);
            found_mergable = (0);
            while (buddies != ((void *)0)) {
                buddy = buddies->data;
                current_member = purple_buddy_get_protocol_data(buddy);
                if (current_member != ((void *)0) && current_member->type == 0x04) {

                    found_mergable = (!(0));
                    purple_buddy_set_protocol_data(buddy, member);
                    bnet_clan_member_set_joindate(member, bnet_clan_member_get_joindate((BnetClanMember *)current_member));
                    break;
                }
                buddies = ((buddies) ? (((GSList *)(buddies))->next) : ((void *)0));
            }
            if (!found_mergable) {
                purple_debug_info("bnet", "Clan diff: %s added\n", name);
                buddy = purple_buddy_new(bnet->account, name, name);
                purple_blist_node_set_flags(((PurpleBlistNode *)(buddy)), PURPLE_BLIST_NODE_FLAG_NO_SAVE);
                purple_blist_add_buddy(buddy, ((void *)0), group, ((void *)0));
                purple_buddy_set_protocol_data(buddy, member);
                purple_prpl_got_user_status(bnet->account, name, prpl_status, ((void *)0));
            } else if (bnet_clan_member_get_status((BnetClanMember *)current_member) !=
                    bnet_clan_member_get_status(member)) {
                purple_debug_info("bnet", "Clan diff: %s updated\n", name);
                purple_prpl_got_user_status(bnet->account, name, prpl_status, ((void *)0));
            }
            el = ((el) ? (((GList *)(el))->next) : ((void *)0));
        }
    } else if (bnet->bncs.w3_clan.clan_members_in_blist) {


        bnet->bncs.w3_clan.clan_members_in_blist = (0);
        do_not_free = (!(0));
    }

    if (!do_not_free && bnet->bncs.w3_clan.my_clanmembers != ((void *)0)) {
        _g_list_free_full(bnet->bncs.w3_clan.my_clanmembers, (GDestroyNotify)bnet_clan_member_free);
    }
    bnet->bncs.w3_clan.my_clanmembers = members;
}

static void
bnet_recv_CLANMEMBERREMOVED(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANMEMBERSTATUSCHANGE(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANMEMBERRANKCHANGE(BnetConnectionData *bnet, BnetPacket *pkt)
{
}

static void
bnet_recv_CLANMEMBERINFO(BnetConnectionData *bnet, BnetPacket *pkt)
{
    guint32 cookie;
    BnetClanResponseCode status;
    gchar *s_clan = ((void *)0);
    const gchar *s_rank = ((void *)0);
    gchar *s_clan_joindate = ((void *)0);
    gchar *clan_name = ((void *)0);
    BnetClanMemberRank clan_rank = BNET_CLAN_RANK_INITIATE;
    guint64 clan_joindate = 0;

    cookie = bnet_packet_read_dword(pkt);
    status = bnet_packet_read_byte(pkt);
    s_clan = bnet_packet_cookie_unregister(bnet, BNET_SID_CLANMEMBERINFO, cookie);

    switch (status) {
        case 0x00:
            clan_name = bnet_packet_read_cstring(pkt);
            clan_rank = bnet_packet_read_byte(pkt);
            clan_joindate = bnet_packet_read_qword(pkt);

            if (bnet->bncs.w3_clan.my_clantag == bnet->bncs.lookup_info.w3_tag) {
                BnetClanMember *member = bnet_clan_find_member(bnet, bnet->bncs.lookup_info.name);
                bnet->bncs.w3_clan.my_clanname = g_strdup(clan_name);
                if (member != ((void *)0)) {
                    bnet_clan_member_set_joindate(member, clan_joindate);
                }
            }
            break;
        case 0x0c:
            purple_debug_warning("bnet", "Error retrieving member info for %s: user not found in that clan\n", bnet->bncs.lookup_info.name);
            break;
        default:
            purple_debug_warning("bnet", "Error retrieving member info for %s: status code 0x%02x\n", bnet->bncs.lookup_info.name, status);
            break;
    }

    if (s_clan == ((void *)0)) {

        return;
    }

    s_rank = bnet_clan_rank_to_string(clan_rank);
    s_clan_joindate = bnet_format_filetime(clan_joindate);

    if (bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_W3_CLAN_MI) {
        bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_AWAIT_W3_CLAN_MI;
        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_CANCELLED)) {

            purple_debug_info("bnet", "Lookup complete: W3_CLAN_MI(%s, Clan %s)\n", bnet->bncs.lookup_info.name, s_clan);
            if (!bnet->bncs.lookup_info.prpl_notify_handle) {
                bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
            } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
                purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
            }
            bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;

            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Clan tag", s_clan);
            if (status == 0x00) {
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Clan name", clan_name);
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Clan rank", s_rank);
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Clan join date", s_clan_joindate);

                if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                    purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                            bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
                }
            }

            if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
                purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                        bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
            }
        } else {
            purple_debug_info("bnet", "Lookup complete: W3_CLAN_MI([freed])\n");
        }
    } else {
        purple_debug_warning("bnet", "Not waiting for 0x82 SID_CLANMEMBERINFO\n");
    }

    g_free(s_clan);
    if (clan_name != ((void *)0)) {
        g_free(clan_name);
    }
    if (s_clan_joindate != ((void *)0)) {
        g_free(s_clan_joindate);
    }
}

static gboolean
bnet_parse_telnet_line_event(BnetConnectionData *bnet, GRegex *regex, const gchar *text, GMatchInfo *mi)
{
    gchar *id_str = g_match_info_fetch(mi, 1);
    gchar *rest = g_match_info_fetch(mi, 2);
    int id = atoi(id_str);
    BnetChatEventFlags flags;
    gint32 ping;
    PurpleConversation *conv = ((void *)0);
    PurpleConvChat *chat = ((void *)0);
    PurpleConnection *gc = bnet->account->gc;

    if (!bnet->bncs.chat_env.is_online) {
        bnet_entered_chat(bnet);
    }
    if (!bnet->bncs.chat_env.first_join && bnet->bncs.channel.prpl_chat_id != 0) {
        conv = purple_find_chat(gc, bnet->bncs.channel.prpl_chat_id);
    }
    if (conv != ((void *)0)) {
        chat = purple_conversation_get_chat_data(conv);
    }

    if (id >= 1000 && id < 2000) {
        gchar *name = ((void *)0);
        gchar *flags_str = ((void *)0);
        gchar *text_str = ((void *)0);
        int i, j;
        gboolean regex_matched = (0);

        id -= 1000;

        i = 0;
        while (bnet_regex_store[i].regex != ((void *)0)) {
            GRegex *ev_regex = bnet_regex_store[i].regex;
            GMatchInfo *ev_mi = ((void *)0);

            if (regex_matched) {
                break;
            }

            if (bnet_regex_store[i].event_id == 1000) {
                if (g_regex_match(ev_regex, rest, 0, &ev_mi)) {
                    for (j = 0; j < strlen(bnet_regex_store[i].arg_format); j++) {
                        char arg = bnet_regex_store[i].arg_format[j];
                        switch (arg) {
                            case '\0':
                                break;
                            case 'n':
                                name = g_match_info_fetch(ev_mi, j + 1);
                                break;
                            case 'f':
                                flags_str = g_match_info_fetch(ev_mi, j + 1);
                                break;
                            case 't':
                                text_str = g_match_info_fetch(ev_mi, j + 1);
                                break;
                            case 'p':
                                text_str = g_match_info_fetch(ev_mi, j + 1);
                                g_strreverse(text_str);
                                break;
                        }
                    }
                    regex_matched = (!(0));
                }
                if (mi != ((void *)0)) {
                    g_match_info_free(ev_mi);
                    mi = ((void *)0);
                }
            }

            i++;
        }

        if (name == ((void *)0)) {
            name = g_strdup("");
        }
        if (flags_str == ((void *)0)) {
            flags_str = g_strdup("0");
        }
        if (text_str == ((void *)0)) {
            text_str = g_strdup("");
        }

        flags = atoi(flags_str);
        ping = -1;

        bnet_recv_event(bnet, chat, id, name, text_str, flags, ping);
        g_free(name);
        g_free(flags_str);
        g_free(text_str);
    } else if (id >= 2000 && id < 3000) {
        id -= 2000;
        switch (id) {
            case BNET_SID_NULL:

                break;
            case BNET_SID_ENTERCHAT:

                bnet->bncs.chat_env.stats = g_strdup("");
                bnet->bncs.chat_env.unique_name = g_strdup(rest);
                purple_connection_set_display_name(gc, bnet->bncs.logon.username);
                break;
        }
    } else if (id == 3000) {
        bnet_recv_event_INFO(bnet, chat, "Battle.net 3000", rest, 0, -1);
    }

    g_free(id_str);
    g_free(rest);

    return (!(0));
}

static void
bnet_parse_telnet_line(BnetConnectionData *bnet, const gchar *line)
{
    gchar *text = bnet_to_utf8_crlf(line);

    purple_debug_misc("bnet", "TELNET S>C: %s\n", text);

    if (strlen(text) > 0) {
        gboolean regex_matched = (0);
        gboolean handled = (0);
        int i = 0;
        while (bnet_regex_store[i].regex != ((void *)0)) {
            GRegex *regex = bnet_regex_store[i].regex;
            GMatchInfo *mi = ((void *)0);

            if (handled) {
                break;
            }

            if (bnet_regex_store[i].event_id == 0) {
                if (g_regex_match(regex, text, 0, &mi)) {
                    bnet_regex_store[i].fn(bnet, regex, text, mi);
                    regex_matched = (!(0));
                }
                if (mi != ((void *)0)) {
                    g_match_info_free(mi);
                    mi = ((void *)0);
                }
                handled = (!(0));
            }

            i++;
        }

        if (!regex_matched) {

        }
    }
    g_free(text);
}

static void
bnet_parse_packet(BnetConnectionData *bnet, const guint8 packet_id, const gchar *packet_start, const guint16 packet_len)
{
    BnetPacket *pkt = ((void *)0);

    purple_debug_misc("bnet", "BNCS S>C 0x%02x: length %d\n", packet_id, packet_len);

    pkt = bnet_packet_refer(packet_start, packet_len);

    switch (packet_id) {
        case BNET_SID_NULL:

            break;
        case BNET_SID_CLIENTID:

            break;
        case BNET_SID_STARTVERSIONING:
            bnet_recv_STARTVERSIONING(bnet, pkt);
            break;
        case BNET_SID_REPORTVERSION:
            bnet_recv_REPORTVERSION(bnet, pkt);
            break;
        case BNET_SID_ENTERCHAT:
            bnet_recv_ENTERCHAT(bnet, pkt);
            break;
        case BNET_SID_GETCHANNELLIST:
            bnet_recv_GETCHANNELLIST(bnet, pkt);
            break;
        case BNET_SID_CHATEVENT:
            bnet_recv_CHATEVENT(bnet, pkt);
            break;
        case BNET_SID_FLOODDETECTED:

            break;
        case BNET_SID_MESSAGEBOX:
            bnet_recv_MESSAGEBOX(bnet, pkt);
            break;
        case BNET_SID_LOGONCHALLENGEEX:
            bnet_recv_LOGONCHALLENGEEX(bnet, pkt);
            break;
        case BNET_SID_PING:
            bnet_recv_PING(bnet, pkt);
            break;
        case BNET_SID_READUSERDATA:
            bnet_recv_READUSERDATA(bnet, pkt);
            break;
        case BNET_SID_LOGONCHALLENGE:
            bnet_recv_LOGONCHALLENGE(bnet, pkt);
            break;
        case BNET_SID_CDKEY:
            bnet_recv_CDKEY(bnet, pkt);
            break;
        case BNET_SID_W3PROFILE:
            bnet_recv_W3PROFILE(bnet, pkt);
            break;
        case BNET_SID_CDKEY2:
            bnet_recv_CDKEY2(bnet, pkt);
            break;
        case BNET_SID_CREATEACCOUNT2:
            bnet_recv_CREATEACCOUNT2(bnet, pkt);
            break;
        case BNET_SID_LOGONREALMEX:
            bnet_recv_LOGONREALMEX(bnet, pkt);
            break;
        case BNET_SID_QUERYREALMS2:
            bnet_recv_QUERYREALMS2(bnet, pkt);
            break;
        case BNET_SID_W3GENERAL:
            bnet_recv_W3GENERAL(bnet, pkt);
            break;
        case BNET_SID_NEWS_INFO:
            bnet_recv_NEWS_INFO(bnet, pkt);
            break;
        case BNET_SID_OPTIONALWORK:
        case BNET_SID_REQUIREDWORK:

            break;
        case BNET_SID_AUTH_INFO:
            bnet_recv_AUTH_INFO(bnet, pkt);
            break;
        case BNET_SID_AUTH_CHECK:
            bnet_recv_AUTH_CHECK(bnet, pkt);
            break;
        case BNET_SID_AUTH_ACCOUNTCREATE:
            bnet_recv_AUTH_ACCOUNTCREATE(bnet, pkt);
            break;
        case BNET_SID_AUTH_ACCOUNTLOGON:
            bnet_recv_AUTH_ACCOUNTLOGON(bnet, pkt);
            break;
        case BNET_SID_AUTH_ACCOUNTLOGONPROOF:
            bnet_recv_AUTH_ACCOUNTLOGONPROOF(bnet, pkt);
            break;
        case BNET_SID_SETEMAIL:
            bnet_recv_SETEMAIL(bnet, pkt);
            break;
        case BNET_SID_LOGONRESPONSE2:
            bnet_recv_LOGONRESPONSE2(bnet, pkt);
            break;
        case BNET_SID_FRIENDSLIST:
            bnet_recv_FRIENDSLIST(bnet, pkt);
            break;
        case BNET_SID_FRIENDSUPDATE:
            bnet_recv_FRIENDSUPDATE(bnet, pkt);
            break;
        case BNET_SID_FRIENDSADD:
            bnet_recv_FRIENDSADD(bnet, pkt);
            break;
        case BNET_SID_FRIENDSREMOVE:
            bnet_recv_FRIENDSREMOVE(bnet, pkt);
            break;
        case BNET_SID_FRIENDSPOSITION:
            bnet_recv_FRIENDSPOSITION(bnet, pkt);
            break;
        case BNET_SID_CLANFINDCANDIDATES:
            bnet_recv_CLANFINDCANDIDATES(bnet, pkt);
            break;
        case BNET_SID_CLANINVITEMULTIPLE:
            bnet_recv_CLANINVITEMULTIPLE(bnet, pkt);
            break;
        case BNET_SID_CLANCREATIONINVITATION:
            bnet_recv_CLANCREATIONINVITATION(bnet, pkt);
            break;
        case BNET_SID_CLANDISBAND:
            bnet_recv_CLANDISBAND(bnet, pkt);
            break;
        case BNET_SID_CLANMAKECHIEFTAIN:
            bnet_recv_CLANMAKECHIEFTAIN(bnet, pkt);
            break;
        case BNET_SID_CLANINFO:
            bnet_recv_CLANINFO(bnet, pkt);
            break;
        case BNET_SID_CLANQUITNOTIFY:
            bnet_recv_CLANQUITNOTIFY(bnet, pkt);
            break;
        case BNET_SID_CLANINVITATION:
            bnet_recv_CLANINVITATION(bnet, pkt);
            break;
        case BNET_SID_CLANREMOVEMEMBER:
            bnet_recv_CLANREMOVEMEMBER(bnet, pkt);
            break;
        case BNET_SID_CLANINVITATIONRESPONSE:
            bnet_recv_CLANINVITATIONRESPONSE(bnet, pkt);
            break;
        case BNET_SID_CLANRANKCHANGE:
            bnet_recv_CLANRANKCHANGE(bnet, pkt);
            break;
        case BNET_SID_CLANMOTD:
            bnet_recv_CLANMOTD(bnet, pkt);
            break;
        case BNET_SID_CLANMEMBERLIST:
            bnet_recv_CLANMEMBERLIST(bnet, pkt);
            break;
        case BNET_SID_CLANMEMBERREMOVED:
            bnet_recv_CLANMEMBERREMOVED(bnet, pkt);
            break;
        case BNET_SID_CLANMEMBERSTATUSCHANGE:
            bnet_recv_CLANMEMBERSTATUSCHANGE(bnet, pkt);
            break;
        case BNET_SID_CLANMEMBERRANKCHANGE:
            bnet_recv_CLANMEMBERRANKCHANGE(bnet, pkt);
            break;
        case BNET_SID_CLANMEMBERINFO:
            bnet_recv_CLANMEMBERINFO(bnet, pkt);
            break;
        default:

            purple_debug_warning("bnet", "Received unhandled packet 0x%02x, length %d\n", packet_id, packet_len);
            break;
    }

    bnet_packet_free(pkt);
}

static void
bnet_request_set_email_null_cb(gpointer data)
{
    BnetConnectionData *bnet;
    PurpleRequestFields *fields;
    GList *group_list; PurpleRequestFieldGroup *group;
    GList *field_list; PurpleRequestField *field;
    gboolean donotaskagain = (0);

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    fields = bnet->bncs.logon.prpl_setemail_fields_handle;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (fields != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "fields != NULL"); return; }; }while (0);
    group_list = g_list_first(purple_request_fields_get_groups(fields));
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group_list != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group_list != NULL"); return; }; }while (0);
    group = group_list->data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group != NULL"); return; }; }while (0);
    field_list = g_list_first(purple_request_field_group_get_fields(group));

    while (field_list != ((void *)0)) {
        field = field_list->data;
        if (field != ((void *)0)) {
            const gchar *name = purple_request_field_get_id(field);
            if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name) && __builtin_constant_p ("donotaskagain") && (__s1_len = strlen (name), __s2_len = strlen ("donotaskagain"), (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("donotaskagain") + 1) - (size_t)(const void *)("donotaskagain") == 1) || __s2_len >= 4)) ? __builtin_strcmp (name, "donotaskagain") : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s1_len = strlen (name), __s1_len < 4) ? (__builtin_constant_p ("donotaskagain") && ((size_t)(const void *)(("donotaskagain") + 1) - (size_t)(const void *)("donotaskagain") == 1) ? __builtin_strcmp (name, "donotaskagain") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("donotaskagain"); register int __result = (((const unsigned char *) (const char *) (name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("donotaskagain") && ((size_t)(const void *)(("donotaskagain") + 1) - (size_t)(const void *)("donotaskagain") == 1) && (__s2_len = strlen ("donotaskagain"), __s2_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (name, "donotaskagain") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("donotaskagain"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("donotaskagain"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("donotaskagain"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("donotaskagain"))[3]); } } __result; }))) : __builtin_strcmp (name, "donotaskagain")))); }) == 0) {
                donotaskagain = purple_request_field_bool_get_value(field);
            }
        }
        field_list = ((field_list) ? (((GList *)(field_list))->next) : ((void *)0));
    }
    if (donotaskagain) {
        bnet_send_SETEMAIL(bnet, "");
    }
}

static void
bnet_request_set_email_cb(gpointer data)
{
    BnetConnectionData *bnet;
    PurpleRequestFields *fields;
    GList *group_list; PurpleRequestFieldGroup *group;
    GList *field_list; PurpleRequestField *field;
    const char *email = ((void *)0);
    const char *email2 = ((void *)0);
    gboolean donotaskagain = (0);

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    fields = bnet->bncs.logon.prpl_setemail_fields_handle;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (fields != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "fields != NULL"); return; }; }while (0);
    group_list = g_list_first(purple_request_fields_get_groups(fields));
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group_list != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group_list != NULL"); return; }; }while (0);
    group = group_list->data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group != NULL"); return; }; }while (0);
    field_list = g_list_first(purple_request_field_group_get_fields(group));

    while (field_list != ((void *)0)) {
        field = field_list->data;
        if (field != ((void *)0)) {
            const gchar *name = purple_request_field_get_id(field);
            if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name) && __builtin_constant_p ("email") && (__s1_len = strlen (name), __s2_len = strlen ("email"), (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("email") + 1) - (size_t)(const void *)("email") == 1) || __s2_len >= 4)) ? __builtin_strcmp (name, "email") : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s1_len = strlen (name), __s1_len < 4) ? (__builtin_constant_p ("email") && ((size_t)(const void *)(("email") + 1) - (size_t)(const void *)("email") == 1) ? __builtin_strcmp (name, "email") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("email"); register int __result = (((const unsigned char *) (const char *) (name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("email") && ((size_t)(const void *)(("email") + 1) - (size_t)(const void *)("email") == 1) && (__s2_len = strlen ("email"), __s2_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (name, "email") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("email"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("email"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("email"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("email"))[3]); } } __result; }))) : __builtin_strcmp (name, "email")))); }) == 0) {
                email = purple_request_field_string_get_value(field);
            } else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name) && __builtin_constant_p ("email2") && (__s1_len = strlen (name), __s2_len = strlen ("email2"), (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("email2") + 1) - (size_t)(const void *)("email2") == 1) || __s2_len >= 4)) ? __builtin_strcmp (name, "email2") : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s1_len = strlen (name), __s1_len < 4) ? (__builtin_constant_p ("email2") && ((size_t)(const void *)(("email2") + 1) - (size_t)(const void *)("email2") == 1) ? __builtin_strcmp (name, "email2") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("email2"); register int __result = (((const unsigned char *) (const char *) (name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("email2") && ((size_t)(const void *)(("email2") + 1) - (size_t)(const void *)("email2") == 1) && (__s2_len = strlen ("email2"), __s2_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (name, "email2") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("email2"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("email2"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("email2"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("email2"))[3]); } } __result; }))) : __builtin_strcmp (name, "email2")))); }) == 0) {
                email2 = purple_request_field_string_get_value(field);
            } else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (name) && __builtin_constant_p ("donotaskagain") && (__s1_len = strlen (name), __s2_len = strlen ("donotaskagain"), (!((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("donotaskagain") + 1) - (size_t)(const void *)("donotaskagain") == 1) || __s2_len >= 4)) ? __builtin_strcmp (name, "donotaskagain") : (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) && (__s1_len = strlen (name), __s1_len < 4) ? (__builtin_constant_p ("donotaskagain") && ((size_t)(const void *)(("donotaskagain") + 1) - (size_t)(const void *)("donotaskagain") == 1) ? __builtin_strcmp (name, "donotaskagain") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("donotaskagain"); register int __result = (((const unsigned char *) (const char *) (name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("donotaskagain") && ((size_t)(const void *)(("donotaskagain") + 1) - (size_t)(const void *)("donotaskagain") == 1) && (__s2_len = strlen ("donotaskagain"), __s2_len < 4) ? (__builtin_constant_p (name) && ((size_t)(const void *)((name) + 1) - (size_t)(const void *)(name) == 1) ? __builtin_strcmp (name, "donotaskagain") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (name); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("donotaskagain"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("donotaskagain"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("donotaskagain"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("donotaskagain"))[3]); } } __result; }))) : __builtin_strcmp (name, "donotaskagain")))); }) == 0) {
                donotaskagain = purple_request_field_bool_get_value(field);
            }
        }
        field_list = ((field_list) ? (((GList *)(field_list))->next) : ((void *)0));
    }
    if (donotaskagain && (email == ((void *)0) || strlen(email) == 0) && (email2 == ((void *)0) || strlen(email2) == 0)) {


        bnet_send_SETEMAIL(bnet, "");
    } else if (email != ((void *)0) && email2 != ((void *)0) && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (email) && __builtin_constant_p (email2) && (__s1_len = strlen (email), __s2_len = strlen (email2), (!((size_t)(const void *)((email) + 1) - (size_t)(const void *)(email) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((email2) + 1) - (size_t)(const void *)(email2) == 1) || __s2_len >= 4)) ? __builtin_strcmp (email, email2) : (__builtin_constant_p (email) && ((size_t)(const void *)((email) + 1) - (size_t)(const void *)(email) == 1) && (__s1_len = strlen (email), __s1_len < 4) ? (__builtin_constant_p (email2) && ((size_t)(const void *)((email2) + 1) - (size_t)(const void *)(email2) == 1) ? __builtin_strcmp (email, email2) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (email2); register int __result = (((const unsigned char *) (const char *) (email))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (email))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (email))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (email))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (email2) && ((size_t)(const void *)((email2) + 1) - (size_t)(const void *)(email2) == 1) && (__s2_len = strlen (email2), __s2_len < 4) ? (__builtin_constant_p (email) && ((size_t)(const void *)((email) + 1) - (size_t)(const void *)(email) == 1) ? __builtin_strcmp (email, email2) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (email); register int __result = __s1[0] - ((const unsigned char *) (const char *) (email2))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (email2))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (email2))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (email2))[3]); } } __result; }))) : __builtin_strcmp (email, email2)))); }) == 0 && strlen(email) > 0) {


        bnet_send_SETEMAIL(bnet, email);
    } else {


        bnet_request_set_email(bnet, (!(0)));
    }
}

static void
bnet_request_set_email(BnetConnectionData *bnet, gboolean nomatch_error)
{
    gchar *group_text = g_strdup_printf("Bind an e-mail address to %s on %s%s", bnet->bncs.logon.username, bnet->bncs.conn.server, nomatch_error ? " (addresses did not match!)" : "");
    PurpleRequestField *field;
    PurpleRequestFields *fields = purple_request_fields_new();
    PurpleRequestFieldGroup *group = purple_request_field_group_new("If you wish to bind an e-mail address, do so here.");

    field = purple_request_field_string_new("email", "e-mail address", "", (0));
    purple_request_field_group_add_field(group, field);
    purple_request_field_string_set_editable(field, (!(0)));
    purple_request_field_set_type_hint(field, "email");

    field = purple_request_field_string_new("email2", "Retype e-mail address", "", (0));
    purple_request_field_group_add_field(group, field);
    purple_request_field_string_set_editable(field, (!(0)));
    purple_request_field_set_required(field, (0));

    field = purple_request_field_bool_new("donotaskagain", "Do not ask again for this account. \n"
            "This will bind an \"empty\" address to your account. \n"
            "You will not be able to recover this account's password.", (0));
    purple_request_field_group_add_field(group, field);

    purple_request_fields_add_group(fields, group);

    bnet->bncs.logon.prpl_setemail_fields_handle = fields;

    purple_debug_warning("bnet", "Battle.net wants to register an email address with this account.\n");
    purple_request_fields(bnet->account->gc, "Bind an e-mail address",
            group_text,
            "This address can be used later to recover your account. \n"
            "When telling them to reset your password, you must use this address again. \n"
            "You may safely ignore this request.",
            fields,
            "_Register", (GCallback)bnet_request_set_email_cb,
            "_Ignore", (GCallback)bnet_request_set_email_null_cb,
            bnet->account,
            ((void *)0), ((void *)0),
            bnet);
    g_free(group_text);
}

static void
bnet_clan_invite_accept_cb(void *data, int act_index)
{
    BnetClanInvitationCallbackData *callback_data = data;
    BnetConnectionData *bnet = callback_data->bnet;
    BnetPacketID packet_id = callback_data->packet_id;
    gint32 cookie = callback_data->cookie;
    BnetClanTag clan_tag = callback_data->clan_tag;
    gchar *inviter = callback_data->inviter;
    gchar *clan_name = callback_data->clan_name;

    g_free(callback_data);

    if (packet_id == BNET_SID_CLANCREATIONINVITATION) {
        bnet_send_CLANCREATIONINVITATION(bnet, cookie, clan_tag, inviter, (!(0)));
    } else if (packet_id == BNET_SID_CLANINVITATIONRESPONSE) {
        bnet_send_CLANINVITATIONRESPONSE(bnet, cookie, clan_tag, inviter, (!(0)));
    }

    g_free(inviter);
    g_free(clan_name);
}

static void
bnet_clan_invite_decline_cb(void *data, int act_index)
{
    BnetClanInvitationCallbackData *callback_data = data;
    BnetConnectionData *bnet = callback_data->bnet;
    BnetPacketID packet_id = callback_data->packet_id;
    gint32 cookie = callback_data->cookie;
    BnetClanTag clan_tag = callback_data->clan_tag;
    gchar *inviter = callback_data->inviter;
    gchar *clan_name = callback_data->clan_name;

    g_free(callback_data);

    if (packet_id == BNET_SID_CLANCREATIONINVITATION) {
        bnet_send_CLANCREATIONINVITATION(bnet, cookie, clan_tag, inviter, (0));
    } else if (packet_id == BNET_SID_CLANINVITATIONRESPONSE) {
        bnet_send_CLANINVITATIONRESPONSE(bnet, cookie, clan_tag, inviter, (0));
    }

    g_free(inviter);
    g_free(clan_name);
}
# 6557 "src/bnet.c"
static gint
bnet_channel_user_compare(gconstpointer a, gconstpointer b)
{
    const BnetChannelUser *bcu = a;
    const char *usr = b;
    const char *a_n = ((void *)0);
    const char *b_n = ((void *)0);
    char *a_nc;
    int cmp = 0;
    if (a == ((void *)0) || b == ((void *)0)) {
        return 1;
    }
    if (bcu->username == ((void *)0)) {
        return 1;
    }
    a_n = bnet_normalize(((void *)0), bcu->username);
    a_nc = g_strdup(a_n);
    b_n = bnet_normalize(((void *)0), usr);
    cmp = __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (a_nc) && __builtin_constant_p (b_n) && (__s1_len = strlen (a_nc), __s2_len = strlen (b_n), (!((size_t)(const void *)((a_nc) + 1) - (size_t)(const void *)(a_nc) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((b_n) + 1) - (size_t)(const void *)(b_n) == 1) || __s2_len >= 4)) ? __builtin_strcmp (a_nc, b_n) : (__builtin_constant_p (a_nc) && ((size_t)(const void *)((a_nc) + 1) - (size_t)(const void *)(a_nc) == 1) && (__s1_len = strlen (a_nc), __s1_len < 4) ? (__builtin_constant_p (b_n) && ((size_t)(const void *)((b_n) + 1) - (size_t)(const void *)(b_n) == 1) ? __builtin_strcmp (a_nc, b_n) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (b_n); register int __result = (((const unsigned char *) (const char *) (a_nc))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (a_nc))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (a_nc))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (a_nc))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (b_n) && ((size_t)(const void *)((b_n) + 1) - (size_t)(const void *)(b_n) == 1) && (__s2_len = strlen (b_n), __s2_len < 4) ? (__builtin_constant_p (a_nc) && ((size_t)(const void *)((a_nc) + 1) - (size_t)(const void *)(a_nc) == 1) ? __builtin_strcmp (a_nc, b_n) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (a_nc); register int __result = __s1[0] - ((const unsigned char *) (const char *) (b_n))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (b_n))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (b_n))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (b_n))[3]); } } __result; }))) : __builtin_strcmp (a_nc, b_n)))); });
    g_free(a_nc);
    return cmp;
}

static gint
bnet_friend_user_compare(gconstpointer a, gconstpointer b)
{
    const BnetFriendInfo *bfi = a;
    const char *usr = b;
    const char *a_n = ((void *)0);
    const char *b_n = ((void *)0);
    char *a_nc;
    int cmp = 0;
    if (a == ((void *)0) || b == ((void *)0)) {
        return 1;
    }
    if (bfi->account == ((void *)0)) {
        return 1;
    }
    a_n = bnet_normalize(((void *)0), bfi->account);
    a_nc = g_strdup(a_n);
    b_n = bnet_normalize(((void *)0), usr);
    cmp = __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (a_nc) && __builtin_constant_p (b_n) && (__s1_len = strlen (a_nc), __s2_len = strlen (b_n), (!((size_t)(const void *)((a_nc) + 1) - (size_t)(const void *)(a_nc) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((b_n) + 1) - (size_t)(const void *)(b_n) == 1) || __s2_len >= 4)) ? __builtin_strcmp (a_nc, b_n) : (__builtin_constant_p (a_nc) && ((size_t)(const void *)((a_nc) + 1) - (size_t)(const void *)(a_nc) == 1) && (__s1_len = strlen (a_nc), __s1_len < 4) ? (__builtin_constant_p (b_n) && ((size_t)(const void *)((b_n) + 1) - (size_t)(const void *)(b_n) == 1) ? __builtin_strcmp (a_nc, b_n) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (b_n); register int __result = (((const unsigned char *) (const char *) (a_nc))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (a_nc))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (a_nc))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (a_nc))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (b_n) && ((size_t)(const void *)((b_n) + 1) - (size_t)(const void *)(b_n) == 1) && (__s2_len = strlen (b_n), __s2_len < 4) ? (__builtin_constant_p (a_nc) && ((size_t)(const void *)((a_nc) + 1) - (size_t)(const void *)(a_nc) == 1) ? __builtin_strcmp (a_nc, b_n) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (a_nc); register int __result = __s1[0] - ((const unsigned char *) (const char *) (b_n))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (b_n))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (b_n))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (b_n))[3]); } } __result; }))) : __builtin_strcmp (a_nc, b_n)))); });
    g_free(a_nc);
    return cmp;
}

static PurpleCmdRet
bnet_handle_cmd(PurpleConversation *conv, const gchar *cmdword,
        gchar **args, gchar **error, void *data)
{
    struct BnetCommand *c = data;
    PurpleConnection *gc;
    BnetConnectionData *bnet;
    char *cmd;
    char *s_args;

    gc = purple_conversation_get_gc(conv);
    if (!gc)
        return PURPLE_CMD_RET_FAILED;

    bnet = gc->proto_data;

    if (!bnet)
        return PURPLE_CMD_RET_FAILED;

    if (!c)
        return PURPLE_CMD_RET_FAILED;

    if (!args) {
        s_args = g_malloc0(1);
    } else {
        s_args = g_strjoinv(" ", args);

        if (strlen(s_args) == 0) {
            char *tmp = g_malloc0(1);
            g_free(s_args);
            s_args = tmp;
        } else {
            char *tmp;
            if ((c->bnetflags & BNET_CMD_FLAG_STAROND2) == BNET_CMD_FLAG_STAROND2)
                tmp = g_strdup_printf(" %s%s", bnet->bncs.chat_env.d2_star, s_args);
            else
                tmp = g_strdup_printf(" %s", s_args);
            g_free(s_args);
            s_args = tmp;
        }
    }

    if (c->id == BNET_CMD_WHISPER && strlen(s_args) > 1 &&
            g_strstr_len(s_args + 1, strlen(s_args - 1) - 1, " ") != ((void *)0)) {

        char *who = g_strdup(s_args + 1);
        const char *norm = ((void *)0);
        char *whatloc = g_strstr_len(s_args + 1, strlen(s_args - 1) - 1, " ");
        char *what = g_strdup(whatloc + 1);
        PurpleConvIm *im = ((void *)0);
        PurpleConversation *conv = ((void *)0);

        *(who + (whatloc - s_args - 1)) = '\0';
        norm = bnet_d2_normalize(bnet->account, who);

        conv = purple_conversation_new(PURPLE_CONV_TYPE_IM, bnet->account, norm);
        im = (purple_conversation_get_im_data(conv));
        purple_conversation_present(conv);

        purple_conv_im_send(im, what);
        g_free(who);
        g_free(what);
        g_free(s_args);
        return PURPLE_CMD_RET_OK;
    }

    cmd = g_strdup_printf("/%s%s", cmdword, s_args);
    if ((c->bnetflags & BNET_CMD_FLAG_INFORESPONSE) == BNET_CMD_FLAG_INFORESPONSE) {
        bnet->bncs.chat_env.prpl_last_cmd_conv_handle = conv;
    } else {
        bnet->bncs.chat_env.prpl_last_cmd_conv_handle = ((void *)0);
    }
    if (purple_conversation_get_type(conv) == PURPLE_CONV_TYPE_IM &&
            (c->bnetflags & BNET_CMD_FLAG_WHISPERPRPLCONTINUE) == BNET_CMD_FLAG_WHISPERPRPLCONTINUE) {
        PurpleConvIm *im = purple_conversation_get_im_data(conv);
        if (im) {
            purple_conv_im_send(im, cmd);
        } else {
            if (bnet_is_telnet(bnet)) {
                bnet_send_telnet_line(bnet, cmd);
            } else {
                bnet_send_CHATCOMMAND(bnet, cmd);
            }
        }
    } else {
        if (bnet_is_telnet(bnet)) {
            bnet_send_telnet_line(bnet, cmd);
        } else {
            bnet_send_CHATCOMMAND(bnet, cmd);
        }
    }

    g_free(cmd);
    g_free(s_args);

    if (c->bnetflags & BNET_CMD_FLAG_PRPLCONTINUE) {
        return PURPLE_CMD_RET_CONTINUE;
    }

    return PURPLE_CMD_RET_OK;
}

static double
bnet_get_tz_bias(void)
{
    time_t t_local, t_utc;
    struct tm *tm_utc = ((void *)0);

    t_local = time(((void *)0));
    tm_utc = gmtime(&t_local);
    t_utc = mktime(tm_utc);

    return difftime(t_utc, t_local);
}

static char *
bnet_format_time(guint64 unixtime)
{
    time_t ut = 0;
    struct tm *t = ((void *)0);

    if (unixtime == 0) {
        return g_strdup("never");
    }

    ut = unixtime;
    t = localtime(&ut);

    return g_strdup(purple_date_format_full(t));
}



static char *
bnet_format_filetime_string(char *ftime_str)
{
    union {
        struct {
            guint32 dwLowDateTime;
            guint32 dwHighDateTime;
        } as_ft;
        guint64 as_int64;
    } data;
    char *space_loc;

    if (strlen(ftime_str) == 0) {
        return g_strdup("never");
    }

    data.as_ft.dwHighDateTime = (guint32)g_ascii_strtoull(ftime_str, &space_loc, 10);
    data.as_ft.dwLowDateTime = 0;
    if (space_loc != ((void *)0)) {
        data.as_ft.dwLowDateTime = (guint32)g_ascii_strtoull(space_loc + 1, ((void *)0), 10);
    }

    return bnet_format_filetime(data.as_int64);
}

static char *
bnet_format_filetime(guint64 ft)
{
    guint64 ut = (ft / 10000000LL - 11644473600LL);

    return bnet_format_time(ut);
}

static guint64
bnet_get_filetime(time_t time)
{
    guint64 ft;
    guint64 ut;
    ut = time;
    ft = (ut + 11644473600LL) * 10000000LL;

    return ft;
}

static char *
bnet_format_strsec(char *secs_str)
{
    guint32 total_secs = strtol(secs_str, ((void *)0), 10);

    return purple_str_seconds_to_string(total_secs);
}

static void
bnet_find_detached_buddies(BnetConnectionData *bnet)
{
    GSList *all_buddies;
    GSList *el;
    PurpleBuddy *buddy;
    BnetFriendInfo *bfi;

    all_buddies = purple_find_buddies(bnet->account, ((void *)0));
    el = all_buddies;
    while (el != ((void *)0)) {
        buddy = el->data;
        bfi = purple_buddy_get_protocol_data(buddy);
        if (bfi == ((void *)0)) {
            purple_prpl_got_user_status(bnet->account, purple_buddy_get_name(buddy),
                    "Offline", ((void *)0));
        }
        el = ((el) ? (((GSList *)(el))->next) : ((void *)0));
    }
    g_slist_free(all_buddies);
}

static void
bnet_do_whois(const BnetConnectionData *bnet, const char *who)
{
    gchar *cmd;

    cmd = g_strdup_printf("/whois %s%s", bnet->bncs.chat_env.d2_star, who);
    if (bnet_is_telnet(bnet)) {
        bnet_send_telnet_line(bnet, cmd);
    } else {
        bnet_send_CHATCOMMAND(bnet, cmd);
    }
    g_free(cmd);
}

static void
bnet_friend_update(const BnetConnectionData *bnet, int index,
        BnetFriendInfo *bfi, BnetFriendStatus status,
        BnetFriendLocation location, BnetProductID product_id,
        const gchar *location_name)
{
    PurpleBuddy *buddy = ((void *)0);
    BnetFriendStatus whoising = 0;

    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bfi != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bfi != NULL"); return; }; }while (0);

    buddy = purple_find_buddy(bnet->account, bfi->account);

    if (!buddy) {

        PurpleGroup *grp = purple_group_new(purple_account_get_string(bnet->account, "grpfriends", "Friends"));

        buddy = purple_buddy_new(bnet->account, bfi->account, bfi->account);

        purple_blist_add_buddy(buddy, ((void *)0), grp, ((void *)0));
    }

    purple_buddy_set_protocol_data(buddy, bfi);

    bfi->buddy = buddy;

    if (bfi->status == status && bfi->location == location &&
            bfi->product == product_id && __extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (bfi->location_name) && __builtin_constant_p (location_name) && (__s1_len = strlen (bfi->location_name), __s2_len = strlen (location_name), (!((size_t)(const void *)((bfi->location_name) + 1) - (size_t)(const void *)(bfi->location_name) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((location_name) + 1) - (size_t)(const void *)(location_name) == 1) || __s2_len >= 4)) ? __builtin_strcmp (bfi->location_name, location_name) : (__builtin_constant_p (bfi->location_name) && ((size_t)(const void *)((bfi->location_name) + 1) - (size_t)(const void *)(bfi->location_name) == 1) && (__s1_len = strlen (bfi->location_name), __s1_len < 4) ? (__builtin_constant_p (location_name) && ((size_t)(const void *)((location_name) + 1) - (size_t)(const void *)(location_name) == 1) ? __builtin_strcmp (bfi->location_name, location_name) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (location_name); register int __result = (((const unsigned char *) (const char *) (bfi->location_name))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (bfi->location_name))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (bfi->location_name))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (bfi->location_name))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (location_name) && ((size_t)(const void *)((location_name) + 1) - (size_t)(const void *)(location_name) == 1) && (__s2_len = strlen (location_name), __s2_len < 4) ? (__builtin_constant_p (bfi->location_name) && ((size_t)(const void *)((bfi->location_name) + 1) - (size_t)(const void *)(bfi->location_name) == 1) ? __builtin_strcmp (bfi->location_name, location_name) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (bfi->location_name); register int __result = __s1[0] - ((const unsigned char *) (const char *) (location_name))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (location_name))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (location_name))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (location_name))[3]); } } __result; }))) : __builtin_strcmp (bfi->location_name, location_name)))); }) == 0) {


        return;
    } else {

        bfi->status = status;
        bfi->location = location;
        bfi->product = product_id;
        g_free(bfi->location_name);
        bfi->location_name = g_strdup(location_name);
    }

    purple_debug_info("bnet", "purple_prpl_got_user_status for %s\n", bfi->account);
    if (bfi->location == BNET_FRIEND_LOCATION_OFFLINE) {
        purple_prpl_got_user_status(bnet->account, bfi->account,
                "Offline", ((void *)0));
    } else {
        purple_prpl_got_user_status(bnet->account, bfi->account,
                "Online", ((void *)0));

        if (bfi->status & BNET_FRIEND_STATUS_AWAY) {
            purple_prpl_got_user_status(bnet->account, bfi->account,
                    "Away", ((void *)0));

            whoising |= BNET_FRIEND_STATUS_AWAY;
        } else {




        }

        if (bfi->status & BNET_FRIEND_STATUS_DND) {
            purple_prpl_got_user_status(bnet->account, bfi->account,
                    "Do not disturb", ((void *)0));

            whoising |= BNET_FRIEND_STATUS_DND;
        } else {


        }
    }

    if (whoising) {

        bfi->automated_lookup = whoising;
        bnet_do_whois(bnet, bfi->account);
    }
}

static void
bnet_close(PurpleConnection *gc)
{
    int i;
    BnetConnectionData *bnet = gc->proto_data;

    if (bnet != ((void *)0)) {
        bnet->bncs.chat_env.first_join = (0);
        bnet->bncs.chat_env.is_online = (0);
        bnet->bncs.chat_env.sent_enter_channel = (0);
        if (bnet->bncs.chat_env.updatelist_timer_handle != 0) {
            purple_timeout_remove(bnet->bncs.chat_env.updatelist_timer_handle);
            bnet->bncs.chat_env.updatelist_timer_handle = 0;
        }
        if (bnet->bncs.logon.lockout_timer_handle != 0) {
            purple_timeout_remove(bnet->bncs.logon.lockout_timer_handle);
            bnet->bncs.logon.lockout_timer_handle = 0;
        }
        if (bnet->bncs.channel.join_timer_handle != 0) {
            purple_timeout_remove(bnet->bncs.channel.join_timer_handle);
            bnet->bncs.channel.join_timer_handle = 0;
        }
        if (bnet->bnls.conn.server != ((void *)0)) {
            g_free(bnet->bnls.conn.server);
            bnet->bnls.conn.server = ((void *)0);
        }
        if (bnet->bnls.conn.fd != 0) {
            bnet_input_free(&bnet->bnls.conn);
        }
        if (bnet->bncs.conn.fd != 0) {
            bnet_input_free(&bnet->bncs.conn);
        }
        if (bnet->d2mcp.conn.fd != 0) {
            bnet_input_free(&bnet->d2mcp.conn);
        }
        if (bnet->bncs.logon.username != ((void *)0)) {
            g_free(bnet->bncs.logon.username);
            bnet->bncs.logon.username = ((void *)0);
        }
        if (bnet->bncs.versioning.key_owner != ((void *)0)) {
            g_free(bnet->bncs.versioning.key_owner);
            bnet->bncs.versioning.key_owner = ((void *)0);
        }
        if (bnet->bncs.chat_env.stats != ((void *)0)) {
            g_free(bnet->bncs.chat_env.stats);
            bnet->bncs.chat_env.stats = ((void *)0);
        }
        if (bnet->bncs.chat_env.unique_name != ((void *)0)) {
            g_free(bnet->bncs.chat_env.unique_name);
            bnet->bncs.chat_env.unique_name = ((void *)0);
        }
        if (bnet_clan_in_clan(bnet)) {
            if (bnet->bncs.w3_clan.my_clanname != ((void *)0)) {
                g_free(bnet->bncs.w3_clan.my_clanname);
                bnet->bncs.w3_clan.my_clanname = ((void *)0);
            }
            if (bnet->bncs.w3_clan.my_clanmembers != ((void *)0)) {
                _g_list_free_full(bnet->bncs.w3_clan.my_clanmembers, (GDestroyNotify)bnet_clan_member_free);
                bnet->bncs.w3_clan.my_clanmembers = ((void *)0);
            }
        }
        if (bnet->bncs.chat_env.packet_cookie_table != ((void *)0)) {
            g_hash_table_destroy(bnet->bncs.chat_env.packet_cookie_table);
            bnet->bncs.chat_env.packet_cookie_table = ((void *)0);
        }
        if (bnet->bncs.chat_env.channel_list != ((void *)0)) {
            _g_list_free_full(bnet->bncs.chat_env.channel_list, g_free);
            bnet->bncs.chat_env.channel_list = ((void *)0);
        }
        if (bnet->bncs.channel.name != ((void *)0)) {
            g_free(bnet->bncs.channel.name);
            bnet->bncs.channel.name = ((void *)0);
        }
        if (bnet->bncs.channel.user_list != ((void *)0)) {
            _g_list_free_full(bnet->bncs.channel.user_list, (GDestroyNotify)bnet_channel_user_free);
            bnet->bncs.channel.user_list = ((void *)0);
        }
        if (bnet->bncs.friends.list != ((void *)0)) {
            _g_list_free_full(bnet->bncs.friends.list, (GDestroyNotify)bnet_friend_info_free);
            bnet->bncs.friends.list = ((void *)0);
        }
        if (bnet->bncs.news.item_list != ((void *)0)) {
            _g_list_free_full(bnet->bncs.news.item_list, (GDestroyNotify)bnet_news_item_free);
            bnet->bncs.news.item_list = ((void *)0);
        }
        for (i = 0; i < 6; i++) {
            bnet_motd_free(bnet, i);
        }
        if (bnet->bncs.status.away_msg != ((void *)0)) {
            g_free(bnet->bncs.status.away_msg);
            bnet->bncs.status.away_msg = ((void *)0);
        }
        if (bnet->bncs.status.dnd_msg != ((void *)0)) {
            g_free(bnet->bncs.status.dnd_msg);
            bnet->bncs.status.dnd_msg = ((void *)0);
        }
        if (bnet->bncs.conn.server != ((void *)0)) {
            g_free(bnet->bncs.conn.server);
            bnet->bncs.conn.server = ((void *)0);
        }
        if (bnet->bncs.logon.auth_ctx != ((void *)0)) {
            srp_free(bnet->bncs.logon.auth_ctx);
            bnet->bncs.logon.auth_ctx = ((void *)0);
        }
        if (bnet->bncs.whisper.last_sent_to != ((void *)0)) {
            g_free(bnet->bncs.whisper.last_sent_to);
            bnet->bncs.whisper.last_sent_to = ((void *)0);
        }
        if (bnet->bncs.channel.name_pending != ((void *)0)) {
            g_free(bnet->bncs.channel.name_pending);
            bnet->bncs.channel.name_pending = ((void *)0);
        }
        bnet_lookup_info_close(bnet);
        g_free(bnet);
        bnet = ((void *)0);
    }
}




static int
bnet_send_raw(PurpleConnection *gc, const char *buf, int len)
{
    BnetConnectionData *bnet = gc->proto_data;
    char *mybuf = g_strdup(buf);
    int ret = -1;

    char *msg_s = ((void *)0);
    char *msg_locale = ((void *)0);

    if (len < strlen(mybuf)) {
        mybuf[len] = '\0';
    }

    msg_s = purple_markup_strip_html(mybuf);
    msg_locale = bnet_utf8_to_iso88591(msg_s);

    if (bnet_is_telnet(bnet)) {
        ret = bnet_send_telnet_line(bnet, msg_locale);
    } else {
        ret = bnet_send_CHATCOMMAND(bnet, msg_locale);
    }
    g_free(msg_locale);
    g_free(msg_s);
    g_free(mybuf);

    return ret;
}







static int
bnet_send_whisper(PurpleConnection *gc, const char *who,
        const char *message, PurpleMessageFlags flags)
{
    BnetConnectionData *bnet = gc->proto_data;
    char *msg_nohtml;
    char *cmd;
    int msg_len;

    if (!bnet->bncs.chat_env.is_online) {
        return -107;
    }

    if (__extension__ ({ char __a0, __a1, __a2; (__builtin_constant_p ("\t\v\r\n") && ((size_t)(const void *)(("\t\v\r\n") + 1) - (size_t)(const void *)("\t\v\r\n") == 1) ? ((__builtin_constant_p (message) && ((size_t)(const void *)((message) + 1) - (size_t)(const void *)(message) == 1)) ? __builtin_strpbrk (message, "\t\v\r\n") : ((__a0 = ((const char *) ("\t\v\r\n"))[0], __a0 == '\0') ? ((void) (message), (char *) ((void *)0)) : ((__a1 = ((const char *) ("\t\v\r\n"))[1], __a1 == '\0') ? __builtin_strchr (message, __a0) : ((__a2 = ((const char *) ("\t\v\r\n"))[2], __a2 == '\0') ? __strpbrk_c2 (message, __a0, __a1) : (((const char *) ("\t\v\r\n"))[3] == '\0' ? __strpbrk_c3 (message, __a0, __a1, __a2) : __builtin_strpbrk (message, "\t\v\r\n")))))) : __builtin_strpbrk (message, "\t\v\r\n")); }) != ((void *)0)) {
        return -0x0100;
    }

    msg_nohtml = purple_markup_strip_html(message);
    if (strlen(msg_nohtml) > 225) {
        return -7;
    }

    cmd = g_strdup_printf("/w %s%s %s",
            bnet->bncs.chat_env.d2_star, who, msg_nohtml);
    if (bnet_is_telnet(bnet)) {
        bnet_send_telnet_line(bnet, cmd);
    } else {
        bnet_send_CHATCOMMAND(bnet, cmd);
    }
    g_free(cmd);

    if (bnet->bncs.whisper.last_sent_to != ((void *)0)) g_free(bnet->bncs.whisper.last_sent_to);
    bnet->bncs.whisper.last_sent_to = g_strdup(who);
    bnet->bncs.whisper.awaiting_confirm = (!(0));

    msg_len = strlen(msg_nohtml);

    g_free(msg_nohtml);

    return msg_len;
}





static void
bnet_lookup_info(PurpleConnection *gc, const char *who)
{
    BnetConnectionData *bnet = gc->proto_data;
    const char *norm = bnet_normalize(bnet->account, who);

    if (bnet->bncs.lookup_info.name != ((void *)0)) {
        g_free(bnet->bncs.lookup_info.name);
    }
    if (bnet->bncs.lookup_info.prpl_notify_handle != ((void *)0)) {
        purple_notify_user_info_destroy(bnet->bncs.lookup_info.prpl_notify_handle);
    }

    bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
    bnet->bncs.lookup_info.name = g_strdup(norm);
    bnet->bncs.lookup_info.flags = BNET_LOOKUP_INFO_FIRST_SECTION;
    bnet->bncs.lookup_info.w3_tag = (BnetClanTag)0;



    bnet_lookup_info_cached_channel(bnet);


    bnet_lookup_info_cached_friends(bnet);



    if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FOUND_LOCPROD)) {
        bnet_lookup_info_whois(bnet);
    }


    if (bnet_is_w3(bnet)) {

        bnet_lookup_info_cached_clan(bnet);



        if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FOUND_W3_CLAN)) {

            bnet_lookup_info_w3_user_profile(bnet);
# 7155 "src/bnet.c"
        }


        else if (bnet->bncs.lookup_info.w3_tag != (BnetClanTag)0) {

            bnet_lookup_info_user_data(bnet);

            bnet_lookup_info_w3_user_stats(bnet);

            bnet_lookup_info_w3_clan_stats(bnet);

            bnet_lookup_info_w3_clan_mi(bnet);
        }

        else {

            bnet_lookup_info_user_data(bnet);

            bnet_lookup_info_w3_user_stats(bnet);
        }
    } else if (!bnet_is_telnet(bnet)) {

        bnet_lookup_info_user_data(bnet);
    }

    if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_AWAIT_MASK)) {
        purple_notify_userinfo(bnet->account->gc, bnet->bncs.lookup_info.name,
                bnet->bncs.lookup_info.prpl_notify_handle, bnet_lookup_info_close, bnet);
    }
}

static void
bnet_lookup_info_close(gpointer user_data)
{
    BnetConnectionData *bnet = (BnetConnectionData *)user_data;
    if (bnet->bncs.lookup_info.name != ((void *)0)) {
        g_free(bnet->bncs.lookup_info.name);
        bnet->bncs.lookup_info.name = ((void *)0);
    }
    if (bnet->bncs.lookup_info.prpl_notify_handle != ((void *)0)) {
        purple_notify_user_info_destroy(bnet->bncs.lookup_info.prpl_notify_handle);
        bnet->bncs.lookup_info.prpl_notify_handle = ((void *)0);
    }
    purple_debug_info("bnet", "Lookup closed by user\n");
    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_CANCELLED;
}

static gboolean
bnet_lookup_info_cached_channel(BnetConnectionData *bnet)
{
    GList *li = g_list_find_custom(bnet->bncs.channel.user_list, bnet->bncs.lookup_info.name, bnet_channel_user_compare);
    BnetChannelUser *bcu;
    char *s_ping;
    char *s_caps = g_malloc0(1);
    BnetProductID product_id;
    char *product;
    char *location_string;


    char *start; char *loc;
    char *key; char *value;

    char *s_clan;

    if (li == ((void *)0)) {

        return (0);
    }

    purple_debug_info("bnet", "Lookup local found: CHANNEL_LIST(%s)\n", bnet->bncs.lookup_info.name);

    bcu = li->data;

    s_ping = g_strdup_printf("%dms", bcu->ping);

    if (bcu->flags & BNET_USER_FLAG_BLIZZREP) {
        char *tmp = g_strdup("Blizzard Representative");
        g_free(s_caps);
        s_caps = tmp;
    }

    if (bcu->flags & BNET_USER_FLAG_OP) {
        if (strlen(s_caps)) {
            char *tmp = g_strdup_printf("%s, Channel Operator", s_caps);
            g_free(s_caps);
            s_caps = tmp;
        } else {
            char *tmp = g_strdup("Channel Operator");
            g_free(s_caps);
            s_caps = tmp;
        }
    }

    if (bcu->flags & BNET_USER_FLAG_BNETADMIN) {
        if (strlen(s_caps)) {
            char *tmp = g_strdup_printf("%s, Battle.net Administrator", s_caps);
            g_free(s_caps);
            s_caps = tmp;
        } else {
            char *tmp = g_strdup("Battle.net Administrator");
            g_free(s_caps);
            s_caps = tmp;
        }
    }

    if (bcu->flags & BNET_USER_FLAG_NOUDP) {
        if (strlen(s_caps)) {
            char *tmp = g_strdup_printf("%s, No UDP Support", s_caps);
            g_free(s_caps);
            s_caps = tmp;
        } else {
            char *tmp = g_strdup("No UDP Support");
            g_free(s_caps);
            s_caps = tmp;
        }
    }

    if (bcu->flags & BNET_USER_FLAG_SQUELCH) {
        if (strlen(s_caps)) {
            char *tmp = g_strdup_printf("%s, Squelched", s_caps);
            g_free(s_caps);
            s_caps = tmp;
        } else {
            char *tmp = g_strdup("Squelched");
            g_free(s_caps);
            s_caps = tmp;
        }
    }

    if (strlen(s_caps) == 0) {
        char *tmp = g_strdup("Normal");
        g_free(s_caps);
        s_caps = tmp;
    }

    product_id = bnet_string_to_tag(bcu->stats_data);
    product = bnet_get_product_name(product_id);

    location_string = bnet_get_location_text(BNET_FRIEND_LOCATION_CHANNEL, bnet->bncs.channel.name);

    if (!bnet->bncs.lookup_info.prpl_notify_handle) {
        bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
    } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
        purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
    }
    bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;

    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Current location", location_string);
    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Current product", product);
    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Ping at logon", s_ping);
    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Channel capabilities", s_caps);

    start = g_strdup(bcu->stats_data + 4);
    loc = start;
    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_W3_CLAN;
    switch (product_id) {
        case (0x53544152):
        case (0x53415850):
        case (0x53534852):
        case (0x4a535452):
        case (0x5732424e):
            {
                guint32 l_rating, l_rank, wins, spawn, l_hirating;

                loc++;
                l_rating = g_ascii_strtod(loc, &loc);
                loc++;
                l_rank = g_ascii_strtod(loc, &loc);
                loc++;
                wins = g_ascii_strtod(loc, &loc);
                loc++;
                spawn = g_ascii_strtod(loc, &loc);
                loc++;
                g_ascii_strtod(loc, &loc);
                loc++;
                l_hirating = g_ascii_strtod(loc, &loc);
                loc++;
                g_ascii_strtod(loc, &loc);
                loc++;
                g_ascii_strtod(loc, &loc);
                loc++;

                if (l_rating || l_rank || l_hirating) {
                    key = g_strdup_printf("%s ladder rating", product);
                    value = g_strdup_printf("%d (high: %d)", l_rating, l_hirating);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, key, value);
                    g_free(key); g_free(value);

                    key = g_strdup_printf("%s ladder rank", product);
                    value = g_strdup_printf("%d", l_rank);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, key, value);
                    g_free(key); g_free(value);
                }
                if (wins) {
                    key = g_strdup_printf("%s wins", product);
                    value = g_strdup_printf("%d", wins);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, key, value);
                    g_free(key); g_free(value);
                }
                if (spawn) {
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Spawned client", "Yes");
                }
                break;
            }
        case (0x4452544c):
        case (0x44534852):
            {
                char *tmp;
                guint32 char_lvl = 0, char_class = 0, char_dots = 0;
                guint32 char_str = 0, char_mag = 0, char_dex = 0, char_vit = 0;
                guint32 char_gold = 0, spawn = 0;

                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_lvl = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_class = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_dots = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_str = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_mag = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_dex = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_vit = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    char_gold = g_ascii_strtod(loc, &loc);
                if (strlen(loc))
                    loc++;
                if (strlen(loc))
                    spawn = g_ascii_strtod(loc, ((void *)0));

                if (char_lvl) {
                    tmp = g_strdup_printf("%d", char_lvl);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character level", tmp);
                    g_free(tmp);
                }
                if ((!(0))) {
                    char *char_type_name;
                    switch (char_class) {
                        default: char_type_name = "Unknown"; break;
                        case 0: char_type_name = "Warrior"; break;
                        case 1: char_type_name = "Sorcerer"; break;
                        case 2: char_type_name = "Rogue"; break;
                    }
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character class", char_type_name);
                }
                if ((!(0))) {
                    char *char_diff_text;
                    switch (char_dots) {
                        default:
                        case 0: char_diff_text = "None"; break;
                        case 1: char_diff_text = "Normal"; break;
                        case 2: char_diff_text = "Nightmare"; break;
                        case 3: char_diff_text = "Hell"; break;
                    }
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Last difficulty completed", char_diff_text);
                }
                if (char_str || char_mag || char_dex || char_vit || char_gold) {
                    tmp = g_strdup_printf("%d", char_str);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character strength", tmp);
                    g_free(tmp);

                    tmp = g_strdup_printf("%d", char_mag);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character magic", tmp);
                    g_free(tmp);

                    tmp = g_strdup_printf("%d", char_dex);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character dexterity", tmp);
                    g_free(tmp);

                    tmp = g_strdup_printf("%d", char_vit);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character vitality", tmp);
                    g_free(tmp);

                    tmp = g_strdup_printf("%d", char_gold);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character gold", tmp);
                    g_free(tmp);
                }
                purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Spawned client", spawn ? "Yes" : "No");
                break;
            }
        case (0x44324456):
        case (0x44325850):
            {
                char *tmp;
                if (strlen(loc) == 0) {
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle,
                            "Diablo II character", "an open Battle.net character");
                } else {
                    char *realm_name; char *char_name; unsigned char *bytes;
                    unsigned char char_type, char_level, char_creation_flags, char_current_act, char_ladder_season;
                    char *char_type_name;

                    char *char_diff_text;

                    g_strdelimit(loc, ",", '\0');
                    realm_name = loc;
                    loc += strlen(realm_name) + 1;
                    char_name = loc;
                    loc += strlen(char_name) + 1;
                    bytes = (unsigned char *)loc;
                    char_type = bytes[13];
                    char_level = bytes[25];
                    char_creation_flags = bytes[26];
                    char_current_act = bytes[27];
                    char_ladder_season = bytes[30];

                    switch (char_type) {
                        default: char_type_name = "Unknown"; break;
                        case 0x01: char_type_name = "Amazon"; break;
                        case 0x02: char_type_name = "Sorceress"; break;
                        case 0x03: char_type_name = "Necromancer"; break;
                        case 0x04: char_type_name = "Paladin"; break;
                        case 0x05: char_type_name = "Barbarian"; break;
                        case 0x06: char_type_name = "Druid"; break;
                        case 0x07: char_type_name = "Assassin"; break;
                    }

                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Diablo II realm", realm_name);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Diablo II character", char_name);

                    tmp = g_strdup_printf("%d", char_level);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character level", tmp);
                    g_free(tmp);
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Character class", char_type_name);
# 7507 "src/bnet.c"
                    char_current_act = (char_current_act ^ 0x80) >> 1;
                    if (char_creation_flags & 0x20) {
                        switch (char_current_act) {
                            default:
                            case 0x0: case 0x1: case 0x2: case 0x3: case 0x4:
                                char_diff_text = "None"; break;
                            case 0x5: case 0x6: case 0x7: case 0x8: case 0x9:
                                char_diff_text = "Normal"; break;
                            case 0xA: case 0xB: case 0xC: case 0xD: case 0xE:
                                char_diff_text = "Nightmare"; break;
                            case 0xF:
                                char_diff_text = "Hell"; break;
                        }
                    } else {
                        switch (char_current_act >> 2) {
                            default:

                            case 0x0:
                                char_diff_text = "None"; break;

                            case 0x1:
                                char_diff_text = "Normal"; break;

                            case 0x2:
                                char_diff_text = "Nightmare"; break;

                            case 0x3:
                                char_diff_text = "Hell"; break;
                        }
                    }
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Last difficulty completed", char_diff_text);

                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Ladder character", (char_ladder_season == 0xFF) ? "No" : "Yes");
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Expansion character", (char_creation_flags & 0x20) ? "Yes" : "No");
                    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Hardcore character", (char_creation_flags & 0x04) ? "Yes" : "No");
                    if (char_creation_flags & 0x04) {
                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Dead", (char_creation_flags & 0x08) ? "Yes" : "No");
                    }
                }
                break;
            }
        case (0x57415233):
        case (0x57335850):
            {
                char *tmp;
                guint32 level = 0;
                int clan_len;

                bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FOUND_W3_CLAN;
                if (strlen(loc)) {
                    loc++;

                    loc += 5;
                    level = g_ascii_strtod(loc, &loc);



                    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_W3_CLAN;
                    if (strlen(loc)) {
                        loc++;
                        clan_len = strlen(loc);
                        s_clan = g_malloc0(5);
                        bnet->bncs.lookup_info.w3_tag = (BnetClanTag)0;
                        do { memmove ((s_clan), (loc), (clan_len)); } while (0);
                        bnet->bncs.lookup_info.w3_tag = bnet_string_to_tag(s_clan);
                        g_free(s_clan);
                    } else {
                        bnet->bncs.lookup_info.w3_tag = (BnetClanTag)0;
                    }

                    if (level) {
                        tmp = g_strdup_printf("%d", level);
                        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Warcraft III level", tmp);
                        g_free(tmp);
                    }
                }
                break;
            }
    }

    g_free(start);
    g_free(location_string);
    g_free(s_ping);
    g_free(s_caps);


    if (bnet->bncs.lookup_info.name != ((void *)0)) {
        g_free(bnet->bncs.lookup_info.name);
    }
    bnet->bncs.lookup_info.name = g_strdup(bcu->username);

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_LOCPROD;




    return (!(0));
}

static gboolean
bnet_lookup_info_cached_friends(BnetConnectionData *bnet)
{
    const char *acct_norm = bnet_account_normalize(bnet->account, bnet->bncs.lookup_info.name);
    GList *li = g_list_find_custom(bnet->bncs.friends.list, acct_norm, bnet_friend_user_compare);
    BnetFriendInfo *bfi;

    if (li == ((void *)0)) {

        return (0);
    }

    purple_debug_info("bnet", "Lookup local found: FRIENDS_LIST(%s)\n", acct_norm);

    bfi = li->data;

    if (!bnet->bncs.lookup_info.prpl_notify_handle) {
        bnet->bncs.lookup_info.prpl_notify_handle = purple_notify_user_info_new();
    } else if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FIRST_SECTION)) {
        purple_notify_user_info_add_section_break(bnet->bncs.lookup_info.prpl_notify_handle);
    }
    bnet->bncs.lookup_info.flags &= ~BNET_LOOKUP_INFO_FIRST_SECTION;

    purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Mutual friend",
            (bfi->status & BNET_FRIEND_STATUS_MUTUAL) ? "Yes" : "No");

    if (!(bnet->bncs.lookup_info.flags & BNET_LOOKUP_INFO_FOUND_LOCPROD)) {
        gchar *location_text = bnet_get_location_text(bfi->location, bfi->location_name);
        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Current location", location_text);
        g_free(location_text);
        if (bfi->location != BNET_FRIEND_LOCATION_OFFLINE) {
            purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Current product", bnet_get_product_name(bfi->product));
        }
    }
    if (bfi->status & BNET_FRIEND_STATUS_DND) {
        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Do Not Disturb", bfi->dnd_stored_status);
    }
    if (bfi->status & BNET_FRIEND_STATUS_AWAY) {
        purple_notify_user_info_add_pair_plaintext(bnet->bncs.lookup_info.prpl_notify_handle, "Away", bfi->away_stored_status);
    }

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_LOCPROD;




    return (!(0));
}

static gboolean
bnet_lookup_info_cached_clan(BnetConnectionData *bnet)
{
    const char *acct_norm = bnet_account_normalize(bnet->account, bnet->bncs.lookup_info.name);
    const BnetClanMember *bcmi = ((void *)0);
    BnetClanTag clan_tag;
    gchar *s_clan = ((void *)0);

    if (!bnet_clan_in_clan(bnet)) {
        return (0);
    }

    bcmi = bnet_clan_find_member(bnet, acct_norm);
    clan_tag = bnet->bncs.w3_clan.my_clantag;
    s_clan = bnet_tag_to_string(clan_tag);

    if (bcmi == ((void *)0)) {
        return (0);
    }

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_FOUND_W3_CLAN;
    bnet->bncs.lookup_info.w3_tag = clan_tag;

    purple_debug_info("bnet", "Lookup local found: W3_CLAN_LIST(%s, Clan %s)\n", acct_norm, s_clan);
# 7691 "src/bnet.c"
    if (bnet->bncs.lookup_info.name != ((void *)0)) {
        g_free(bnet->bncs.lookup_info.name);
    }
    bnet->bncs.lookup_info.name = g_strdup(bcmi->name);

    g_free(s_clan);

    return (!(0));
}

static void
bnet_lookup_info_whois(BnetConnectionData *bnet)
{
    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_AWAIT_WHOIS;
    purple_debug_info("bnet", "Lookup: WHOIS(%s)\n", bnet->bncs.lookup_info.name);

    bnet_do_whois(bnet, bnet->bncs.lookup_info.name);
}

static void
bnet_lookup_info_user_data(BnetConnectionData *bnet)
{
    gchar *final_request;
    BnetUserDataRequest *req;
    BnetUserDataRequestType request_type;
    gboolean is_self = (0);
    int recordbits = 0;
    char **keys;
    int request_cookie = g_str_hash(bnet->bncs.lookup_info.name);
    char *acct_norm = g_strdup(bnet_account_normalize(bnet->account, bnet->bncs.lookup_info.name));
    char *uu_norm = g_strdup(bnet_account_normalize(bnet->account, bnet_normalize(bnet->account, bnet->bncs.chat_env.unique_name)));

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_AWAIT_USER_DATA;
    purple_debug_info("bnet", "Lookup: USER_DATA(%s)\n", acct_norm);

    if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (uu_norm) && __builtin_constant_p (acct_norm) && (__s1_len = strlen (uu_norm), __s2_len = strlen (acct_norm), (!((size_t)(const void *)((uu_norm) + 1) - (size_t)(const void *)(uu_norm) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((acct_norm) + 1) - (size_t)(const void *)(acct_norm) == 1) || __s2_len >= 4)) ? __builtin_strcmp (uu_norm, acct_norm) : (__builtin_constant_p (uu_norm) && ((size_t)(const void *)((uu_norm) + 1) - (size_t)(const void *)(uu_norm) == 1) && (__s1_len = strlen (uu_norm), __s1_len < 4) ? (__builtin_constant_p (acct_norm) && ((size_t)(const void *)((acct_norm) + 1) - (size_t)(const void *)(acct_norm) == 1) ? __builtin_strcmp (uu_norm, acct_norm) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (acct_norm); register int __result = (((const unsigned char *) (const char *) (uu_norm))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (uu_norm))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (uu_norm))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (uu_norm))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (acct_norm) && ((size_t)(const void *)((acct_norm) + 1) - (size_t)(const void *)(acct_norm) == 1) && (__s2_len = strlen (acct_norm), __s2_len < 4) ? (__builtin_constant_p (uu_norm) && ((size_t)(const void *)((uu_norm) + 1) - (size_t)(const void *)(uu_norm) == 1) ? __builtin_strcmp (uu_norm, acct_norm) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (uu_norm); register int __result = __s1[0] - ((const unsigned char *) (const char *) (acct_norm))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (acct_norm))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (acct_norm))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (acct_norm))[3]); } } __result; }))) : __builtin_strcmp (uu_norm, acct_norm)))); }) == 0) {
        final_request = g_strdup_printf("%s\n%s", "profile\\sex\nprofile\\age\nprofile\\location\nprofile\\description", "System\\Account Created\nSystem\\Last Logoff\nSystem\\Last Logon\nSystem\\Time Logged\nSystem\\Account Expires\n");
        is_self = (!(0));
    } else {
        final_request = g_strdup("profile\\sex\nprofile\\age\nprofile\\location\nprofile\\description");
    }

    switch (bnet->bncs.versioning.product) {
        case (0x53534852):
            recordbits = 1;
            break;
        case (0x5732424e):
            recordbits = 1 |
                2 |
                8;
            break;
        case (0x53544152):
        case (0x53415850):
        case (0x4a535452):
            recordbits = 1 |
                2;
            break;
        case (0x4452544c):
        case (0x44534852):
        case (0x44324456):
        case (0x44325850):
        case (0x57415233):
        case (0x57335850):
            recordbits = 0;
            break;
    }

    if (recordbits & 1) {
        char *product_id = bnet_get_product_id_str(bnet->bncs.versioning.product);
        char *request_part = g_strdup_printf("Record\\%s\\%d\\wins\nRecord\\%s\\%d\\losses\nRecord\\%s\\%d\\disconnects\nRecord\\%s\\%d\\last game\nRecord\\%s\\%d\\last game result", (product_id), (0), (product_id), (0), (product_id), (0), (product_id), (0), (product_id), (0));
        char *request_combined = g_strdup_printf("%s\n%s", final_request, request_part);
        g_free(final_request);
        final_request = request_combined;
        g_free(product_id);
        g_free(request_part);
    }

    if (recordbits & 2) {
        char *product_id = bnet_get_product_id_str(bnet->bncs.versioning.product);
        char *request_part = g_strdup_printf("Record\\%s\\%d\\wins\nRecord\\%s\\%d\\losses\nRecord\\%s\\%d\\disconnects\nRecord\\%s\\%d\\last game\nRecord\\%s\\%d\\last game result\nRecord\\%s\\%d\\rating\nRecord\\%s\\%d\\high rating\nDynKey\\%s\\%d\\rank\nRecord\\%s\\%d\\high rank", (product_id), (1), (product_id), (1), (product_id), (1), (product_id), (1), (product_id), (1), (product_id), (1), (product_id), (1), (product_id), (1), (product_id), (1));
        char *request_combined = g_strdup_printf("%s\n%s", final_request, request_part);
        g_free(final_request);
        final_request = request_combined;
        g_free(product_id);
        g_free(request_part);
    }

    if (recordbits & 8) {
        char *product_id = bnet_get_product_id_str(bnet->bncs.versioning.product);
        char *request_part = g_strdup_printf("Record\\%s\\%d\\wins\nRecord\\%s\\%d\\losses\nRecord\\%s\\%d\\disconnects\nRecord\\%s\\%d\\last game\nRecord\\%s\\%d\\last game result\nRecord\\%s\\%d\\rating\nRecord\\%s\\%d\\high rating\nDynKey\\%s\\%d\\rank\nRecord\\%s\\%d\\high rank", (product_id), (3), (product_id), (3), (product_id), (3), (product_id), (3), (product_id), (3), (product_id), (3), (product_id), (3), (product_id), (3), (product_id), (3));
        char *request_combined = g_strdup_printf("%s\n%s", final_request, request_part);
        g_free(final_request);
        final_request = request_combined;
        g_free(product_id);
        g_free(request_part);
    }

    keys = g_strsplit(final_request, "\n", -1);

    request_type = BNET_READUSERDATA_REQUEST_PROFILE |
        ((is_self) ? BNET_READUSERDATA_REQUEST_SYSTEM : 0) |
        ((recordbits == 0) ? 0 : BNET_READUSERDATA_REQUEST_RECORD);

    req = bnet_userdata_request_new(request_cookie, request_type,
            acct_norm, keys,
            bnet->bncs.versioning.product);

    bnet->bncs.user_data.requests = g_list_append(bnet->bncs.user_data.requests, req);

    bnet_send_READUSERDATA(bnet, request_cookie, acct_norm, keys);

    g_free(final_request);
    g_free(acct_norm);
    g_free(uu_norm);
}

static void
bnet_lookup_info_w3_user_profile(BnetConnectionData *bnet)
{
    char *acct_norm = g_strdup(bnet_account_normalize(bnet->account, bnet->bncs.lookup_info.name));
    guint32 cookie;

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_AWAIT_W3_USER_PROFILE;
    purple_debug_info("bnet", "Lookup: W3_USER_PROFILE(%s)\n", acct_norm);

    cookie = bnet_packet_cookie_register(bnet, BNET_SID_W3PROFILE, g_strdup(acct_norm));

    bnet_send_W3PROFILE(bnet, cookie, acct_norm);

    g_free(acct_norm);
}

static void
bnet_lookup_info_w3_user_stats(BnetConnectionData *bnet)
{
    char *acct_norm = g_strdup(bnet_account_normalize(bnet->account, bnet->bncs.lookup_info.name));
    guint32 cookie;

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_AWAIT_W3_USER_STATS;
    purple_debug_info("bnet", "Lookup: W3_USER_STATS(%s)\n", acct_norm);

    cookie = bnet_packet_cookie_register(bnet, BNET_SID_W3GENERAL, g_strdup(acct_norm));

    bnet_send_W3GENERAL_USERRECORD(bnet, cookie, acct_norm, bnet->bncs.versioning.product);

    g_free(acct_norm);
}

static void
bnet_lookup_info_w3_clan_stats(BnetConnectionData *bnet)
{
    gchar *s_clan = bnet_tag_to_string(bnet->bncs.lookup_info.w3_tag);
    guint32 cookie;

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_AWAIT_W3_CLAN_STATS;
    purple_debug_info("bnet", "Lookup: W3_CLAN_STATS(Clan %s)\n", s_clan);

    cookie = bnet_packet_cookie_register(bnet, BNET_SID_W3GENERAL, s_clan);

    bnet_send_W3GENERAL_CLANRECORD(bnet, cookie, bnet->bncs.lookup_info.w3_tag, bnet->bncs.versioning.product);
}

static void
bnet_lookup_info_w3_clan_mi(BnetConnectionData *bnet)
{
    gchar *s_clan = bnet_tag_to_string(bnet->bncs.lookup_info.w3_tag);
    char *acct_norm = g_strdup(bnet_account_normalize(bnet->account, bnet->bncs.lookup_info.name));
    guint32 cookie;

    bnet->bncs.lookup_info.flags |= BNET_LOOKUP_INFO_AWAIT_W3_CLAN_MI;
    purple_debug_info("bnet", "Lookup: W3_CLAN_MI(%s, Clan %s)\n", acct_norm, s_clan);

    cookie = bnet_packet_cookie_register(bnet, BNET_SID_CLANMEMBERINFO, s_clan);

    bnet_send_CLANMEMBERINFO(bnet, cookie, bnet->bncs.lookup_info.w3_tag, acct_norm);

    g_free(acct_norm);
}

static void
bnet_action_set_motd_cb(gpointer data)
{
    BnetConnectionData *bnet;
    PurpleRequestFields *fields;
    GList *group_list; PurpleRequestFieldGroup *group;
    GList *field_list; PurpleRequestField *field = ((void *)0);
    const char *motd = ((void *)0);

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    fields = bnet->bncs.w3_clan.prpl_setmotd_fields_handle;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (fields != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "fields != NULL"); return; }; }while (0);
    group_list = g_list_first(purple_request_fields_get_groups(fields));
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group_list != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group_list != NULL"); return; }; }while (0);
    group = group_list->data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group != NULL"); return; }; }while (0);
    field_list = g_list_first(purple_request_field_group_get_fields(group));

    if (field_list != ((void *)0)) {
        field = field_list->data;
    }
    if (field != ((void *)0)) {
        motd = purple_request_field_string_get_value(field);
    }
    if (motd == ((void *)0)) {
        motd = "";
    }

    if (bnet_clan_in_clan(bnet)) {
        BnetClanMemberRank rank = bnet->bncs.w3_clan.my_rank;
        if (rank == BNET_CLAN_RANK_SHAMAN || rank == BNET_CLAN_RANK_CHIEFTAIN) {
            PurpleConversation *conv = ((void *)0);
            PurpleConvChat *chat = ((void *)0);
            bnet_send_CLANSETMOTD(bnet, 0xbaadf00du, motd);
            if (!bnet->bncs.chat_env.first_join && bnet->bncs.channel.prpl_chat_id != 0) {
                conv = purple_find_chat(bnet->account->gc, bnet->bncs.channel.prpl_chat_id);
            }
            if (conv != ((void *)0)) {
                chat = purple_conversation_get_chat_data(conv);
            }
            if (chat != ((void *)0) && bnet_clan_is_clan_channel(bnet, bnet->bncs.channel.name)) {
                purple_conv_chat_set_topic(chat, "(clan leader)", motd);
            }
        }
    }
}

static gint
bnet_news_item_sort(gconstpointer a, gconstpointer b)
{
    const BnetNewsItem *news_a = a;
    const BnetNewsItem *news_b = b;

    return news_b->timestamp - news_a->timestamp;
}

static gchar *
bnet_locale_full_escape_nullable(const gchar *input)
{
    gchar *r1;
    gchar *r2;

    if (input == ((void *)0)) {
        return ((void *)0);
    }

    r1 = bnet_to_utf8_crlf(input);
    r2 = bnet_escape_text(r1, -1, (!(0)));
    g_free(r1);
    return r2;
}

static void
bnet_cache_set(BnetConnectionData *bnet, gchar *name, guint64 timestamp, gchar *key, gchar *val)
{
    xmlnode *current_cache;
    xmlnode *file;
    xmlnode *file_child;
    gboolean was_set = (0);
    gchar *output;
    int length;

    current_cache = purple_util_read_xml_from_file("bnet-cache.xml", "Battle.net data cache");

    if (current_cache != ((void *)0)) {

        if (!g_str_equal(current_cache->name, "cache")) {
            xmlnode_free(current_cache);
            current_cache = xmlnode_new("cache");
        }


        for (file = current_cache->child; file; file = file->next) {
            if (file->type != XMLNODE_TYPE_TAG) {
                continue;
            }
            if (g_str_equal(file->name, "file")) {
                const gchar *current_name = xmlnode_get_attrib(file, "name");
                const gchar *current_key = xmlnode_get_attrib(file, "key");
                if (g_str_equal(name, current_name) &&
                        g_str_equal(key, current_key)) {
                    gchar buf[(29 + 10)];
                    g_ascii_dtostr(buf, (29 + 10), timestamp);
                    xmlnode_set_attrib(file, "timestamp", buf);
                    for (file_child = file->child; file_child; file_child = file_child->next) {
                        if (file_child->type != XMLNODE_TYPE_DATA) {
                            continue;
                        }
                        g_free(file_child->data);
                        file_child->data = val;
                        was_set = (!(0));
                    }
                    if (!was_set) {
                        xmlnode_insert_data(file, val, -1);
                        was_set = (!(0));
                    }
                    break;
                }
            }
        }
    } else {
        current_cache = xmlnode_new("cache");
    }


    if (!was_set) {
        xmlnode *file = xmlnode_new_child(current_cache, "file");
        gchar buf[(29 + 10)];
        g_ascii_dtostr(buf, (29 + 10), timestamp);
        xmlnode_set_attrib(file, "name", name);
        xmlnode_set_attrib(file, "key", key);
        xmlnode_set_attrib(file, "timestamp", buf);
        xmlnode_insert_data(file, val, -1);
    }


 output = xmlnode_to_formatted_str(current_cache, &length);
 xmlnode_free(current_cache);
 purple_util_write_data_to_file("bnet-cache.xml", output, length);
    g_free(output);
}

static gchar *
bnet_cache_get(BnetConnectionData *bnet, gchar *name, guint64 *timestamp, gchar *key)
{
    xmlnode *current_cache;
    xmlnode *file;

    *timestamp = 0;
    current_cache = purple_util_read_xml_from_file("bnet-cache.xml", "Battle.net data cache");

    if (current_cache != ((void *)0)) {

        if (!g_str_equal(current_cache->name, "cache")) {
            return ((void *)0);
        }


        for (file = current_cache->child; file; file = file->next) {
            if (file->type != XMLNODE_TYPE_TAG) {
                continue;
            }
            if (g_str_equal(file->name, "file")) {
                const gchar *current_name = xmlnode_get_attrib(file, "name");
                const gchar *current_key = xmlnode_get_attrib(file, "key");
                if (g_str_equal(name, current_name) &&
                        g_str_equal(key, current_key)) {
                    const gchar *current_timestamp = xmlnode_get_attrib(file, "timestamp");
                    const gchar *current_value = xmlnode_get_data(file);
                    *timestamp = g_ascii_strtod(current_timestamp, ((void *)0));
                    return g_strdup(current_value);
                }
            }
        }
    }

    return ((void *)0);
}

static void
bnet_news_save(BnetConnectionData *bnet)
{
    GList *el;
    BnetPacket *pkt;
    gchar *cache_key;
    gchar *cache_val;

    pkt = bnet_packet_create(0);
    bnet_packet_insert(pkt, bnet->bncs.conn.server, -1);
    bnet_packet_insert(pkt, &bnet->bncs.versioning.product, 4);
    cache_key = bnet_packet_serialize(pkt);

    pkt = bnet_packet_create(0);
    bnet_packet_insert(pkt, &bnet->bncs.news.item_count, 1);
    el = g_list_first(bnet->bncs.news.item_list);
    while (el != ((void *)0)) {
        BnetNewsItem *item = el->data;

        if (item->timestamp > 0 && item->message != ((void *)0)) {
            bnet_packet_insert(pkt, &item->timestamp, 4);
            bnet_packet_insert(pkt, item->message, -1);
        }

        el = ((el) ? (((GList *)(el))->next) : ((void *)0));
    }
    cache_val = bnet_packet_serialize(pkt);
    bnet_cache_set(bnet, "pkt:SID_NEWS_INFO", bnet->bncs.news.latest, cache_key, cache_val);
}

static void
bnet_news_load(BnetConnectionData *bnet)
{
    BnetPacket *pkt;
    gchar *cache_key;
    gchar *cache_val;
    int i;
    guint64 timestamp;

    pkt = bnet_packet_create(0);
    bnet_packet_insert(pkt, bnet->bncs.conn.server, -1);
    bnet_packet_insert(pkt, &bnet->bncs.versioning.product, 4);
    cache_key = bnet_packet_serialize(pkt);
    cache_val = bnet_cache_get(bnet, "pkt:SID_NEWS_INFO", &timestamp, cache_key);

    bnet->bncs.news.latest = timestamp;
    if (cache_val == ((void *)0)) {
        bnet->bncs.news.item_count = 0;
        bnet->bncs.news.item_list = ((void *)0);
    } else {
        pkt = bnet_packet_deserialize(cache_val);
        if (pkt != ((void *)0) && bnet_packet_can_read(pkt, 1)) {
            bnet->bncs.news.item_count = bnet_packet_read_byte(pkt);
            for (i = 0; i < bnet->bncs.news.item_count; i++) {
                BnetNewsItem *item = (BnetNewsItem *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (BnetNewsItem); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
                guint32 timestamp = bnet_packet_read_dword(pkt);
                gchar *message = bnet_packet_read_cstring(pkt);
                GList *el2 = g_list_first(bnet->bncs.news.item_list);

                while (el2 != ((void *)0)) {
                    if (((BnetNewsItem *)el2->data)->timestamp == timestamp) {
                        purple_debug_warning("bnet", "duplicate in bnet_news_load\n");
                    }
                    el2 = ((el2) ? (((GList *)(el2))->next) : ((void *)0));
                }

                item->timestamp = timestamp;
                item->message = message;

                bnet->bncs.news.item_list = g_list_append(bnet->bncs.news.item_list, item);
            }
        }
        bnet_packet_free(pkt);
        g_free(cache_val);
    }
    g_free(cache_key);
}

static void
bnet_action_show_news(PurplePluginAction *action)
{
    PurpleConnection *gc = action->context;
    BnetConnectionData *bnet = gc->proto_data;
    GList *el = ((void *)0);
    gchar *formatted = g_malloc0(1);
    int i;

    if (bnet->bncs.news.item_list != ((void *)0)) {
        for (i = 0; i < 6; i++) {
            const gchar *type;
            gchar *name;
            gchar *subname;
            gchar *message;
            gchar *s_name;
            gchar *s_message;
            gchar *sum;

            switch (i) {
                default:
                case 0:
                    type = "Message of the Day for Battle.net";
                    break;
                case 1:
                    type = "Message from the Battle.net Logon Server";
                    break;
                case 2:
                    type = "Message of the Day for the Diablo II Realm";
                    break;
                case 3:
                    type = "Message of the Day for your Warcraft III Clan";
                    break;
                case 4:
                    type = "Tournament Information for WCG";
                    break;
                case 5:
                    type = "Tournament Information for Warcraft III";
                    break;
            }

            name = bnet_locale_full_escape_nullable(bnet->bncs.motds[i].name);
            subname = bnet_locale_full_escape_nullable(bnet->bncs.motds[i].subname);
            message = bnet_locale_full_escape_nullable(bnet->bncs.motds[i].message);

            if (name != ((void *)0) || message != ((void *)0)) {
                if (name != ((void *)0)) {
                    if (subname != ((void *)0)) {
                        s_name = g_strdup_printf("<i>%s: %s</i><br>", name, subname);
                        g_free(subname);
                    } else {
                        s_name = g_strdup_printf("<i>%s</i><br>", name);
                    }
                } else {
                    s_name = g_strdup("");
                }
                if (message != ((void *)0)) {
                    s_message = message;
                } else {
                    s_message = g_strdup("<i>No message stored.</i>");
                }
                sum = g_strdup_printf("%s<b>%s</b><br>%s%s<br><br>", formatted, type, s_name, s_message);
                g_free(formatted);
                g_free(s_name);
                g_free(s_message);
                formatted = sum;
            }
        }


        el = g_list_first(bnet->bncs.news.item_list);
        do {
            BnetNewsItem *item = el->data;
            gchar *add = ((void *)0);
            gchar *sum = ((void *)0);
            gchar *msgbody = bnet_locale_full_escape_nullable(item->message);
            gchar *tm = bnet_format_time(item->timestamp);
            add = g_strdup_printf("<b>%s</b><br>%s<br><br>", tm, msgbody);
            sum = g_strdup_printf("%s%s", formatted, add);
            g_free(tm);
            g_free(add);
            g_free(formatted);
            g_free(msgbody);
            formatted = sum;

            el = ((el) ? (((GList *)(el))->next) : ((void *)0));
        } while (el != ((void *)0));
    }

    if (strlen(formatted) == 0) {
        g_free(formatted);
        formatted = g_strdup("<i>No news returned.</i>");
    }
    purple_notify_formatted(bnet->account->gc, "Battle.net News",
            "News for this Battle.net server.", ((void *)0), formatted, ((void *)0), ((void *)0));

    g_free(formatted);
}

static void
bnet_action_set_motd(PurplePluginAction *action)
{
    PurpleConnection *gc = action->context;
    BnetConnectionData *bnet = gc->proto_data;
    PurpleRequestField *field = ((void *)0);
    PurpleRequestFields *fields = ((void *)0);
    PurpleRequestFieldGroup *group = ((void *)0);
    BnetClanMemberRank my_rank = 0;
    BnetClanTag tag = 0;
    gchar *group_name = ((void *)0);
    gchar *tag_string = ((void *)0);
    gchar *current_motd = ((void *)0);

    if (bnet == ((void *)0)) return;
    if (bnet_is_telnet(bnet)) return;
    if (!bnet_clan_in_clan(bnet)) return;

    my_rank = bnet->bncs.w3_clan.my_rank;

    if (my_rank != BNET_CLAN_RANK_SHAMAN &&
            my_rank != BNET_CLAN_RANK_CHIEFTAIN) return;

    tag = bnet->bncs.w3_clan.my_clantag;
    tag_string = bnet_tag_to_string(tag);

    current_motd = bnet->bncs.motds[3].message;
    if (current_motd == ((void *)0)) {
        current_motd = g_strdup("");
    }

    fields = purple_request_fields_new();
    group_name = g_strdup_printf("Set clan MOTD for Clan %s", tag_string);
    group = purple_request_field_group_new(group_name);

    field = purple_request_field_string_new("motd", "Message of the Day", current_motd, (0));
    purple_request_field_string_set_editable(field, (!(0)));
    purple_request_field_set_required(field, (!(0)));
    purple_request_field_string_set_value(field, current_motd);
    purple_request_field_group_add_field(group, field);

    purple_request_fields_add_group(fields, group);

    bnet->bncs.w3_clan.prpl_setmotd_fields_handle = fields;

    purple_request_fields(gc, "Edit Clan MOTD", "Change this WarCraft III clan's MOTD.", ((void *)0), fields,
            "Save", (GCallback)bnet_action_set_motd_cb, "Cancel", ((void *)0),
            bnet->account, ((void *)0), ((void *)0), bnet);

    g_free(tag_string);
    g_free(group_name);
}

static void
bnet_action_set_user_data(PurplePluginAction *action)
{
    PurpleConnection *gc = action->context;
    BnetConnectionData *bnet = gc->proto_data;

    if (bnet == ((void *)0)) return;

    if (bnet_is_telnet(bnet)) return;

    bnet_profile_get_for_edit(bnet);
}

static void
bnet_profile_get_for_edit(BnetConnectionData *bnet)
{
    const char *uu_norm = bnet_normalize(bnet->account, bnet->bncs.chat_env.unique_name);
    int request_cookie = g_str_hash(uu_norm);
    BnetUserDataRequest *req;
    char **keys;

    keys = g_strsplit("profile\\sex\nprofile\\age\nprofile\\location\nprofile\\description", "\n", -1);

    bnet->bncs.user_data.writing_profile = (!(0));

    req = bnet_userdata_request_new(request_cookie, BNET_READUSERDATA_REQUEST_PROFILE,
            bnet->bncs.logon.username, keys, bnet->bncs.versioning.product);

    bnet->bncs.user_data.requests = g_list_append(bnet->bncs.user_data.requests, req);

    bnet_send_READUSERDATA(bnet, request_cookie, bnet->bncs.logon.username, keys);
}

static void
bnet_profile_show_write_dialog(BnetConnectionData *bnet,
        const char *psex, const char *page, const char *ploc, const char *pdescr)
{
    PurpleRequestField *field;
    PurpleRequestFields *fields = purple_request_fields_new();
    gchar *group_name = g_strdup_printf("Change profile information for %s", bnet->bncs.logon.username);
    PurpleRequestFieldGroup *group = purple_request_field_group_new(group_name);

    field = purple_request_field_string_new("profile\\sex", "Sex", psex, (0));
    purple_request_field_group_add_field(group, field);
    purple_request_field_string_set_editable(field, (!(0)));
    purple_request_field_set_required(field, (0));
# 8334 "src/bnet.c"
    field = purple_request_field_string_new("profile\\location", "Location", ploc, (0));
    purple_request_field_group_add_field(group, field);
    purple_request_field_string_set_editable(field, (!(0)));
    purple_request_field_set_required(field, (0));


    field = purple_request_field_string_new("profile\\description", "Description", pdescr, (!(0)));
    purple_request_field_group_add_field(group, field);
    purple_request_field_string_set_editable(field, (!(0)));
    purple_request_field_set_required(field, (0));


    purple_request_fields_add_group(fields, group);

    bnet->bncs.user_data.prpl_profile_fields_handle = fields;

    bnet->bncs.user_data.writing_profile = (0);

    purple_request_fields(bnet->account->gc,
            "Edit Profile",
            ((void *)0), ((void *)0),
            fields,
            "_Save", (GCallback)bnet_profile_write_cb,
            "_Cancel", ((void *)0),
            bnet->account,
            ((void *)0), ((void *)0),
            bnet);
}

static void
bnet_profile_write_cb(gpointer data)
{
    BnetConnectionData *bnet;
    PurpleRequestFields *fields;
    GList *group_list; PurpleRequestFieldGroup *group;
    GList *field_list; PurpleRequestField *field;
    const char *s_const = "";
    const char *sex = s_const;
    const char *age = s_const;
    const char *location = s_const;
    const char *description = s_const;
    const char *field_id;

    bnet = data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (bnet != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "bnet != NULL"); return; }; }while (0);
    fields = bnet->bncs.user_data.prpl_profile_fields_handle;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (fields != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "fields != NULL"); return; }; }while (0);
    group_list = g_list_first(purple_request_fields_get_groups(fields));
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group_list != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group_list != NULL"); return; }; }while (0);
    group = group_list->data;
    do{ if (__builtin_expect (__extension__ ({ int _g_boolean_var_; if (group != ((void *)0)) _g_boolean_var_ = 1; else _g_boolean_var_ = 0; _g_boolean_var_; }), 1)) { } else { g_return_if_fail_warning (((gchar*) 0), __PRETTY_FUNCTION__, "group != NULL"); return; }; }while (0);
    field_list = g_list_first(purple_request_field_group_get_fields(group));

    while (field_list != ((void *)0)) {
        field = field_list->data;
        field_id = purple_request_field_get_id(field);
        if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (field_id) && __builtin_constant_p ("profile\\sex") && (__s1_len = strlen (field_id), __s2_len = strlen ("profile\\sex"), (!((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("profile\\sex") + 1) - (size_t)(const void *)("profile\\sex") == 1) || __s2_len >= 4)) ? __builtin_strcmp (field_id, "profile\\sex") : (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) && (__s1_len = strlen (field_id), __s1_len < 4) ? (__builtin_constant_p ("profile\\sex") && ((size_t)(const void *)(("profile\\sex") + 1) - (size_t)(const void *)("profile\\sex") == 1) ? __builtin_strcmp (field_id, "profile\\sex") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("profile\\sex"); register int __result = (((const unsigned char *) (const char *) (field_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (field_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("profile\\sex") && ((size_t)(const void *)(("profile\\sex") + 1) - (size_t)(const void *)("profile\\sex") == 1) && (__s2_len = strlen ("profile\\sex"), __s2_len < 4) ? (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) ? __builtin_strcmp (field_id, "profile\\sex") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (field_id); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("profile\\sex"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("profile\\sex"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("profile\\sex"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("profile\\sex"))[3]); } } __result; }))) : __builtin_strcmp (field_id, "profile\\sex")))); }) == 0) {
            sex = purple_request_field_string_get_value(field);
            if (sex == ((void *)0)) {
                sex = s_const;
            }
        } else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (field_id) && __builtin_constant_p ("profile\\age") && (__s1_len = strlen (field_id), __s2_len = strlen ("profile\\age"), (!((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("profile\\age") + 1) - (size_t)(const void *)("profile\\age") == 1) || __s2_len >= 4)) ? __builtin_strcmp (field_id, "profile\\age") : (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) && (__s1_len = strlen (field_id), __s1_len < 4) ? (__builtin_constant_p ("profile\\age") && ((size_t)(const void *)(("profile\\age") + 1) - (size_t)(const void *)("profile\\age") == 1) ? __builtin_strcmp (field_id, "profile\\age") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("profile\\age"); register int __result = (((const unsigned char *) (const char *) (field_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (field_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("profile\\age") && ((size_t)(const void *)(("profile\\age") + 1) - (size_t)(const void *)("profile\\age") == 1) && (__s2_len = strlen ("profile\\age"), __s2_len < 4) ? (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) ? __builtin_strcmp (field_id, "profile\\age") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (field_id); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("profile\\age"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("profile\\age"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("profile\\age"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("profile\\age"))[3]); } } __result; }))) : __builtin_strcmp (field_id, "profile\\age")))); }) == 0) {
            age = purple_request_field_string_get_value(field);
            if (age == ((void *)0)) {
                age = s_const;
            }
        } else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (field_id) && __builtin_constant_p ("profile\\location") && (__s1_len = strlen (field_id), __s2_len = strlen ("profile\\location"), (!((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("profile\\location") + 1) - (size_t)(const void *)("profile\\location") == 1) || __s2_len >= 4)) ? __builtin_strcmp (field_id, "profile\\location") : (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) && (__s1_len = strlen (field_id), __s1_len < 4) ? (__builtin_constant_p ("profile\\location") && ((size_t)(const void *)(("profile\\location") + 1) - (size_t)(const void *)("profile\\location") == 1) ? __builtin_strcmp (field_id, "profile\\location") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("profile\\location"); register int __result = (((const unsigned char *) (const char *) (field_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (field_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("profile\\location") && ((size_t)(const void *)(("profile\\location") + 1) - (size_t)(const void *)("profile\\location") == 1) && (__s2_len = strlen ("profile\\location"), __s2_len < 4) ? (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) ? __builtin_strcmp (field_id, "profile\\location") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (field_id); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("profile\\location"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("profile\\location"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("profile\\location"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("profile\\location"))[3]); } } __result; }))) : __builtin_strcmp (field_id, "profile\\location")))); }) == 0) {
            location = purple_request_field_string_get_value(field);
            if (location == ((void *)0)) {
                location = s_const;
            }
        } else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (field_id) && __builtin_constant_p ("profile\\description") && (__s1_len = strlen (field_id), __s2_len = strlen ("profile\\description"), (!((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("profile\\description") + 1) - (size_t)(const void *)("profile\\description") == 1) || __s2_len >= 4)) ? __builtin_strcmp (field_id, "profile\\description") : (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) && (__s1_len = strlen (field_id), __s1_len < 4) ? (__builtin_constant_p ("profile\\description") && ((size_t)(const void *)(("profile\\description") + 1) - (size_t)(const void *)("profile\\description") == 1) ? __builtin_strcmp (field_id, "profile\\description") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("profile\\description"); register int __result = (((const unsigned char *) (const char *) (field_id))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (field_id))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (field_id))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("profile\\description") && ((size_t)(const void *)(("profile\\description") + 1) - (size_t)(const void *)("profile\\description") == 1) && (__s2_len = strlen ("profile\\description"), __s2_len < 4) ? (__builtin_constant_p (field_id) && ((size_t)(const void *)((field_id) + 1) - (size_t)(const void *)(field_id) == 1) ? __builtin_strcmp (field_id, "profile\\description") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (field_id); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("profile\\description"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("profile\\description"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("profile\\description"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("profile\\description"))[3]); } } __result; }))) : __builtin_strcmp (field_id, "profile\\description")))); }) == 0) {
            description = purple_request_field_string_get_value(field);
            if (description == ((void *)0)) {
                description = s_const;
            }
        }
        field_list = ((field_list) ? (((GList *)(field_list))->next) : ((void *)0));
    }

    if (sex != s_const ||
        age != s_const ||
        location != s_const ||
        description == s_const) {
        bnet_send_WRITEUSERDATA(bnet, sex, age, location, description);
    }
}


static GHashTable *
bnet_chat_info_defaults(PurpleConnection *gc, const char *chat_name)
{
    GHashTable *defaults;

    defaults = g_hash_table_new_full(g_str_hash, g_str_equal, ((void *)0), g_free);

    if (chat_name != ((void *)0))
        g_hash_table_insert(defaults, "channel", g_strdup(chat_name));

    return defaults;
}

static GList *
bnet_chat_info(PurpleConnection *gc)
{
    GList *m = ((void *)0);
    struct proto_chat_entry *pce;

    pce = (struct proto_chat_entry *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (struct proto_chat_entry); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    pce->label = "_Channel:";
    pce->identifier = "channel";
    pce->required = (!(0));
    m = g_list_append(m, pce);

    return m;
}

static char *
bnet_channel_message_parse(char *stats_data, BnetChatEventFlags flags, int ping)
{
    BnetProductID product_id = bnet_string_to_tag(stats_data);
    return g_strdup_printf("%dms using %s", ping, bnet_get_product_name(product_id));
}

static PurpleConvChatBuddyFlags
bnet_channel_flags_to_prpl_flags(BnetChatEventFlags flags)
{
    PurpleConvChatBuddyFlags result = 0;
    if (flags & BNET_USER_FLAG_BLIZZREP ||
            flags & BNET_USER_FLAG_BNETADMIN) {
        result |= PURPLE_CBFLAGS_FOUNDER;
    }
    if (flags & BNET_USER_FLAG_OP) {
        result |= PURPLE_CBFLAGS_OP;
    }
    if (flags & BNET_USER_FLAG_VOICE) {
        result |= PURPLE_CBFLAGS_VOICE;
    }
    return result;
}

static gboolean
bnet_join_timer(BnetConnectionData *bnet)
{
    const char *room = bnet->bncs.channel.name_pending;
    const char *norm = ((void *)0);
    int chat_id = 0;
    gchar *cmd = ((void *)0);

    norm = bnet_normalize(bnet->account, room);
    chat_id = g_str_hash(norm);
    bnet->bncs.channel.join_timer_handle = 0;
    if (chat_id == bnet->bncs.channel.prpl_chat_id) {


        return (0);
    }
    cmd = g_strdup_printf("/join %s", room);
    if (bnet_is_telnet(bnet)) {
        bnet_send_telnet_line(bnet, cmd);
    } else {
        bnet_send_CHATCOMMAND(bnet, cmd);
    }
    g_free(cmd);
    return (0);
}

static void
bnet_join_chat(PurpleConnection *gc, GHashTable *components)
{
    BnetConnectionData *bnet = gc->proto_data;
    char *room = g_hash_table_lookup(components, "channel");
    const char *norm = ((void *)0);
    int chat_id = 0;

    if (room == ((void *)0)) {

        room = g_hash_table_lookup(components, "name");
        if (room == ((void *)0)) {

            return;
        }
    }

    purple_debug_info("bnet", "Attempting to join channel %s...\n", room);

    norm = bnet_normalize(bnet->account, room);
    chat_id = g_str_hash(norm);

    if (bnet->bncs.channel.prpl_chat_id == chat_id) {
        PurpleConversation *conv = ((void *)0);

        serv_got_chat_left(gc, bnet->bncs.channel.prpl_chat_id);

        bnet->bncs.channel.prpl_chat_id = chat_id;

        conv = serv_got_joined_chat(gc, chat_id, bnet->bncs.channel.name);

        if (bnet->bncs.channel.user_list != ((void *)0)) {
            PurpleConvChat *chat = ((void *)0);
            if (!bnet->bncs.chat_env.first_join && conv != ((void *)0))
                chat = purple_conversation_get_chat_data(conv);
            if (chat != ((void *)0)) {
                GList *users = ((void *)0);
                GList *extras = ((void *)0);
                GList *flags = ((void *)0);
                GList *el = g_list_first(bnet->bncs.channel.user_list);

                while (el != ((void *)0)) {
                    BnetChannelUser *bcuel = el->data;
                    int bcuelflags = bnet_channel_flags_to_prpl_flags(bcuel->flags);

                    users = g_list_prepend(users, bcuel->username);
                    extras = g_list_prepend(extras, bnet_channel_message_parse(bcuel->stats_data, bcuel->flags, bcuel->ping));
                    flags = g_list_prepend(flags, ((gpointer) (glong) (bcuelflags)));


                    el = ((el) ? (((GList *)(el))->next) : ((void *)0));
                }
                purple_conv_chat_add_users(chat, users, extras, flags, (0));
                g_list_free(users);
                _g_list_free_full(extras, g_free);
                g_list_free(flags);
            }
        }

        return;
    }

    if (bnet->bncs.channel.name_pending != ((void *)0)) {
        if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (bnet->bncs.channel.name_pending) && __builtin_constant_p (room) && (__s1_len = strlen (bnet->bncs.channel.name_pending), __s2_len = strlen (room), (!((size_t)(const void *)((bnet->bncs.channel.name_pending) + 1) - (size_t)(const void *)(bnet->bncs.channel.name_pending) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((room) + 1) - (size_t)(const void *)(room) == 1) || __s2_len >= 4)) ? __builtin_strcmp (bnet->bncs.channel.name_pending, room) : (__builtin_constant_p (bnet->bncs.channel.name_pending) && ((size_t)(const void *)((bnet->bncs.channel.name_pending) + 1) - (size_t)(const void *)(bnet->bncs.channel.name_pending) == 1) && (__s1_len = strlen (bnet->bncs.channel.name_pending), __s1_len < 4) ? (__builtin_constant_p (room) && ((size_t)(const void *)((room) + 1) - (size_t)(const void *)(room) == 1) ? __builtin_strcmp (bnet->bncs.channel.name_pending, room) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (room); register int __result = (((const unsigned char *) (const char *) (bnet->bncs.channel.name_pending))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (bnet->bncs.channel.name_pending))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (bnet->bncs.channel.name_pending))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (bnet->bncs.channel.name_pending))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (room) && ((size_t)(const void *)((room) + 1) - (size_t)(const void *)(room) == 1) && (__s2_len = strlen (room), __s2_len < 4) ? (__builtin_constant_p (bnet->bncs.channel.name_pending) && ((size_t)(const void *)((bnet->bncs.channel.name_pending) + 1) - (size_t)(const void *)(bnet->bncs.channel.name_pending) == 1) ? __builtin_strcmp (bnet->bncs.channel.name_pending, room) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (bnet->bncs.channel.name_pending); register int __result = __s1[0] - ((const unsigned char *) (const char *) (room))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (room))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (room))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (room))[3]); } } __result; }))) : __builtin_strcmp (bnet->bncs.channel.name_pending, room)))); }) == 0) {


            return;
        }
        g_free(bnet->bncs.channel.name_pending);
    }
    bnet->bncs.channel.name_pending = g_strdup(room);
    if (bnet->bncs.channel.join_timer_handle != 0) {
        purple_timeout_remove(bnet->bncs.channel.join_timer_handle);
    }
    bnet->bncs.channel.join_timer_handle = purple_timeout_add_seconds(1, (GSourceFunc)bnet_join_timer, bnet);
}

static int
bnet_chat_im(PurpleConnection *gc, int chat_id, const char *message, PurpleMessageFlags flags)
{
    BnetConnectionData *bnet = gc->proto_data;
    char *msg_nohtml;

    if (!bnet->bncs.chat_env.is_online) {
        return -107;
    }
    if (__extension__ ({ char __a0, __a1, __a2; (__builtin_constant_p ("\t\v\r\n") && ((size_t)(const void *)(("\t\v\r\n") + 1) - (size_t)(const void *)("\t\v\r\n") == 1) ? ((__builtin_constant_p (message) && ((size_t)(const void *)((message) + 1) - (size_t)(const void *)(message) == 1)) ? __builtin_strpbrk (message, "\t\v\r\n") : ((__a0 = ((const char *) ("\t\v\r\n"))[0], __a0 == '\0') ? ((void) (message), (char *) ((void *)0)) : ((__a1 = ((const char *) ("\t\v\r\n"))[1], __a1 == '\0') ? __builtin_strchr (message, __a0) : ((__a2 = ((const char *) ("\t\v\r\n"))[2], __a2 == '\0') ? __strpbrk_c2 (message, __a0, __a1) : (((const char *) ("\t\v\r\n"))[3] == '\0' ? __strpbrk_c3 (message, __a0, __a1, __a2) : __builtin_strpbrk (message, "\t\v\r\n")))))) : __builtin_strpbrk (message, "\t\v\r\n")); }) != ((void *)0)) {
        return -0x0100;
    }
    msg_nohtml = purple_unescape_text(message);
    if (strlen(message) > 225) {
        return -7;
    }

    if (message[0] == '/') {
        PurpleConversation *conv = purple_find_chat(gc, bnet->bncs.channel.prpl_chat_id);
        PurpleConvChat *chat = ((void *)0);
        if (conv != ((void *)0)) {
            chat = purple_conversation_get_chat_data(conv);
        }
        if (chat != ((void *)0)) {
            gchar *e = ((void *)0);
            if (purple_cmd_do_command(conv, msg_nohtml + 1, msg_nohtml + 1, &e) == PURPLE_CMD_STATUS_NOT_FOUND) {
                if (bnet_is_telnet(bnet)) {
                    bnet_send_telnet_line(bnet, (char *)msg_nohtml);
                } else {
                    bnet_send_CHATCOMMAND(bnet, (char *)msg_nohtml);
                }
            }

            if (e != ((void *)0)) {
                serv_got_chat_in(gc, bnet->bncs.channel.prpl_chat_id, "", PURPLE_MESSAGE_ERROR, e, time(((void *)0)));
            }
        }
        g_free(msg_nohtml);
        return 0;
    } else {
        int len = strlen(msg_nohtml);
        gchar *esc_text = bnet_escape_text(msg_nohtml, -1, (0));
        if (bnet_is_telnet(bnet)) {
            bnet_send_telnet_line(bnet, (char *)msg_nohtml);
        } else {
            bnet_send_CHATCOMMAND(bnet, (char *)msg_nohtml);
        }
        serv_got_chat_in(gc, bnet->bncs.channel.prpl_chat_id, bnet->bncs.logon.username, PURPLE_MESSAGE_SEND, esc_text, time(((void *)0)));
        g_free(msg_nohtml);
        return len;
    }
}

static const char *
bnet_list_icon(PurpleAccount *a, PurpleBuddy *b)
{

    return "bnet";
}

static const char *
bnet_list_emblem(PurpleBuddy *b)
{
    BnetUser *bfi = purple_buddy_get_protocol_data(b);
    if (bfi == ((void *)0)) {
        return "not-authorized";
    } else if (bfi->type == 0x02) {
        if (((BnetFriendInfo *)bfi)->location >= BNET_FRIEND_LOCATION_GAME_PUBLIC) {
            return "game";
        } else {
            return ((void *)0);
        }
    } else {
        return ((void *)0);
    }
}

static char *
bnet_status_text(PurpleBuddy *b)
{
    BnetUser *bfi = purple_buddy_get_protocol_data(b);
    if (bfi == ((void *)0)) {
        return g_strdup("Not on Battle.net's friend list.");
    } else if (bfi->type == 0x02 && ((BnetFriendInfo *)bfi)->away_stored_status != ((void *)0)) {
        return g_strdup(((BnetFriendInfo *)bfi)->away_stored_status);
    } else if (bfi->type == 0x02 && ((BnetFriendInfo *)bfi)->dnd_stored_status != ((void *)0)) {
        return g_strdup(((BnetFriendInfo *)bfi)->dnd_stored_status);
    } else {
        return g_strdup("");
    }
}

static void
bnet_tooltip_text(PurpleBuddy *buddy,
        PurpleNotifyUserInfo *info,
        gboolean full)
{
    BnetUser *bfi = purple_buddy_get_protocol_data(buddy);
    purple_debug_info("bnet", "poll buddy tooltip %s \n", buddy->name);
    if (bfi == ((void *)0)) {

        purple_notify_user_info_add_pair_plaintext(info, "Status", "Not on Battle.net's friend list.");
    } else if (bfi->type == 0x02 && ((BnetFriendInfo *)bfi)->location != BNET_FRIEND_LOCATION_OFFLINE) {

        gboolean is_available = (!(0));
        purple_notify_user_info_add_pair_plaintext(info, "Mutual",
                (((BnetFriendInfo *)bfi)->status & BNET_FRIEND_STATUS_MUTUAL) ? "Yes" : "No");

        if (full) {
            gchar *location_text = bnet_get_location_text(((BnetFriendInfo *)bfi)->location, ((BnetFriendInfo *)bfi)->location_name);
            purple_notify_user_info_add_pair_plaintext(info, "Location", location_text);
            g_free(location_text);
            purple_notify_user_info_add_pair_plaintext(info, "Product",
                    bnet_get_product_name(((BnetFriendInfo *)bfi)->product));
        }

        if (((BnetFriendInfo *)bfi)->status & BNET_FRIEND_STATUS_DND) {
            purple_notify_user_info_add_pair_plaintext(info, "Status",
                    g_strdup_printf("Do Not Disturb - %s", ((BnetFriendInfo *)bfi)->dnd_stored_status));
            is_available = (0);
        }
        if (((BnetFriendInfo *)bfi)->status & BNET_FRIEND_STATUS_AWAY) {
            purple_notify_user_info_add_pair_plaintext(info, "Status",
                    g_strdup_printf("Away - %s", ((BnetFriendInfo *)bfi)->away_stored_status));
            is_available = (0);
        }
        if (is_available) {
            purple_notify_user_info_add_pair_plaintext(info, "Status", "Available");
        }
    } else if (bfi->type == 0x04) {
        BnetClanMember *bcmi = (BnetClanMember *)bfi;
        if (bnet_clan_member_get_status(bcmi) != BNET_CLAN_STATUS_OFFLINE) {
            purple_notify_user_info_add_pair_plaintext(info, "Status", "Online");
        }
        purple_notify_user_info_add_pair_plaintext(info, "Clan rank", bnet_clan_rank_to_string(bnet_clan_member_get_rank(bcmi)));
        if (bnet_clan_member_get_joindate(bcmi) != 0) {
            gchar *s_joindate = bnet_format_filetime(bnet_clan_member_get_joindate(bcmi));
            purple_notify_user_info_add_pair_plaintext(info, "Clan join date", s_joindate);
            g_free(s_joindate);
        }
    }
}

static char *
bnet_get_location_text(BnetFriendLocation location, char *location_name)
{
    switch (location)
    {
        case BNET_FRIEND_LOCATION_OFFLINE:
            return g_strdup("Offline");
        default:
        case BNET_FRIEND_LOCATION_ONLINE:
            return g_strdup("Nowhere");
        case BNET_FRIEND_LOCATION_CHANNEL:
            if (strlen(location_name) > 0) {
                return g_strdup_printf("in channel %s", location_name);
            } else {
                return g_strdup("In a private channel");
            }
        case BNET_FRIEND_LOCATION_GAME_PUBLIC:
            if (strlen(location_name) > 0) {
                return g_strdup_printf("In the public game %s", location_name);
            } else {
                return g_strdup("In a public game");
            }
        case BNET_FRIEND_LOCATION_GAME_PRIVATE:
            if (strlen(location_name) > 0) {
                return g_strdup_printf("In the private game %s", location_name);
            } else {
                return g_strdup("In a private game");
            }
        case BNET_FRIEND_LOCATION_GAME_PROTECTED:
            if (strlen(location_name) > 0) {
                return g_strdup_printf("In the password protected game %s", location_name);
            } else {
                return g_strdup("In a password protected game");
            }
    }
}

static char *
bnet_get_product_name(BnetProductID product)
{
    switch (product)
    {
        case (0x53544152):
            return "Starcraft";
        case (0x53415850):
            return "Starcraft Broodwar";
        case (0x5732424e):
            return "Warcraft II";
        case (0x44324456):
            return "Diablo II";
        case (0x44325850):
            return "Diablo II Lord of Destruction";
        case (0x57415233):
            return "Warcraft III";
        case (0x57335850):
            return "Warcraft III The Frozen Throne";
        case (0x4452544c):
            return "Diablo";
        case (0x44534852):
            return "Diablo Shareware";
        case (0x53534852):
            return "Starcraft Shareware";
        case (0x4a535452):
            return "Starcraft Japanese";
        case (0x43484152):
            return "Telnet Chat";
        default:
            return "Unknown";
    }
}

static gchar *
bnet_get_product_id_str(BnetProductID product)
{
    return bnet_tag_to_string(product);
}

static GList *
bnet_status_types(PurpleAccount *account)
{
    PurpleStatusType *type;
    GList *types = ((void *)0);

    type = purple_status_type_new(PURPLE_STATUS_AVAILABLE,
            "Online", ((void *)0), (!(0)));
    types = g_list_append(types, type);

    type = purple_status_type_new_with_attrs(PURPLE_STATUS_AWAY,
            "Away", ((void *)0), (!(0)), (!(0)), (0),
            "message", "Message", purple_value_new(PURPLE_TYPE_STRING),
            ((void *)0));
    types = g_list_append(types, type);

    type = purple_status_type_new_with_attrs(PURPLE_STATUS_UNAVAILABLE,
            "Do not disturb", ((void *)0), (!(0)), (!(0)), (0),
            "message", "Message", purple_value_new(PURPLE_TYPE_STRING),
            ((void *)0));
    types = g_list_append(types, type);

    type = purple_status_type_new(PURPLE_STATUS_OFFLINE,
            "Offline", ((void *)0), (!(0)));
    types = g_list_append(types, type);

    return types;
}

static void
bnet_add_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)
{
    BnetConnectionData *bnet = gc->proto_data;

    const char *username = purple_buddy_get_name(buddy);

    char *cmd = g_strdup_printf("/f a %s",
            username);
    if (bnet_is_telnet(bnet)) {
        bnet_send_telnet_line(bnet, cmd);
    } else {
        bnet_send_CHATCOMMAND(bnet, cmd);
    }
    g_free(cmd);
}

static void
bnet_remove_buddy(PurpleConnection *gc, PurpleBuddy *buddy, PurpleGroup *group)
{
    BnetConnectionData *bnet = gc->proto_data;

    const char *username = purple_buddy_get_name(buddy);
    BnetUser *bfi = purple_buddy_get_protocol_data(buddy);

    char *cmd;


    if (bfi == ((void *)0)) return;

    if (bfi->type == 0x02) {
        GList *el;
        cmd = g_strdup_printf("/f r %s", username);
        if (bnet_is_telnet(bnet)) {
            bnet_send_telnet_line(bnet, cmd);
        } else {
            bnet_send_CHATCOMMAND(bnet, cmd);
        }
        g_free(cmd);




        el = g_list_first(bnet->bncs.friends.list);
        while (el != ((void *)0)) {
            if (el->data != ((void *)0)) {
                BnetUser *bfi_link = el->data;
                if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (bfi_link->username) && __builtin_constant_p (bfi->username) && (__s1_len = strlen (bfi_link->username), __s2_len = strlen (bfi->username), (!((size_t)(const void *)((bfi_link->username) + 1) - (size_t)(const void *)(bfi_link->username) == 1) || __s1_len >= 4) && (!((size_t)(const void *)((bfi->username) + 1) - (size_t)(const void *)(bfi->username) == 1) || __s2_len >= 4)) ? __builtin_strcmp (bfi_link->username, bfi->username) : (__builtin_constant_p (bfi_link->username) && ((size_t)(const void *)((bfi_link->username) + 1) - (size_t)(const void *)(bfi_link->username) == 1) && (__s1_len = strlen (bfi_link->username), __s1_len < 4) ? (__builtin_constant_p (bfi->username) && ((size_t)(const void *)((bfi->username) + 1) - (size_t)(const void *)(bfi->username) == 1) ? __builtin_strcmp (bfi_link->username, bfi->username) : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) (bfi->username); register int __result = (((const unsigned char *) (const char *) (bfi_link->username))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (bfi_link->username))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (bfi_link->username))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (bfi_link->username))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p (bfi->username) && ((size_t)(const void *)((bfi->username) + 1) - (size_t)(const void *)(bfi->username) == 1) && (__s2_len = strlen (bfi->username), __s2_len < 4) ? (__builtin_constant_p (bfi_link->username) && ((size_t)(const void *)((bfi_link->username) + 1) - (size_t)(const void *)(bfi_link->username) == 1) ? __builtin_strcmp (bfi_link->username, bfi->username) : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (bfi_link->username); register int __result = __s1[0] - ((const unsigned char *) (const char *) (bfi->username))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) (bfi->username))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) (bfi->username))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) (bfi->username))[3]); } } __result; }))) : __builtin_strcmp (bfi_link->username, bfi->username)))); }) == 0) {
                    el->data = ((void *)0);
                }
            }
            el = ((el) ? (((GList *)(el))->next) : ((void *)0));
        }
    }
}

static PurpleRoomlist *
bnet_roomlist_get_list(PurpleConnection *gc)
{
    BnetConnectionData *bnet = gc->proto_data;
    GList *fields = ((void *)0);
    PurpleRoomlistField *f;
    PurpleRoomlistRoom *r;

    if (bnet->bncs.chat_env.prpl_room_list_handle)
        purple_roomlist_unref(bnet->bncs.chat_env.prpl_room_list_handle);

    bnet->bncs.chat_env.prpl_room_list_handle = purple_roomlist_new(purple_connection_get_account(gc));

    f = purple_roomlist_field_new(PURPLE_ROOMLIST_FIELD_STRING, "", "channel", (!(0)));
    fields = g_list_append(fields, f);

    purple_roomlist_set_fields(bnet->bncs.chat_env.prpl_room_list_handle, fields);

    if (bnet->bncs.chat_env.channel_list != ((void *)0)) {
        GList *room_el = g_list_first(bnet->bncs.chat_env.channel_list);
        r = purple_roomlist_room_new(PURPLE_ROOMLIST_ROOMTYPE_ROOM,
                (char *)room_el->data, ((void *)0));
        purple_roomlist_room_add(bnet->bncs.chat_env.prpl_room_list_handle, r);
        while (((room_el) ? (((GList *)(room_el))->next) : ((void *)0)) != ((void *)0)) {
            room_el = ((room_el) ? (((GList *)(room_el))->next) : ((void *)0));
            r = purple_roomlist_room_new(PURPLE_ROOMLIST_ROOMTYPE_ROOM,
                    (char *)room_el->data, ((void *)0));
            purple_roomlist_room_add(bnet->bncs.chat_env.prpl_room_list_handle, r);
        }
    }

    purple_roomlist_set_in_progress(bnet->bncs.chat_env.prpl_room_list_handle, (0));

    return bnet->bncs.chat_env.prpl_room_list_handle;
}

static void
bnet_roomlist_cancel(PurpleRoomlist *list)
{
    PurpleConnection *gc = purple_account_get_connection(list->account);
    BnetConnectionData *bnet;

    if (gc == ((void *)0))
        return;

    bnet = gc->proto_data;

    purple_roomlist_set_in_progress(list, (0));

    if (bnet->bncs.chat_env.prpl_room_list_handle == list) {
        bnet->bncs.chat_env.prpl_room_list_handle = ((void *)0);
        purple_roomlist_unref(list);
    }
}

static void
bnet_set_status(PurpleAccount *account, PurpleStatus *status)
{
    const char *msg = purple_status_get_attr_string(status, "message");
    const char *type = purple_status_get_name(status);
    PurpleConnection *gc = purple_account_get_connection(account);
    BnetConnectionData *bnet = gc->proto_data;

    if (purple_status_is_online(status)) {
        if (purple_status_is_available(status)) {

            if (bnet->bncs.status.status & BNET_FRIEND_STATUS_AWAY) {
                bnet_set_away(bnet, (0), ((void *)0));
            }
            if (bnet->bncs.status.status & BNET_FRIEND_STATUS_DND) {
                bnet_set_dnd(bnet, (0), ((void *)0));
            }
        } else {
            if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (type) && __builtin_constant_p ("Away") && (__s1_len = strlen (type), __s2_len = strlen ("Away"), (!((size_t)(const void *)((type) + 1) - (size_t)(const void *)(type) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("Away") + 1) - (size_t)(const void *)("Away") == 1) || __s2_len >= 4)) ? __builtin_strcmp (type, "Away") : (__builtin_constant_p (type) && ((size_t)(const void *)((type) + 1) - (size_t)(const void *)(type) == 1) && (__s1_len = strlen (type), __s1_len < 4) ? (__builtin_constant_p ("Away") && ((size_t)(const void *)(("Away") + 1) - (size_t)(const void *)("Away") == 1) ? __builtin_strcmp (type, "Away") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("Away"); register int __result = (((const unsigned char *) (const char *) (type))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (type))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (type))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (type))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("Away") && ((size_t)(const void *)(("Away") + 1) - (size_t)(const void *)("Away") == 1) && (__s2_len = strlen ("Away"), __s2_len < 4) ? (__builtin_constant_p (type) && ((size_t)(const void *)((type) + 1) - (size_t)(const void *)(type) == 1) ? __builtin_strcmp (type, "Away") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (type); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("Away"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("Away"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("Away"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("Away"))[3]); } } __result; }))) : __builtin_strcmp (type, "Away")))); }) == 0) {
                if (bnet->bncs.status.status & BNET_FRIEND_STATUS_DND) {
                    purple_debug_info("bnet", "unsetting dnd\n");
                    bnet_set_dnd(bnet, (0), ((void *)0));
                }
                purple_debug_info("bnet", "setting away %s\n", msg);
                bnet_set_away(bnet, (!(0)), msg);
            } else if (__extension__ ({ size_t __s1_len, __s2_len; (__builtin_constant_p (type) && __builtin_constant_p ("Do not disturb") && (__s1_len = strlen (type), __s2_len = strlen ("Do not disturb"), (!((size_t)(const void *)((type) + 1) - (size_t)(const void *)(type) == 1) || __s1_len >= 4) && (!((size_t)(const void *)(("Do not disturb") + 1) - (size_t)(const void *)("Do not disturb") == 1) || __s2_len >= 4)) ? __builtin_strcmp (type, "Do not disturb") : (__builtin_constant_p (type) && ((size_t)(const void *)((type) + 1) - (size_t)(const void *)(type) == 1) && (__s1_len = strlen (type), __s1_len < 4) ? (__builtin_constant_p ("Do not disturb") && ((size_t)(const void *)(("Do not disturb") + 1) - (size_t)(const void *)("Do not disturb") == 1) ? __builtin_strcmp (type, "Do not disturb") : (__extension__ ({ const unsigned char *__s2 = (const unsigned char *) (const char *) ("Do not disturb"); register int __result = (((const unsigned char *) (const char *) (type))[0] - __s2[0]); if (__s1_len > 0 && __result == 0) { __result = (((const unsigned char *) (const char *) (type))[1] - __s2[1]); if (__s1_len > 1 && __result == 0) { __result = (((const unsigned char *) (const char *) (type))[2] - __s2[2]); if (__s1_len > 2 && __result == 0) __result = (((const unsigned char *) (const char *) (type))[3] - __s2[3]); } } __result; }))) : (__builtin_constant_p ("Do not disturb") && ((size_t)(const void *)(("Do not disturb") + 1) - (size_t)(const void *)("Do not disturb") == 1) && (__s2_len = strlen ("Do not disturb"), __s2_len < 4) ? (__builtin_constant_p (type) && ((size_t)(const void *)((type) + 1) - (size_t)(const void *)(type) == 1) ? __builtin_strcmp (type, "Do not disturb") : (__extension__ ({ const unsigned char *__s1 = (const unsigned char *) (const char *) (type); register int __result = __s1[0] - ((const unsigned char *) (const char *) ("Do not disturb"))[0]; if (__s2_len > 0 && __result == 0) { __result = (__s1[1] - ((const unsigned char *) (const char *) ("Do not disturb"))[1]); if (__s2_len > 1 && __result == 0) { __result = (__s1[2] - ((const unsigned char *) (const char *) ("Do not disturb"))[2]); if (__s2_len > 2 && __result == 0) __result = (__s1[3] - ((const unsigned char *) (const char *) ("Do not disturb"))[3]); } } __result; }))) : __builtin_strcmp (type, "Do not disturb")))); }) == 0) {
                if (bnet->bncs.status.status & BNET_FRIEND_STATUS_AWAY) {
                    purple_debug_info("bnet", "unsetting away\n");
                    bnet_set_away(bnet, (0), ((void *)0));
                }
                purple_debug_info("bnet", "setting dnd %s\n", msg);
                bnet_set_dnd(bnet, (!(0)), msg);
            } else {
                purple_debug_info("bnet", "setting %s %s\n", type, msg);
            }
        }
    }
}

static void
bnet_set_away(BnetConnectionData *bnet, gboolean new_state, const gchar *message)
{
    char *msg;
    if (message == ((void *)0) || strlen(message) == 0) {
        msg = g_strdup("Not available");
    } else {
        msg = g_strdup(message);
    }

    bnet->bncs.status.status_pending |= BNET_FRIEND_STATUS_AWAY;
    if (new_state) {
        char *msg_s = purple_markup_strip_html(msg);
        char *cmd = g_strdup_printf("/away %s", msg);
        if (bnet_is_telnet(bnet)) {
            bnet_send_telnet_line(bnet, cmd);
        } else {
            bnet_send_CHATCOMMAND(bnet, cmd);
        }
        g_free(msg_s);
        g_free(cmd);

        if (bnet->bncs.status.away_msg != ((void *)0)) {
            g_free(bnet->bncs.status.away_msg);
        }
        bnet->bncs.status.away_msg = msg;
    } else {
        char *cmd = "/away";
        if (bnet_is_telnet(bnet)) {
            bnet_send_telnet_line(bnet, cmd);
        } else {
            bnet_send_CHATCOMMAND(bnet, cmd);
        }

        if (bnet->bncs.status.away_msg != ((void *)0)) {
            g_free(bnet->bncs.status.away_msg);
        }
        bnet->bncs.status.away_msg = ((void *)0);
        g_free(msg);
    }
}

static void
bnet_set_dnd(BnetConnectionData *bnet, gboolean new_state, const gchar *message)
{
    char *msg;
    if (message == ((void *)0) || strlen(message) == 0) {
        msg = g_strdup("Not available");
    } else {
        msg = g_strdup(message);
    }

    bnet->bncs.status.status_pending |= BNET_FRIEND_STATUS_DND;
    if (new_state) {
        char *msg_s = purple_markup_strip_html(msg);
        char *cmd = g_strdup_printf("/dnd %s", msg);
        if (bnet_is_telnet(bnet)) {
            bnet_send_telnet_line(bnet, cmd);
        } else {
            bnet_send_CHATCOMMAND(bnet, cmd);
        }
        g_free(msg_s);
        g_free(cmd);

        if (bnet->bncs.status.dnd_msg != ((void *)0)) {
            g_free(bnet->bncs.status.dnd_msg);
        }
        bnet->bncs.status.dnd_msg = msg;
    } else {
        char *cmd = "/dnd";
        if (bnet_is_telnet(bnet)) {
            bnet_send_telnet_line(bnet, cmd);
        } else {
            bnet_send_CHATCOMMAND(bnet, cmd);
        }

        if (bnet->bncs.status.dnd_msg != ((void *)0)) {
            g_free(bnet->bncs.status.dnd_msg);
        }
        bnet->bncs.status.dnd_msg = ((void *)0);
        g_free(msg);
    }
}

static const char *
bnet_normalize(const PurpleAccount *account, const char *in)
{
    static char out[64];

    char *o = g_ascii_strdown(in, -1);
    do { memmove (((char *)out), (o), (strlen(o) + 1)); } while (0);
    g_free(o);

    return out;
}

static const char *
bnet_d2_normalize(const PurpleAccount *account, const char *in)
{
    PurpleConnection *gc = ((void *)0);
    BnetConnectionData *bnet = ((void *)0);
    static char o[64];
    char *d2norm = ((void *)0);

    if (account != ((void *)0)) gc = purple_account_get_connection(account);

    if (gc != ((void *)0)) bnet = gc->proto_data;

    if (bnet != ((void *)0) && bnet_is_d2(bnet))
    {
        char *d2_star = g_strstr_len(in, 30, "*");
        if (d2_star != ((void *)0)) {



            d2norm = g_strdup(d2_star + 1);
            if (d2_star > in + 1) {
                if (*(d2_star - 1) == '(' && *(d2_star - 2) == ' ') {


                    *(d2norm + strlen(d2norm) - 1) = '\0';
                }
            }
        }
    }
    if (d2norm == ((void *)0)) {
        d2norm = g_strdup(in);
    }

    do { memmove (((char *)o), (d2norm), (strlen(d2norm) + 1)); } while (0);
    g_free(d2norm);
    return o;
}

static const char *
bnet_d2_get_character(const PurpleAccount *account, const char *in)
{
    PurpleConnection *gc = ((void *)0);
    BnetConnectionData *bnet = ((void *)0);
    static char o[64];
    char *d2norm = ((void *)0);

    if (account != ((void *)0)) gc = purple_account_get_connection(account);

    if (gc != ((void *)0)) bnet = gc->proto_data;

    if (bnet != ((void *)0) && bnet_is_d2(bnet)) {
        char *d2_star;
        char *d2_at;
        d2norm = g_strdup(in);
        d2_star = g_strstr_len(d2norm, 30, "*");
        if (d2_star != ((void *)0)) {



            *d2_star = '\0';
            if (strlen(d2norm) == 0) {

                g_free(d2norm);
                return ((void *)0);
            }
            if (d2_star > d2norm + 1) {
                if (*(d2_star - 1) == '(' && *(d2_star - 2) == ' ') {


                    *(d2_star - 2) = '\0';
                }
            }
            d2_at = g_strstr_len(d2norm, 30, "@");
            if (d2_at != ((void *)0)) {

                *d2_at = '\0';
                if (strlen(d2norm) == 0) {
                    g_free(d2norm);
                    return ((void *)0);
                }
            }
        } else {
            g_free(d2norm);
            return ((void *)0);
        }
    } else {
        return ((void *)0);
    }

    do { memmove (((char *)o), (d2norm), (strlen(d2norm) + 1)); } while (0);
    g_free(d2norm);
    return o;
}

static const char *
bnet_d2_get_realm(const PurpleAccount *account, const char *in)
{
    PurpleConnection *gc = ((void *)0);
    BnetConnectionData *bnet = ((void *)0);
    static char o[64];
    char *d2norm = ((void *)0);

    if (account != ((void *)0)) gc = purple_account_get_connection(account);

    if (gc != ((void *)0)) bnet = gc->proto_data;

    if (bnet != ((void *)0) && bnet_is_d2(bnet)) {
        char *d2_star;
        char *d2_at;
        d2norm = g_strdup(in);
        d2_star = g_strstr_len(d2norm, 30, "*");
        if (d2_star != ((void *)0)) {



            *d2_star = '\0';
            if (strlen(d2norm) == 0) {

                g_free(d2norm);
                return ((void *)0);
            }
            if (d2_star > d2norm + 1) {
                if (*(d2_star - 1) == '(' && *(d2_star - 2) == ' ') {


                    *(d2_star - 2) = '\0';
                }
            }
            d2_at = g_strstr_len(d2norm, 30, "@");
            if (d2_at != ((void *)0)) {

                char *tmp = g_strdup(d2_at + 1);
                g_free(d2norm);
                d2norm = tmp;
                if (strlen(d2norm) == 0) {
                    g_free(d2norm);
                    return ((void *)0);
                }
            } else {
                g_free(d2norm);
                return ((void *)0);
            }
        } else {
            g_free(d2norm);
            return ((void *)0);
        }
    } else {
        return ((void *)0);
    }

    do { memmove (((char *)o), (d2norm), (strlen(d2norm) + 1)); } while (0);
    g_free(d2norm);
    return o;
}



static const char *
bnet_account_normalize(const PurpleAccount *account, const char *in)
{
    static char o[64];
    char *out = g_strdup(in);
    char *poundloc = ((void *)0);
    poundloc = g_strstr_len(out, strlen(out), "#");
    if (poundloc != ((void *)0)) {
        int i = 0, j = 0;
        gboolean is_gateway = (0);
        for (; i < strlen(poundloc); ) {
            if (poundloc[i] == '@')
                is_gateway = (!(0));




            if (is_gateway) {
                poundloc[j] = poundloc[i];
                j++;
            }

            i++;
        }
        poundloc[j] = poundloc[i];
    }
    do { memmove (((char *)o), (out), (strlen(out) + 1)); } while (0);
    g_free(out);
    return o;
}



static const char *
bnet_gateway_normalize(const PurpleAccount *account, const char *in)
{
    static char out[64];

    char *o = g_strdup(in);
    int i;

    for (i = 0; i < 64; i++) {
        if (o[i] == '\0') {
            break;
        }
        if (i > 0 && o[i] == '@') {
            o[i] = '\0';
            break;
        }
    }
    do { memmove (((char *)out), (o), (strlen(o) + 1)); } while (0);
    g_free(o);

    return out;
}

static GList *
bnet_actions(PurplePlugin *plugin, gpointer context)
{
    GList *list = ((void *)0);
    PurplePluginAction *action = ((void *)0);
    PurpleConnection *gc = ((void *)0);
    BnetConnectionData *bnet = ((void *)0);
    BnetClanMemberRank my_rank = 0;

    gc = context;
    bnet = gc->proto_data;

    action = purple_plugin_action_new("Set User Info...", bnet_action_set_user_data);
    list = g_list_append(list, action);

    action = purple_plugin_action_new("Show News and MOTD...", bnet_action_show_news);
    list = g_list_append(list, action);

    if (bnet_clan_in_clan(bnet)) {
        my_rank = bnet->bncs.w3_clan.my_rank;
        if (my_rank == BNET_CLAN_RANK_SHAMAN || my_rank == BNET_CLAN_RANK_CHIEFTAIN) {
            action = purple_plugin_action_new("Set Clan MOTD...", bnet_action_set_motd);
            list = g_list_append(list, action);
        }
    }

    return list;
}

static void
bnet_rename_group(PurpleConnection *gc, const char *old_name, PurpleGroup *group, GList *moved_buddies)
{

}

static PurplePluginProtocolInfo prpl_info =
{
    OPT_PROTO_CHAT_TOPIC |
    OPT_PROTO_SLASH_COMMANDS_NATIVE,
    ((void *)0),
    ((void *)0),
    {((void *)0), 0, 0, 0, 0, 0, 0},
    bnet_list_icon,
    bnet_list_emblem,
    bnet_status_text,
    bnet_tooltip_text,
    bnet_status_types,
    ((void *)0),
    bnet_chat_info,
    bnet_chat_info_defaults,
    bnet_login,
    bnet_close,
    bnet_send_whisper,
    ((void *)0),
    ((void *)0),
    bnet_lookup_info,
    bnet_set_status,
    ((void *)0),
    bnet_account_chpw,
    bnet_add_buddy,
    ((void *)0),
    bnet_remove_buddy,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    bnet_join_chat,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    bnet_chat_im,
    bnet_keepalive,
    bnet_account_register,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    bnet_rename_group,
    bnet_buddy_free,
    ((void *)0),
    bnet_normalize,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    bnet_roomlist_get_list,
    bnet_roomlist_cancel,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    bnet_send_raw,
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    sizeof(PurplePluginProtocolInfo),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
};

static PurplePluginInfo info =
{
    5,
    (2),
    (10),
    PURPLE_PLUGIN_PROTOCOL,
    ((void *)0),
    0,
    ((void *)0),
    0,

    "prpl-ribose-bnet",
    "Classic Battle.net",
    "1.0.0",
    "Classic Battle.net Protocol Plugin",
    "Classic Battle.net Chat Server Protocol. Allows you to connect to classic Battle.net to chat with users on StarCraft, Diablo/II, and WarCraft II/III and their expansions.",
    "Nate Book <nmbook@gmail.com>",
    "http://www.natembook.com",

    ((void *)0),
    ((void *)0),
    ((void *)0),

    ((void *)0),
    &prpl_info,
    ((void *)0),
    bnet_actions,

    ((void *)0),
    ((void *)0),
    ((void *)0),
    ((void *)0),
};

static void
init_plugin(PurplePlugin *plugin)
{
    PurpleAccountUserSplit *split = ((void *)0);
    PurpleAccountOption *option = ((void *)0);
    GList *optlist = ((void *)0);
    PurpleKeyValuePair *kvp = ((void *)0);
    char *prpl_name = "prpl-ribose-bnet";
    PurpleCmdFlag flags = 0;
    struct BnetCommand *c = ((void *)0);
    int i;

    flags |= PURPLE_CMD_FLAG_CHAT;
    flags |= PURPLE_CMD_FLAG_IM;
    flags |= PURPLE_CMD_FLAG_PRPL_ONLY;
    flags |= PURPLE_CMD_FLAG_ALLOW_WRONG_ARGS;

    split = purple_account_user_split_new("Server", "uswest.battle.net", '@');
    prpl_info.user_splits = g_list_append(prpl_info.user_splits, split);

    option = purple_account_option_int_new("Port", "port", 6112);
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("StarCraft");
    kvp->value = g_strdup("RATS");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("StarCraft: Brood War");
    kvp->value = g_strdup("PXES");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("WarCraft II: Battle.net Edition");
    kvp->value = g_strdup("NB2W");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("Diablo II");
    kvp->value = g_strdup("VD2D");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("Diablo II: Lord of Destruction");
    kvp->value = g_strdup("PX2D");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("WarCraft III");
    kvp->value = g_strdup("3RAW");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("WarCraft III: The Frozen Throne");
    kvp->value = g_strdup("PX3W");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("StarCraft: Shareware");
    kvp->value = g_strdup("RHSS");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("StarCraft: Japanese");
    kvp->value = g_strdup("RTSJ");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("Diablo");
    kvp->value = g_strdup("LTRD");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("Diablo: Shareware");
    kvp->value = g_strdup("RHSD");
    optlist = g_list_append(optlist, kvp);

    kvp = (PurpleKeyValuePair *) (__extension__ ({ gsize __n = (gsize) (1); gsize __s = sizeof (PurpleKeyValuePair); gpointer __p; if (__s == 1) __p = g_malloc0 (__n); else if (__builtin_constant_p (__n) && (__s == 0 || __n <= (9223372036854775807L * 2UL + 1UL) / __s)) __p = g_malloc0 (__n * __s); else __p = g_malloc0_n (__n, __s); __p; }));
    kvp->key = g_strdup("Chat Client");
    kvp->value = g_strdup("TAHC");
    optlist = g_list_append(optlist, kvp);

    option = purple_account_option_list_new("Game Client", "product", optlist);
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_string_new("CD Key", "key1", "");
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_string_new("Expansion CD Key", "key2", "");
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_string_new("Key Owner", "key_owner", "");
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_string_new("Logon Server", "bnlsserver", "bnls.net");
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_bool_new("Show ban messages", "showbans", (!(0)));
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_string_new("Default friends group", "grpfriends", "Friends");
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_string_new("Default clan members group", "grpclan", "Clan %T members");
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_bool_new("Show mutual friend status-change messages", "showmutual", (0));
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_bool_new("Show clan members on buddy list (buggy)", "showgrpclan", (0));
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    option = purple_account_option_bool_new("Use Diablo II character (buggy)", "use_d2realm", (0));
    prpl_info.protocol_options = g_list_append(prpl_info.protocol_options, option);

    for (c = bnet_cmds; c && c->name; c++) {
        purple_cmd_register(c->name, c->args, PURPLE_CMD_P_PRPL, flags,
                prpl_name, bnet_handle_cmd, c->helptext, c);
    }

    i = 0;
    while (bnet_regex_store[i].regex_str != ((void *)0)) {
        GError *err = ((void *)0);
        bnet_regex_store[i].regex = g_regex_new(bnet_regex_store[i].regex_str, G_REGEX_OPTIMIZE, G_REGEX_MATCH_ANCHORED, &err);
        if (err != ((void *)0)) {
            purple_debug_warning("bnet", "Regex creation failed: %s\n", err->message);
            g_error_free(err);
        }
        i++;
    }
}

 gboolean purple_init_plugin(PurplePlugin *plugin); gboolean purple_init_plugin(PurplePlugin *plugin) { plugin->info = &(info); init_plugin((plugin)); return purple_plugin_register(plugin); }
